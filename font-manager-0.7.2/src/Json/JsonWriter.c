/* JsonWriter.c generated by valac 0.26.1, the Vala compiler
 * generated from JsonWriter.vala, do not modify */

/* JsonWriter.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <json-glib/json-glib.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define TYPE_JSON_WRITER (json_writer_get_type ())
#define JSON_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_JSON_WRITER, JsonWriter))
#define JSON_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_JSON_WRITER, JsonWriterClass))
#define IS_JSON_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_JSON_WRITER))
#define IS_JSON_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_JSON_WRITER))
#define JSON_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_JSON_WRITER, JsonWriterClass))

typedef struct _JsonWriter JsonWriter;
typedef struct _JsonWriterClass JsonWriterClass;
typedef struct _JsonWriterPrivate JsonWriterPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _JsonWriter {
	JsonGenerator parent_instance;
	JsonWriterPrivate * priv;
};

struct _JsonWriterClass {
	JsonGeneratorClass parent_class;
};

struct _JsonWriterPrivate {
	gboolean _compress;
};


static gpointer json_writer_parent_class = NULL;

GType json_writer_get_type (void) G_GNUC_CONST;
#define JSON_WRITER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_JSON_WRITER, JsonWriterPrivate))
enum  {
	JSON_WRITER_DUMMY_PROPERTY,
	JSON_WRITER_COMPRESS
};
JsonWriter* json_writer_new (JsonNode* root);
JsonWriter* json_writer_construct (GType object_type, JsonNode* root);
gboolean json_writer_to_file (JsonWriter* self, const gchar* filepath, gboolean use_backup);
gboolean json_writer_get_compress (JsonWriter* self);
void json_writer_set_compress (JsonWriter* self, gboolean value);
static void json_writer_finalize (GObject* obj);
static void _vala_json_writer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_json_writer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gboolean write_json_file (JsonNode* root, const gchar* filepath, gboolean compress, gboolean backup);
JsonNode* load_json_file (const gchar* filepath, gboolean compressed);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);


JsonWriter* json_writer_construct (GType object_type, JsonNode* root) {
	JsonWriter * self = NULL;
	JsonNode* _tmp0_ = NULL;
	g_return_val_if_fail (root != NULL, NULL);
	_tmp0_ = root;
	self = (JsonWriter*) g_object_new (object_type, "indent", 4, "pretty", TRUE, "root", _tmp0_, NULL);
	return self;
}


JsonWriter* json_writer_new (JsonNode* root) {
	return json_writer_construct (TYPE_JSON_WRITER, root);
}


gboolean json_writer_to_file (JsonWriter* self, const gchar* filepath, gboolean use_backup) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (filepath != NULL, FALSE);
	{
		GFile* file = NULL;
		const gchar* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		GFileOutputStream* stream = NULL;
		GFile* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		GFileOutputStream* _tmp4_ = NULL;
		GFile* parent = NULL;
		GFile* _tmp5_ = NULL;
		GFile* _tmp6_ = NULL;
		GFile* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		gboolean _tmp10_ = FALSE;
		_tmp0_ = filepath;
		_tmp1_ = g_file_new_for_path (_tmp0_);
		file = _tmp1_;
		_tmp2_ = file;
		_tmp3_ = use_backup;
		_tmp4_ = g_file_replace (_tmp2_, NULL, _tmp3_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		stream = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch40_g_error;
		}
		_tmp5_ = file;
		_tmp6_ = g_file_get_parent (_tmp5_);
		parent = _tmp6_;
		_tmp7_ = parent;
		_tmp8_ = g_file_query_exists (_tmp7_, NULL);
		if (!_tmp8_) {
			GFile* _tmp9_ = NULL;
			_tmp9_ = parent;
			g_file_make_directory_with_parents (_tmp9_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (parent);
				_g_object_unref0 (stream);
				_g_object_unref0 (file);
				goto __catch40_g_error;
			}
		}
		_tmp10_ = self->priv->_compress;
		if (_tmp10_) {
			GZlibCompressor* compressor = NULL;
			GZlibCompressor* _tmp11_ = NULL;
			GConverterOutputStream* compressed_stream = NULL;
			GFileOutputStream* _tmp12_ = NULL;
			GZlibCompressor* _tmp13_ = NULL;
			GConverterOutputStream* _tmp14_ = NULL;
			GConverterOutputStream* _tmp15_ = NULL;
			_tmp11_ = g_zlib_compressor_new (G_ZLIB_COMPRESSOR_FORMAT_ZLIB, -1);
			compressor = _tmp11_;
			_tmp12_ = stream;
			_tmp13_ = compressor;
			_tmp14_ = (GConverterOutputStream*) g_converter_output_stream_new ((GOutputStream*) _tmp12_, (GConverter*) _tmp13_);
			compressed_stream = _tmp14_;
			_tmp15_ = compressed_stream;
			json_generator_to_stream ((JsonGenerator*) self, (GOutputStream*) _tmp15_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (compressed_stream);
				_g_object_unref0 (compressor);
				_g_object_unref0 (parent);
				_g_object_unref0 (stream);
				_g_object_unref0 (file);
				goto __catch40_g_error;
			}
			_g_object_unref0 (compressed_stream);
			_g_object_unref0 (compressor);
		} else {
			GFileOutputStream* _tmp16_ = NULL;
			_tmp16_ = stream;
			json_generator_to_stream ((JsonGenerator*) self, (GOutputStream*) _tmp16_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (parent);
				_g_object_unref0 (stream);
				_g_object_unref0 (file);
				goto __catch40_g_error;
			}
		}
		result = TRUE;
		_g_object_unref0 (parent);
		_g_object_unref0 (stream);
		_g_object_unref0 (file);
		return result;
	}
	goto __finally40;
	__catch40_g_error:
	{
		GError* e = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		g_warning ("JsonWriter.vala:51: %s", _tmp18_);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally40:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


gboolean json_writer_get_compress (JsonWriter* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_compress;
	result = _tmp0_;
	return result;
}


void json_writer_set_compress (JsonWriter* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_compress = _tmp0_;
	g_object_notify ((GObject *) self, "compress");
}


static void json_writer_class_init (JsonWriterClass * klass) {
	json_writer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (JsonWriterPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_json_writer_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_json_writer_set_property;
	G_OBJECT_CLASS (klass)->finalize = json_writer_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), JSON_WRITER_COMPRESS, g_param_spec_boolean ("compress", "compress", "compress", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void json_writer_instance_init (JsonWriter * self) {
	self->priv = JSON_WRITER_GET_PRIVATE (self);
	self->priv->_compress = FALSE;
}


static void json_writer_finalize (GObject* obj) {
	JsonWriter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_JSON_WRITER, JsonWriter);
	G_OBJECT_CLASS (json_writer_parent_class)->finalize (obj);
}


GType json_writer_get_type (void) {
	static volatile gsize json_writer_type_id__volatile = 0;
	if (g_once_init_enter (&json_writer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (JsonWriterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) json_writer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (JsonWriter), 0, (GInstanceInitFunc) json_writer_instance_init, NULL };
		GType json_writer_type_id;
		json_writer_type_id = g_type_register_static (json_generator_get_type (), "JsonWriter", &g_define_type_info, 0);
		g_once_init_leave (&json_writer_type_id__volatile, json_writer_type_id);
	}
	return json_writer_type_id__volatile;
}


static void _vala_json_writer_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	JsonWriter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_JSON_WRITER, JsonWriter);
	switch (property_id) {
		case JSON_WRITER_COMPRESS:
		g_value_set_boolean (value, json_writer_get_compress (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_json_writer_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	JsonWriter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_JSON_WRITER, JsonWriter);
	switch (property_id) {
		case JSON_WRITER_COMPRESS:
		json_writer_set_compress (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


gboolean write_json_file (JsonNode* root, const gchar* filepath, gboolean compress, gboolean backup) {
	gboolean result = FALSE;
	JsonWriter* writer = NULL;
	JsonNode* _tmp0_ = NULL;
	JsonWriter* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (root != NULL, FALSE);
	g_return_val_if_fail (filepath != NULL, FALSE);
	_tmp0_ = root;
	_tmp1_ = json_writer_new (_tmp0_);
	writer = _tmp1_;
	_tmp2_ = compress;
	json_writer_set_compress (writer, _tmp2_);
	_tmp3_ = filepath;
	_tmp4_ = backup;
	_tmp5_ = json_writer_to_file (writer, _tmp3_, _tmp4_);
	result = _tmp5_;
	_g_object_unref0 (writer);
	return result;
}


static JsonNode* _vala_JsonNode_copy (JsonNode* self) {
	return g_boxed_copy (json_node_get_type (), self);
}


static gpointer __vala_JsonNode_copy0 (gpointer self) {
	return self ? _vala_JsonNode_copy (self) : NULL;
}


JsonNode* load_json_file (const gchar* filepath, gboolean compressed) {
	JsonNode* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filepath != NULL, NULL);
	{
		JsonParser* parser = NULL;
		JsonParser* _tmp0_ = NULL;
		gboolean _tmp1_ = FALSE;
		JsonParser* _tmp15_ = NULL;
		JsonNode* _tmp16_ = NULL;
		JsonNode* _tmp17_ = NULL;
		_tmp0_ = json_parser_new ();
		parser = _tmp0_;
		_tmp1_ = compressed;
		if (_tmp1_) {
			GFileInputStream* stream = NULL;
			const gchar* _tmp2_ = NULL;
			GFile* _tmp3_ = NULL;
			GFile* _tmp4_ = NULL;
			GFileInputStream* _tmp5_ = NULL;
			GFileInputStream* _tmp6_ = NULL;
			GZlibDecompressor* decompressor = NULL;
			GZlibDecompressor* _tmp7_ = NULL;
			GConverterInputStream* uncompressed_stream = NULL;
			GFileInputStream* _tmp8_ = NULL;
			GZlibDecompressor* _tmp9_ = NULL;
			GConverterInputStream* _tmp10_ = NULL;
			JsonParser* _tmp11_ = NULL;
			GConverterInputStream* _tmp12_ = NULL;
			_tmp2_ = filepath;
			_tmp3_ = g_file_new_for_path (_tmp2_);
			_tmp4_ = _tmp3_;
			_tmp5_ = g_file_read (_tmp4_, NULL, &_inner_error_);
			_tmp6_ = _tmp5_;
			_g_object_unref0 (_tmp4_);
			stream = _tmp6_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (parser);
				goto __catch41_g_error;
			}
			_tmp7_ = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_ZLIB);
			decompressor = _tmp7_;
			_tmp8_ = stream;
			_tmp9_ = decompressor;
			_tmp10_ = (GConverterInputStream*) g_converter_input_stream_new ((GInputStream*) _tmp8_, (GConverter*) _tmp9_);
			uncompressed_stream = _tmp10_;
			_tmp11_ = parser;
			_tmp12_ = uncompressed_stream;
			json_parser_load_from_stream (_tmp11_, (GInputStream*) _tmp12_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (uncompressed_stream);
				_g_object_unref0 (decompressor);
				_g_object_unref0 (stream);
				_g_object_unref0 (parser);
				goto __catch41_g_error;
			}
			_g_object_unref0 (uncompressed_stream);
			_g_object_unref0 (decompressor);
			_g_object_unref0 (stream);
		} else {
			JsonParser* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			_tmp13_ = parser;
			_tmp14_ = filepath;
			json_parser_load_from_file (_tmp13_, _tmp14_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (parser);
				goto __catch41_g_error;
			}
		}
		_tmp15_ = parser;
		_tmp16_ = json_parser_get_root (_tmp15_);
		_tmp17_ = __vala_JsonNode_copy0 (_tmp16_);
		result = _tmp17_;
		_g_object_unref0 (parser);
		return result;
	}
	goto __finally41;
	__catch41_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp18_ = NULL;
		GError* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp18_ = filepath;
		_tmp19_ = e;
		_tmp20_ = _tmp19_->message;
		g_warning ("JsonWriter.vala:79: \n" \
"Failed to load cache file : %s\n" \
"%s : skipping...", _tmp18_, _tmp20_);
		_g_error_free0 (e);
	}
	__finally41:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	return result;
}



