/* Cacheable.c generated by valac 0.26.1, the Vala compiler
 * generated from Cacheable.vala, do not modify */

/* Cacheable.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <json-glib/json-glib.h>
#include <json-glib/json-gobject.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;
typedef struct _CacheablePrivate CacheablePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))

struct _Cacheable {
	GObject parent_instance;
	CacheablePrivate * priv;
};

struct _CacheableClass {
	GObjectClass parent_class;
	gboolean (*deserialize_property) (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec, JsonNode* node);
	JsonNode* (*serialize_property) (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec);
};


static gpointer cacheable_parent_class = NULL;
static JsonSerializableIface* cacheable_json_serializable_parent_iface = NULL;

GType cacheable_get_type (void) G_GNUC_CONST;
enum  {
	CACHEABLE_DUMMY_PROPERTY
};
gboolean cacheable_deserialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec, JsonNode* node);
static gboolean cacheable_real_deserialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec, JsonNode* node);
static GParamSpec* cacheable_real_find_property (JsonSerializable* base, const gchar* name);
GParamSpec** cacheable_list_properties (Cacheable* self, int* result_length1);
static GParamSpec** _vala_array_dup1 (GParamSpec** self, int length);
JsonNode* cacheable_serialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec);
static JsonNode* cacheable_real_serialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec);
static void _vala_JsonNode_free (JsonNode* self);
Cacheable* cacheable_new (void);
Cacheable* cacheable_construct (GType object_type);


static gboolean cacheable_real_deserialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec, JsonNode* node) {
	GValue _vala_val = {0};
	gboolean result = FALSE;
	GParamSpec* _tmp0_ = NULL;
	GType _tmp1_ = 0UL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	JsonNode* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	JsonNode* _tmp6_ = NULL;
	GValue _tmp7_ = {0};
	g_return_val_if_fail (prop_name != NULL, FALSE);
	g_return_val_if_fail (pspec != NULL, FALSE);
	g_return_val_if_fail (node != NULL, FALSE);
	_tmp0_ = pspec;
	_tmp1_ = _tmp0_->value_type;
	g_value_init (&_tmp2_, _tmp1_);
	G_IS_VALUE (&_vala_val) ? (g_value_unset (&_vala_val), NULL) : NULL;
	_vala_val = _tmp2_;
	_tmp3_ = _vala_val;
	_tmp4_ = node;
	_tmp5_ = json_node_is_null (_tmp4_);
	if (_tmp5_) {
		result = TRUE;
		if (val) {
			*val = _vala_val;
		} else {
			G_IS_VALUE (&_vala_val) ? (g_value_unset (&_vala_val), NULL) : NULL;
		}
		return result;
	}
	_tmp6_ = node;
	json_node_get_value (_tmp6_, &_tmp7_);
	G_IS_VALUE (&_vala_val) ? (g_value_unset (&_vala_val), NULL) : NULL;
	_vala_val = _tmp7_;
	result = TRUE;
	if (val) {
		*val = _vala_val;
	} else {
		G_IS_VALUE (&_vala_val) ? (g_value_unset (&_vala_val), NULL) : NULL;
	}
	return result;
}


gboolean cacheable_deserialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec, JsonNode* node) {
	g_return_val_if_fail (self != NULL, FALSE);
	return CACHEABLE_GET_CLASS (self)->deserialize_property (self, prop_name, val, pspec, node);
}


static GParamSpec* cacheable_real_find_property (JsonSerializable* base, const gchar* name) {
	Cacheable * self;
	GParamSpec* result = NULL;
	GObjectClass* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GParamSpec* _tmp2_ = NULL;
	self = (Cacheable*) base;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = G_OBJECT_GET_CLASS ((GObject*) self);
	_tmp1_ = name;
	_tmp2_ = g_object_class_find_property (_tmp0_, _tmp1_);
	result = _tmp2_;
	return result;
}


static gpointer _g_param_spec_ref0 (gpointer self) {
	return self ? g_param_spec_ref (self) : NULL;
}


static GParamSpec** _vala_array_dup1 (GParamSpec** self, int length) {
	GParamSpec** result;
	int i;
	result = g_new0 (GParamSpec*, length + 1);
	for (i = 0; i < length; i++) {
		GParamSpec* _tmp0_ = NULL;
		_tmp0_ = _g_param_spec_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


GParamSpec** cacheable_list_properties (Cacheable* self, int* result_length1) {
	GParamSpec** result = NULL;
	GObjectClass* _tmp0_ = NULL;
	guint _tmp1_;
	GParamSpec** _tmp2_ = NULL;
	GParamSpec** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	GParamSpec** _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = G_OBJECT_GET_CLASS ((GObject*) self);
	_tmp2_ = g_object_class_list_properties (_tmp0_, &_tmp1_);
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup1 (_tmp2_, _tmp1_) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp1_;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static JsonNode* cacheable_real_serialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec) {
	JsonNode* result = NULL;
	JsonNode* node = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (prop_name != NULL, NULL);
	g_return_val_if_fail (val != NULL, NULL);
	g_return_val_if_fail (pspec != NULL, NULL);
	_tmp0_ = g_strdup_value_contents (val);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strcmp0 (_tmp1_, "NULL") == 0;
	_g_free0 (_tmp1_);
	if (_tmp2_) {
		JsonNode* _tmp3_ = NULL;
		_tmp3_ = json_node_new (JSON_NODE_NULL);
		__vala_JsonNode_free0 (node);
		node = _tmp3_;
	} else {
		JsonNode* _tmp4_ = NULL;
		JsonNode* _tmp5_ = NULL;
		GValue _tmp6_ = {0};
		_tmp4_ = json_node_new (JSON_NODE_VALUE);
		__vala_JsonNode_free0 (node);
		node = _tmp4_;
		_tmp5_ = node;
		_tmp6_ = *val;
		json_node_set_value (_tmp5_, &_tmp6_);
	}
	result = node;
	return result;
}


JsonNode* cacheable_serialize_property (Cacheable* self, const gchar* prop_name, GValue* val, GParamSpec* pspec) {
	g_return_val_if_fail (self != NULL, NULL);
	return CACHEABLE_GET_CLASS (self)->serialize_property (self, prop_name, val, pspec);
}


Cacheable* cacheable_construct (GType object_type) {
	Cacheable * self = NULL;
	self = (Cacheable*) g_object_new (object_type, NULL);
	return self;
}


Cacheable* cacheable_new (void) {
	return cacheable_construct (TYPE_CACHEABLE);
}


static void cacheable_class_init (CacheableClass * klass) {
	cacheable_parent_class = g_type_class_peek_parent (klass);
	((CacheableClass *) klass)->deserialize_property = cacheable_real_deserialize_property;
	((CacheableClass *) klass)->serialize_property = cacheable_real_serialize_property;
}


static void cacheable_json_serializable_interface_init (JsonSerializableIface * iface) {
	cacheable_json_serializable_parent_iface = g_type_interface_peek_parent (iface);
	iface->deserialize_property = (gboolean (*)(JsonSerializable*, const gchar*, GValue*, GParamSpec*, JsonNode*)) cacheable_deserialize_property;
	iface->find_property = (GParamSpec* (*)(JsonSerializable*, const gchar*)) cacheable_real_find_property;
	iface->serialize_property = (JsonNode* (*)(JsonSerializable*, const gchar*, GValue*, GParamSpec*)) cacheable_serialize_property;
}


static void cacheable_instance_init (Cacheable * self) {
}


GType cacheable_get_type (void) {
	static volatile gsize cacheable_type_id__volatile = 0;
	if (g_once_init_enter (&cacheable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CacheableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) cacheable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Cacheable), 0, (GInstanceInitFunc) cacheable_instance_init, NULL };
		static const GInterfaceInfo json_serializable_info = { (GInterfaceInitFunc) cacheable_json_serializable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType cacheable_type_id;
		cacheable_type_id = g_type_register_static (G_TYPE_OBJECT, "Cacheable", &g_define_type_info, 0);
		g_type_add_interface_static (cacheable_type_id, json_serializable_get_type (), &json_serializable_info);
		g_once_init_leave (&cacheable_type_id__volatile, cacheable_type_id);
	}
	return cacheable_type_id__volatile;
}



