/* Accept.c generated by valac 0.26.1, the Vala compiler
 * generated from Accept.vala, do not modify */

/* Accept.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>


#define FONT_CONFIG_TYPE_SELECTIONS (font_config_selections_get_type ())
#define FONT_CONFIG_SELECTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelections))
#define FONT_CONFIG_SELECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelectionsClass))
#define FONT_CONFIG_IS_SELECTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_SELECTIONS))
#define FONT_CONFIG_IS_SELECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_SELECTIONS))
#define FONT_CONFIG_SELECTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelectionsClass))

typedef struct _FontConfigSelections FontConfigSelections;
typedef struct _FontConfigSelectionsClass FontConfigSelectionsClass;
typedef struct _FontConfigSelectionsPrivate FontConfigSelectionsPrivate;
typedef xmlTextWriter FontConfigXmlWriter;

#define FONT_CONFIG_TYPE_ACCEPT (font_config_accept_get_type ())
#define FONT_CONFIG_ACCEPT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_ACCEPT, FontConfigAccept))
#define FONT_CONFIG_ACCEPT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_ACCEPT, FontConfigAcceptClass))
#define FONT_CONFIG_IS_ACCEPT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_ACCEPT))
#define FONT_CONFIG_IS_ACCEPT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_ACCEPT))
#define FONT_CONFIG_ACCEPT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_ACCEPT, FontConfigAcceptClass))

typedef struct _FontConfigAccept FontConfigAccept;
typedef struct _FontConfigAcceptClass FontConfigAcceptClass;
typedef struct _FontConfigAcceptPrivate FontConfigAcceptPrivate;

struct _FontConfigSelections {
	GeeHashSet parent_instance;
	FontConfigSelectionsPrivate * priv;
};

struct _FontConfigSelectionsClass {
	GeeHashSetClass parent_class;
	void (*save) (FontConfigSelections* self);
	gboolean (*init) (FontConfigSelections* self);
	void (*parse) (FontConfigSelections* self, xmlNode* root);
	void (*write_node) (FontConfigSelections* self, FontConfigXmlWriter* writer);
	void (*parse_node) (FontConfigSelections* self, xmlNode* node);
};

struct _FontConfigAccept {
	FontConfigSelections parent_instance;
	FontConfigAcceptPrivate * priv;
};

struct _FontConfigAcceptClass {
	FontConfigSelectionsClass parent_class;
};


static gpointer font_config_accept_parent_class = NULL;

GType font_config_selections_get_type (void) G_GNUC_CONST;
GType font_config_accept_get_type (void) G_GNUC_CONST;
enum  {
	FONT_CONFIG_ACCEPT_DUMMY_PROPERTY
};
FontConfigAccept* font_config_accept_new (void);
FontConfigAccept* font_config_accept_construct (GType object_type);
FontConfigSelections* font_config_selections_construct (GType object_type);
void font_config_selections_set_target_element (FontConfigSelections* self, const gchar* value);
void font_config_selections_set_target_file (FontConfigSelections* self, const gchar* value);


FontConfigAccept* font_config_accept_construct (GType object_type) {
	FontConfigAccept * self = NULL;
	self = (FontConfigAccept*) font_config_selections_construct (object_type);
	font_config_selections_set_target_element ((FontConfigSelections*) self, "acceptfont");
	font_config_selections_set_target_file ((FontConfigSelections*) self, "79-Accept.conf");
	return self;
}


FontConfigAccept* font_config_accept_new (void) {
	return font_config_accept_construct (FONT_CONFIG_TYPE_ACCEPT);
}


static void font_config_accept_class_init (FontConfigAcceptClass * klass) {
	font_config_accept_parent_class = g_type_class_peek_parent (klass);
}


static void font_config_accept_instance_init (FontConfigAccept * self) {
}


GType font_config_accept_get_type (void) {
	static volatile gsize font_config_accept_type_id__volatile = 0;
	if (g_once_init_enter (&font_config_accept_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontConfigAcceptClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_config_accept_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontConfigAccept), 0, (GInstanceInitFunc) font_config_accept_instance_init, NULL };
		GType font_config_accept_type_id;
		font_config_accept_type_id = g_type_register_static (FONT_CONFIG_TYPE_SELECTIONS, "FontConfigAccept", &g_define_type_info, 0);
		g_once_init_leave (&font_config_accept_type_id__volatile, font_config_accept_type_id);
	}
	return font_config_accept_type_id__volatile;
}



