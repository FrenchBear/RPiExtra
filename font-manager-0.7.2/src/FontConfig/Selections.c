/* Selections.c generated by valac 0.26.1, the Vala compiler
 * generated from Selections.vala, do not modify */

/* Selections.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <libxml/tree.h>
#include <libxml/xmlwriter.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <libxml/parser.h>


#define FONT_CONFIG_TYPE_SELECTIONS (font_config_selections_get_type ())
#define FONT_CONFIG_SELECTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelections))
#define FONT_CONFIG_SELECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelectionsClass))
#define FONT_CONFIG_IS_SELECTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_SELECTIONS))
#define FONT_CONFIG_IS_SELECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_SELECTIONS))
#define FONT_CONFIG_SELECTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelectionsClass))

typedef struct _FontConfigSelections FontConfigSelections;
typedef struct _FontConfigSelectionsClass FontConfigSelectionsClass;
typedef struct _FontConfigSelectionsPrivate FontConfigSelectionsPrivate;
typedef xmlTextWriter FontConfigXmlWriter;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _xmlFreeTextWriter0(var) ((var == NULL) ? NULL : (var = (xmlFreeTextWriter (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _FontConfigSelections {
	GeeHashSet parent_instance;
	FontConfigSelectionsPrivate * priv;
};

struct _FontConfigSelectionsClass {
	GeeHashSetClass parent_class;
	void (*save) (FontConfigSelections* self);
	gboolean (*init) (FontConfigSelections* self);
	void (*parse) (FontConfigSelections* self, xmlNode* root);
	void (*write_node) (FontConfigSelections* self, FontConfigXmlWriter* writer);
	void (*parse_node) (FontConfigSelections* self, xmlNode* node);
};

struct _FontConfigSelectionsPrivate {
	gchar* _target_element;
	gchar* _target_file;
};


static gpointer font_config_selections_parent_class = NULL;

GType font_config_selections_get_type (void) G_GNUC_CONST;
#define FONT_CONFIG_SELECTIONS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelectionsPrivate))
enum  {
	FONT_CONFIG_SELECTIONS_DUMMY_PROPERTY,
	FONT_CONFIG_SELECTIONS_TARGET_FILE,
	FONT_CONFIG_SELECTIONS_TARGET_ELEMENT
};
void font_config_selections_save (FontConfigSelections* self);
static void font_config_selections_real_save (FontConfigSelections* self);
const gchar* font_config_selections_get_target_file (FontConfigSelections* self);
const gchar* font_config_selections_get_target_element (FontConfigSelections* self);
FontConfigXmlWriter* font_config_xml_writer_new (const gchar* filepath);
FontConfigXmlWriter* font_config_xml_writer_new (const gchar* filepath);
void font_config_selections_write_node (FontConfigSelections* self, FontConfigXmlWriter* writer);
void font_config_xml_writer_close (FontConfigXmlWriter* self);
gboolean font_config_selections_init (FontConfigSelections* self);
static gboolean font_config_selections_real_init (FontConfigSelections* self);
void font_config_selections_parse (FontConfigSelections* self, xmlNode* root);
static void font_config_selections_real_parse (FontConfigSelections* self, xmlNode* root);
void font_config_selections_parse_node (FontConfigSelections* self, xmlNode* node);
static void font_config_selections_real_write_node (FontConfigSelections* self, FontConfigXmlWriter* writer);
void font_config_xml_writer_start_selection (FontConfigXmlWriter* self, const gchar* selection_type);
void font_config_xml_writer_write_family_patelt (FontConfigXmlWriter* self, const gchar* family);
void font_config_xml_writer_end_selection (FontConfigXmlWriter* self);
static void font_config_selections_real_parse_node (FontConfigSelections* self, xmlNode* node);
FontConfigSelections* font_config_selections_construct (GType object_type);
void font_config_selections_set_target_file (FontConfigSelections* self, const gchar* value);
gchar* font_config_get_config_dir (void);
void font_config_selections_set_target_element (FontConfigSelections* self, const gchar* value);
static void font_config_selections_finalize (GObject* obj);
static void _vala_font_config_selections_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_config_selections_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void font_config_selections_real_save (FontConfigSelections* self) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	FontConfigXmlWriter* writer = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	FontConfigXmlWriter* _tmp5_ = NULL;
	_tmp0_ = font_config_selections_get_target_file (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_target_element;
	g_return_if_fail ((_tmp1_ != NULL) && (_tmp2_ != NULL));
	_tmp3_ = font_config_selections_get_target_file (self);
	_tmp4_ = _tmp3_;
	_tmp5_ = font_config_xml_writer_new (_tmp4_);
	writer = _tmp5_;
	font_config_selections_write_node (self, writer);
	font_config_xml_writer_close (writer);
	_xmlFreeTextWriter0 (writer);
	return;
}


void font_config_selections_save (FontConfigSelections* self) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = font_config_selections_get_target_file (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = font_config_selections_get_target_element (self);
	_tmp3_ = _tmp2_;
	g_return_if_fail ((_tmp1_ != NULL) && (_tmp3_ != NULL));
	FONT_CONFIG_SELECTIONS_GET_CLASS (self)->save (self);
}


static gboolean font_config_selections_real_init (FontConfigSelections* self) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	xmlDoc* doc = NULL;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	xmlDoc* _tmp10_ = NULL;
	xmlDoc* _tmp11_ = NULL;
	xmlNode* root = NULL;
	xmlDoc* _tmp12_ = NULL;
	xmlNode* _tmp13_ = NULL;
	xmlNode* _tmp14_ = NULL;
	xmlNode* _tmp16_ = NULL;
	xmlDoc* _tmp17_ = NULL;
	_tmp0_ = font_config_selections_get_target_file (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_target_element;
	g_return_val_if_fail ((_tmp1_ != NULL) && (_tmp2_ != NULL), FALSE);
	{
		GFile* file = NULL;
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		GFile* _tmp5_ = NULL;
		GFile* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		_tmp3_ = font_config_selections_get_target_file (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_file_new_for_path (_tmp4_);
		file = _tmp5_;
		_tmp6_ = file;
		_tmp7_ = g_file_query_exists (_tmp6_, NULL);
		if (!_tmp7_) {
			result = FALSE;
			_g_object_unref0 (file);
			return result;
		}
		_g_object_unref0 (file);
	}
	xmlInitParser ();
	_tmp8_ = font_config_selections_get_target_file (self);
	_tmp9_ = _tmp8_;
	_tmp10_ = xmlParseFile (_tmp9_);
	doc = _tmp10_;
	_tmp11_ = doc;
	if (_tmp11_ == NULL) {
		xmlCleanupParser ();
		result = FALSE;
		return result;
	}
	_tmp12_ = doc;
	_tmp13_ = xmlDocGetRootElement (_tmp12_);
	root = _tmp13_;
	_tmp14_ = root;
	if (_tmp14_ == NULL) {
		xmlDoc* _tmp15_ = NULL;
		_tmp15_ = doc;
		xmlFreeDoc (_tmp15_);
		xmlCleanupParser ();
		result = FALSE;
		return result;
	}
	_tmp16_ = root;
	font_config_selections_parse (self, _tmp16_);
	_tmp17_ = doc;
	xmlFreeDoc (_tmp17_);
	xmlCleanupParser ();
	result = TRUE;
	return result;
}


gboolean font_config_selections_init (FontConfigSelections* self) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = font_config_selections_get_target_file (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = font_config_selections_get_target_element (self);
	_tmp3_ = _tmp2_;
	g_return_val_if_fail ((_tmp1_ != NULL) && (_tmp3_ != NULL), FALSE);
	return FONT_CONFIG_SELECTIONS_GET_CLASS (self)->init (self);
}


static void font_config_selections_real_parse (FontConfigSelections* self, xmlNode* root) {
	{
		xmlNode* iter = NULL;
		xmlNode* _tmp0_ = NULL;
		xmlNode* _tmp1_ = NULL;
		_tmp0_ = root;
		_tmp1_ = _tmp0_->children;
		iter = _tmp1_;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp5_ = NULL;
				xmlNode* _tmp6_ = NULL;
				xmlElementType _tmp7_ = 0;
				xmlNode* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				if (!_tmp2_) {
					xmlNode* _tmp3_ = NULL;
					xmlNode* _tmp4_ = NULL;
					_tmp3_ = iter;
					_tmp4_ = _tmp3_->next;
					iter = _tmp4_;
				}
				_tmp2_ = FALSE;
				_tmp5_ = iter;
				if (!(_tmp5_ != NULL)) {
					break;
				}
				_tmp6_ = iter;
				_tmp7_ = _tmp6_->type;
				if (_tmp7_ != XML_ELEMENT_NODE) {
					continue;
				}
				_tmp8_ = iter;
				_tmp9_ = _tmp8_->name;
				if (g_strcmp0 (_tmp9_, "selectfont") == 0) {
					{
						xmlNode* node = NULL;
						xmlNode* _tmp10_ = NULL;
						xmlNode* _tmp11_ = NULL;
						_tmp10_ = iter;
						_tmp11_ = _tmp10_->children;
						node = _tmp11_;
						{
							gboolean _tmp12_ = FALSE;
							_tmp12_ = TRUE;
							while (TRUE) {
								xmlNode* _tmp15_ = NULL;
								xmlNode* _tmp16_ = NULL;
								const gchar* _tmp17_ = NULL;
								const gchar* _tmp18_ = NULL;
								if (!_tmp12_) {
									xmlNode* _tmp13_ = NULL;
									xmlNode* _tmp14_ = NULL;
									_tmp13_ = node;
									_tmp14_ = _tmp13_->next;
									node = _tmp14_;
								}
								_tmp12_ = FALSE;
								_tmp15_ = node;
								if (!(_tmp15_ != NULL)) {
									break;
								}
								_tmp16_ = node;
								_tmp17_ = _tmp16_->name;
								_tmp18_ = self->priv->_target_element;
								if (g_strcmp0 (_tmp17_, _tmp18_) == 0) {
									xmlNode* _tmp19_ = NULL;
									xmlNode* _tmp20_ = NULL;
									_tmp19_ = node;
									_tmp20_ = _tmp19_->children;
									font_config_selections_parse_node (self, _tmp20_);
								}
							}
						}
					}
				}
			}
		}
	}
}


void font_config_selections_parse (FontConfigSelections* self, xmlNode* root) {
	g_return_if_fail (self != NULL);
	FONT_CONFIG_SELECTIONS_GET_CLASS (self)->parse (self, root);
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static void font_config_selections_real_write_node (FontConfigSelections* self, FontConfigXmlWriter* writer) {
	FontConfigXmlWriter* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	FontConfigXmlWriter* _tmp13_ = NULL;
	g_return_if_fail (writer != NULL);
	_tmp0_ = writer;
	_tmp1_ = self->priv->_target_element;
	font_config_xml_writer_start_selection (_tmp0_, _tmp1_);
	{
		GeeIterator* _font_it = NULL;
		GeeIterator* _tmp2_ = NULL;
		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) self);
		_font_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_ = NULL;
			gboolean _tmp4_ = FALSE;
			gchar* font = NULL;
			GeeIterator* _tmp5_ = NULL;
			gpointer _tmp6_ = NULL;
			FontConfigXmlWriter* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			_tmp3_ = _font_it;
			_tmp4_ = gee_iterator_next (_tmp3_);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = _font_it;
			_tmp6_ = gee_iterator_get (_tmp5_);
			font = (gchar*) _tmp6_;
			_tmp7_ = writer;
			_tmp8_ = font;
			_tmp9_ = string_strip (_tmp8_);
			_tmp10_ = _tmp9_;
			_tmp11_ = g_markup_escape_text (_tmp10_, (gssize) (-1));
			_tmp12_ = _tmp11_;
			font_config_xml_writer_write_family_patelt (_tmp7_, _tmp12_);
			_g_free0 (_tmp12_);
			_g_free0 (_tmp10_);
			_g_free0 (font);
		}
		_g_object_unref0 (_font_it);
	}
	_tmp13_ = writer;
	font_config_xml_writer_end_selection (_tmp13_);
	return;
}


void font_config_selections_write_node (FontConfigSelections* self, FontConfigXmlWriter* writer) {
	g_return_if_fail (self != NULL);
	FONT_CONFIG_SELECTIONS_GET_CLASS (self)->write_node (self, writer);
}


static void font_config_selections_real_parse_node (FontConfigSelections* self, xmlNode* node) {
	{
		xmlNode* iter = NULL;
		xmlNode* _tmp0_ = NULL;
		_tmp0_ = node;
		iter = _tmp0_;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp4_ = NULL;
				xmlNode* _tmp5_ = NULL;
				xmlElementType _tmp6_ = 0;
				gchar* content = NULL;
				xmlNode* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				if (!_tmp1_) {
					xmlNode* _tmp2_ = NULL;
					xmlNode* _tmp3_ = NULL;
					_tmp2_ = iter;
					_tmp3_ = _tmp2_->next;
					iter = _tmp3_;
				}
				_tmp1_ = FALSE;
				_tmp4_ = iter;
				if (!(_tmp4_ != NULL)) {
					break;
				}
				_tmp5_ = iter;
				_tmp6_ = _tmp5_->type;
				if (_tmp6_ != XML_ELEMENT_NODE) {
					continue;
				}
				_tmp7_ = iter;
				_tmp8_ = (gchar*) xmlNodeGetContent (_tmp7_);
				content = _tmp8_;
				_tmp9_ = content;
				if (_tmp9_ == NULL) {
					_g_free0 (content);
					continue;
				}
				_tmp10_ = content;
				_tmp11_ = string_strip (_tmp10_);
				_g_free0 (content);
				content = _tmp11_;
				_tmp12_ = content;
				if (g_strcmp0 (_tmp12_, "") == 0) {
					_g_free0 (content);
					continue;
				} else {
					const gchar* _tmp13_ = NULL;
					_tmp13_ = content;
					gee_abstract_collection_add ((GeeAbstractCollection*) self, _tmp13_);
				}
				_g_free0 (content);
			}
		}
	}
	return;
}


void font_config_selections_parse_node (FontConfigSelections* self, xmlNode* node) {
	g_return_if_fail (self != NULL);
	FONT_CONFIG_SELECTIONS_GET_CLASS (self)->parse_node (self, node);
}


FontConfigSelections* font_config_selections_construct (GType object_type) {
	FontConfigSelections * self = NULL;
	self = (FontConfigSelections*) gee_hash_set_construct (object_type, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	return self;
}


const gchar* font_config_selections_get_target_file (FontConfigSelections* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_target_file;
	result = _tmp0_;
	return result;
}


void font_config_selections_set_target_file (FontConfigSelections* self, const gchar* value) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = font_config_get_config_dir ();
	_tmp1_ = _tmp0_;
	_tmp2_ = value;
	_tmp3_ = g_build_filename (_tmp1_, _tmp2_, NULL);
	_g_free0 (self->priv->_target_file);
	self->priv->_target_file = _tmp3_;
	_g_free0 (_tmp1_);
	g_object_notify ((GObject *) self, "target-file");
}


const gchar* font_config_selections_get_target_element (FontConfigSelections* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_target_element;
	result = _tmp0_;
	return result;
}


void font_config_selections_set_target_element (FontConfigSelections* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_target_element);
	self->priv->_target_element = _tmp1_;
	g_object_notify ((GObject *) self, "target-element");
}


static void font_config_selections_class_init (FontConfigSelectionsClass * klass) {
	font_config_selections_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontConfigSelectionsPrivate));
	((FontConfigSelectionsClass *) klass)->save = font_config_selections_real_save;
	((FontConfigSelectionsClass *) klass)->init = font_config_selections_real_init;
	((FontConfigSelectionsClass *) klass)->parse = font_config_selections_real_parse;
	((FontConfigSelectionsClass *) klass)->write_node = font_config_selections_real_write_node;
	((FontConfigSelectionsClass *) klass)->parse_node = font_config_selections_real_parse_node;
	G_OBJECT_CLASS (klass)->get_property = _vala_font_config_selections_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_config_selections_set_property;
	G_OBJECT_CLASS (klass)->finalize = font_config_selections_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_CONFIG_SELECTIONS_TARGET_FILE, g_param_spec_string ("target-file", "target-file", "target-file", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_CONFIG_SELECTIONS_TARGET_ELEMENT, g_param_spec_string ("target-element", "target-element", "target-element", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void font_config_selections_instance_init (FontConfigSelections * self) {
	self->priv = FONT_CONFIG_SELECTIONS_GET_PRIVATE (self);
	self->priv->_target_element = NULL;
	self->priv->_target_file = NULL;
}


static void font_config_selections_finalize (GObject* obj) {
	FontConfigSelections * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelections);
	_g_free0 (self->priv->_target_element);
	_g_free0 (self->priv->_target_file);
	G_OBJECT_CLASS (font_config_selections_parent_class)->finalize (obj);
}


GType font_config_selections_get_type (void) {
	static volatile gsize font_config_selections_type_id__volatile = 0;
	if (g_once_init_enter (&font_config_selections_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontConfigSelectionsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_config_selections_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontConfigSelections), 0, (GInstanceInitFunc) font_config_selections_instance_init, NULL };
		GType font_config_selections_type_id;
		font_config_selections_type_id = g_type_register_static (GEE_TYPE_HASH_SET, "FontConfigSelections", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&font_config_selections_type_id__volatile, font_config_selections_type_id);
	}
	return font_config_selections_type_id__volatile;
}


static void _vala_font_config_selections_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontConfigSelections * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelections);
	switch (property_id) {
		case FONT_CONFIG_SELECTIONS_TARGET_FILE:
		g_value_set_string (value, font_config_selections_get_target_file (self));
		break;
		case FONT_CONFIG_SELECTIONS_TARGET_ELEMENT:
		g_value_set_string (value, font_config_selections_get_target_element (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_config_selections_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontConfigSelections * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_CONFIG_TYPE_SELECTIONS, FontConfigSelections);
	switch (property_id) {
		case FONT_CONFIG_SELECTIONS_TARGET_FILE:
		font_config_selections_set_target_file (self, g_value_get_string (value));
		break;
		case FONT_CONFIG_SELECTIONS_TARGET_ELEMENT:
		font_config_selections_set_target_element (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



