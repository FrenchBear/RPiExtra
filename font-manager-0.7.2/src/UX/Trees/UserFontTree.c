/* UserFontTree.c generated by valac 0.26.1, the Vala compiler
 * generated from UserFontTree.vala, do not modify */

/* UserFontTree.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <pango/pango.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>


#define FONT_MANAGER_TYPE_USER_FONT_TREE (font_manager_user_font_tree_get_type ())
#define FONT_MANAGER_USER_FONT_TREE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTree))
#define FONT_MANAGER_USER_FONT_TREE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTreeClass))
#define FONT_MANAGER_IS_USER_FONT_TREE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE))
#define FONT_MANAGER_IS_USER_FONT_TREE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_USER_FONT_TREE))
#define FONT_MANAGER_USER_FONT_TREE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTreeClass))

typedef struct _FontManagerUserFontTree FontManagerUserFontTree;
typedef struct _FontManagerUserFontTreeClass FontManagerUserFontTreeClass;
typedef struct _FontManagerUserFontTreePrivate FontManagerUserFontTreePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FONT_MANAGER_TYPE_FONT_MODEL (font_manager_font_model_get_type ())
#define FONT_MANAGER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel))
#define FONT_MANAGER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))
#define FONT_MANAGER_IS_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_IS_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))

typedef struct _FontManagerFontModel FontManagerFontModel;
typedef struct _FontManagerFontModelClass FontManagerFontModelClass;

#define FONT_MANAGER_TYPE_USER_FONT_MODEL (font_manager_user_font_model_get_type ())
#define FONT_MANAGER_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel))
#define FONT_MANAGER_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))
#define FONT_MANAGER_IS_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_IS_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_USER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))

typedef struct _FontManagerUserFontModel FontManagerUserFontModel;
typedef struct _FontManagerUserFontModelClass FontManagerUserFontModelClass;

#define TYPE_CELL_RENDERER_PILL (cell_renderer_pill_get_type ())
#define CELL_RENDERER_PILL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_RENDERER_PILL, CellRendererPill))
#define CELL_RENDERER_PILL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_RENDERER_PILL, CellRendererPillClass))
#define IS_CELL_RENDERER_PILL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_RENDERER_PILL))
#define IS_CELL_RENDERER_PILL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_RENDERER_PILL))
#define CELL_RENDERER_PILL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_RENDERER_PILL, CellRendererPillClass))

typedef struct _CellRendererPill CellRendererPill;
typedef struct _CellRendererPillClass CellRendererPillClass;

#define TYPE_CELL_RENDERER_COUNT (cell_renderer_count_get_type ())
#define CELL_RENDERER_COUNT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CELL_RENDERER_COUNT, CellRendererCount))
#define CELL_RENDERER_COUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CELL_RENDERER_COUNT, CellRendererCountClass))
#define IS_CELL_RENDERER_COUNT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CELL_RENDERER_COUNT))
#define IS_CELL_RENDERER_COUNT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CELL_RENDERER_COUNT))
#define CELL_RENDERER_COUNT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CELL_RENDERER_COUNT, CellRendererCountClass))

typedef struct _CellRendererCount CellRendererCount;
typedef struct _CellRendererCountClass CellRendererCountClass;

#define FONT_MANAGER_TYPE_FONT_LIST_COLUMN (font_manager_font_list_column_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_CONFIG_TYPE_FAMILY (font_config_family_get_type ())
#define FONT_CONFIG_FAMILY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FAMILY, FontConfigFamily))
#define FONT_CONFIG_FAMILY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FAMILY, FontConfigFamilyClass))
#define FONT_CONFIG_IS_FAMILY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FAMILY))
#define FONT_CONFIG_IS_FAMILY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FAMILY))
#define FONT_CONFIG_FAMILY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FAMILY, FontConfigFamilyClass))

typedef struct _FontConfigFamily FontConfigFamily;
typedef struct _FontConfigFamilyClass FontConfigFamilyClass;

#define FONT_CONFIG_TYPE_FONT (font_config_font_get_type ())
#define FONT_CONFIG_FONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFont))
#define FONT_CONFIG_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))
#define FONT_CONFIG_IS_FONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_FONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))

typedef struct _FontConfigFont FontConfigFont;
typedef struct _FontConfigFontClass FontConfigFontClass;

#define FONT_MANAGER_TYPE_FONT_MODEL_COLUMN (font_manager_font_model_column_get_type ())

#define FONT_MANAGER_TYPE_DATABASE (font_manager_database_get_type ())
#define FONT_MANAGER_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabase))
#define FONT_MANAGER_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))
#define FONT_MANAGER_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))

typedef struct _FontManagerDatabase FontManagerDatabase;
typedef struct _FontManagerDatabaseClass FontManagerDatabaseClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _FontManagerUserFontTree {
	GtkTreeView parent_instance;
	FontManagerUserFontTreePrivate * priv;
};

struct _FontManagerUserFontTreeClass {
	GtkTreeViewClass parent_class;
};

struct _FontManagerUserFontTreePrivate {
	GtkCellRendererToggle* toggle;
	GeeHashSet* selected_paths;
	GeeHashMap* filemap;
};

typedef enum  {
	FONT_MANAGER_FONT_LIST_COLUMN_TOGGLE,
	FONT_MANAGER_FONT_LIST_COLUMN_TEXT,
	FONT_MANAGER_FONT_LIST_COLUMN_PREVIEW,
	FONT_MANAGER_FONT_LIST_COLUMN_COUNT,
	FONT_MANAGER_FONT_LIST_COLUMN_N_COLUMNS
} FontManagerFontListColumn;

typedef enum  {
	FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT,
	FONT_MANAGER_FONT_MODEL_COLUMN_DESCRIPTION,
	FONT_MANAGER_FONT_MODEL_COLUMN_COUNT,
	FONT_MANAGER_FONT_MODEL_COLUMN_N_COLUMNS
} FontManagerFontModelColumn;

typedef enum  {
	FONT_MANAGER_DATABASE_ERROR_ERROR,
	FONT_MANAGER_DATABASE_ERROR_BACKING,
	FONT_MANAGER_DATABASE_ERROR_MEMORY,
	FONT_MANAGER_DATABASE_ERROR_ABORT,
	FONT_MANAGER_DATABASE_ERROR_LIMITS,
	FONT_MANAGER_DATABASE_ERROR_TYPESPEC
} FontManagerDatabaseError;
#define FONT_MANAGER_DATABASE_ERROR font_manager_database_error_quark ()

static gpointer font_manager_user_font_tree_parent_class = NULL;

GType font_manager_user_font_tree_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_USER_FONT_TREE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTreePrivate))
enum  {
	FONT_MANAGER_USER_FONT_TREE_DUMMY_PROPERTY
};
GType font_manager_font_model_get_type (void) G_GNUC_CONST;
GType font_manager_user_font_model_get_type (void) G_GNUC_CONST;
FontManagerUserFontTree* font_manager_user_font_tree_new (FontManagerUserFontModel* model);
FontManagerUserFontTree* font_manager_user_font_tree_construct (GType object_type, FontManagerUserFontModel* model);
GType cell_renderer_pill_get_type (void) G_GNUC_CONST;
GType cell_renderer_count_get_type (void) G_GNUC_CONST;
CellRendererCount* cell_renderer_count_new (void);
CellRendererCount* cell_renderer_count_construct (GType object_type);
void cell_renderer_pill_set_junction_side (CellRendererPill* self, GtkJunctionSides value);
GType font_manager_font_list_column_get_type (void) G_GNUC_CONST;
static void font_manager_user_font_tree_toggle_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter);
static void _font_manager_user_font_tree_toggle_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self);
static void font_manager_user_font_tree_text_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter);
static void _font_manager_user_font_tree_text_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self);
static void font_manager_user_font_tree_preview_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter);
static void _font_manager_user_font_tree_preview_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self);
static void font_manager_user_font_tree_count_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter);
static void _font_manager_user_font_tree_count_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self);
static void font_manager_user_font_tree_connect_signals (FontManagerUserFontTree* self);
GFile** font_manager_user_font_tree_to_file_array (FontManagerUserFontTree* self, int* result_length1);
static void _vala_array_add10 (GFile*** array, int* length, int* size, GFile* value);
static void font_manager_user_font_tree_on_font_toggled (FontManagerUserFontTree* self, const gchar* path);
static void _font_manager_user_font_tree_on_font_toggled_gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self);
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_config_family_get_type (void) G_GNUC_CONST;
static gint font_manager_user_font_tree_family_state (FontManagerUserFontTree* self, FontConfigFamily* family);
GType font_config_font_get_type (void) G_GNUC_CONST;
GeeArrayList* font_config_family_list_faces (FontConfigFamily* self);
const gchar* font_config_font_get_description (FontConfigFont* self);
GType font_manager_font_model_column_get_type (void) G_GNUC_CONST;
const gchar* font_config_family_get_description (FontConfigFamily* self);
const gchar* font_config_family_get_name (FontConfigFamily* self);
const gchar* font_config_font_get_style (FontConfigFont* self);
static GObject * font_manager_user_font_tree_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
GType font_manager_database_get_type (void) G_GNUC_CONST;
GQuark font_manager_database_error_quark (void);
FontManagerDatabase* font_manager_get_database (GError** error);
GeeHashMap* font_manager_get_user_filemap (FontManagerDatabase* db, GError** error);
void font_manager_show_error_message (const gchar* message, GError* e, GtkWindow* parent);
static void font_manager_user_font_tree_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _font_manager_user_font_tree_toggle_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self) {
	font_manager_user_font_tree_toggle_cell_data_func ((FontManagerUserFontTree*) self, tree_column, cell, tree_model, iter);
}


static void _font_manager_user_font_tree_text_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self) {
	font_manager_user_font_tree_text_cell_data_func ((FontManagerUserFontTree*) self, tree_column, cell, tree_model, iter);
}


static void _font_manager_user_font_tree_preview_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self) {
	font_manager_user_font_tree_preview_cell_data_func ((FontManagerUserFontTree*) self, tree_column, cell, tree_model, iter);
}


static void _font_manager_user_font_tree_count_cell_data_func_gtk_tree_cell_data_func (GtkTreeViewColumn* tree_column, GtkCellRenderer* cell, GtkTreeModel* tree_model, GtkTreeIter* iter, gpointer self) {
	font_manager_user_font_tree_count_cell_data_func ((FontManagerUserFontTree*) self, tree_column, cell, tree_model, iter);
}


FontManagerUserFontTree* font_manager_user_font_tree_construct (GType object_type, FontManagerUserFontModel* model) {
	FontManagerUserFontTree * self = NULL;
	FontManagerUserFontModel* _tmp0_ = NULL;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkCellRendererToggle* _tmp2_ = NULL;
	GtkCellRendererText* text = NULL;
	GtkCellRendererText* _tmp3_ = NULL;
	GtkCellRendererText* preview = NULL;
	GtkCellRendererText* _tmp4_ = NULL;
	CellRendererCount* count = NULL;
	CellRendererCount* _tmp5_ = NULL;
	GtkCellRendererToggle* _tmp6_ = NULL;
	GtkTreeViewColumn* _tmp7_ = NULL;
	GtkTreeViewColumn* _tmp8_ = NULL;
	GtkTreeViewColumn* _tmp9_ = NULL;
	GtkTreeViewColumn* _tmp10_ = NULL;
	GeeHashSet* _tmp11_ = NULL;
	g_return_val_if_fail (model != NULL, NULL);
	self = (FontManagerUserFontTree*) g_object_new (object_type, NULL);
	_tmp0_ = model;
	gtk_tree_view_set_model ((GtkTreeView*) self, (GtkTreeModel*) _tmp0_);
	_tmp1_ = gtk_tree_view_get_selection ((GtkTreeView*) self);
	gtk_tree_selection_set_mode (_tmp1_, GTK_SELECTION_SINGLE);
	gtk_tree_view_set_headers_visible ((GtkTreeView*) self, FALSE);
	_tmp2_ = (GtkCellRendererToggle*) gtk_cell_renderer_toggle_new ();
	g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->priv->toggle);
	self->priv->toggle = _tmp2_;
	_tmp3_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp3_);
	text = _tmp3_;
	_tmp4_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp4_);
	preview = _tmp4_;
	g_object_set (preview, "ellipsize", PANGO_ELLIPSIZE_END, NULL);
	_tmp5_ = cell_renderer_count_new ();
	g_object_ref_sink (_tmp5_);
	count = _tmp5_;
	cell_renderer_pill_set_junction_side ((CellRendererPill*) count, GTK_JUNCTION_RIGHT);
	_tmp6_ = self->priv->toggle;
	gtk_tree_view_insert_column_with_data_func ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_TOGGLE, "", (GtkCellRenderer*) _tmp6_, _font_manager_user_font_tree_toggle_cell_data_func_gtk_tree_cell_data_func, g_object_ref (self), g_object_unref);
	gtk_tree_view_insert_column_with_data_func ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_TEXT, "", (GtkCellRenderer*) text, _font_manager_user_font_tree_text_cell_data_func_gtk_tree_cell_data_func, g_object_ref (self), g_object_unref);
	gtk_tree_view_insert_column_with_data_func ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_PREVIEW, "", (GtkCellRenderer*) preview, _font_manager_user_font_tree_preview_cell_data_func_gtk_tree_cell_data_func, g_object_ref (self), g_object_unref);
	gtk_tree_view_insert_column_with_data_func ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_COUNT, "", (GtkCellRenderer*) count, _font_manager_user_font_tree_count_cell_data_func_gtk_tree_cell_data_func, g_object_ref (self), g_object_unref);
	_tmp7_ = gtk_tree_view_get_column ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_TOGGLE);
	gtk_tree_view_column_set_expand (_tmp7_, FALSE);
	_tmp8_ = gtk_tree_view_get_column ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_TEXT);
	gtk_tree_view_column_set_expand (_tmp8_, FALSE);
	_tmp9_ = gtk_tree_view_get_column ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_PREVIEW);
	gtk_tree_view_column_set_expand (_tmp9_, TRUE);
	_tmp10_ = gtk_tree_view_get_column ((GtkTreeView*) self, (gint) FONT_MANAGER_FONT_LIST_COLUMN_COUNT);
	gtk_tree_view_column_set_expand (_tmp10_, FALSE);
	_tmp11_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->selected_paths);
	self->priv->selected_paths = _tmp11_;
	font_manager_user_font_tree_connect_signals (self);
	_g_object_unref0 (count);
	_g_object_unref0 (preview);
	_g_object_unref0 (text);
	return self;
}


FontManagerUserFontTree* font_manager_user_font_tree_new (FontManagerUserFontModel* model) {
	return font_manager_user_font_tree_construct (FONT_MANAGER_TYPE_USER_FONT_TREE, model);
}


static void _vala_array_add10 (GFile*** array, int* length, int* size, GFile* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


GFile** font_manager_user_font_tree_to_file_array (FontManagerUserFontTree* self, int* result_length1) {
	GFile** result = NULL;
	GFile** arr = NULL;
	gint arr_length1 = 0;
	gint _arr_size_ = 0;
	GFile** _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	arr = NULL;
	arr_length1 = 0;
	_arr_size_ = arr_length1;
	{
		GeeIterator* _path_it = NULL;
		GeeHashSet* _tmp0_ = NULL;
		GeeIterator* _tmp1_ = NULL;
		_tmp0_ = self->priv->selected_paths;
		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
		_path_it = _tmp1_;
		while (TRUE) {
			GeeIterator* _tmp2_ = NULL;
			gboolean _tmp3_ = FALSE;
			gchar* path = NULL;
			GeeIterator* _tmp4_ = NULL;
			gpointer _tmp5_ = NULL;
			GFile** _tmp6_ = NULL;
			gint _tmp6__length1 = 0;
			const gchar* _tmp7_ = NULL;
			GFile* _tmp8_ = NULL;
			_tmp2_ = _path_it;
			_tmp3_ = gee_iterator_next (_tmp2_);
			if (!_tmp3_) {
				break;
			}
			_tmp4_ = _path_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			path = (gchar*) _tmp5_;
			_tmp6_ = arr;
			_tmp6__length1 = arr_length1;
			_tmp7_ = path;
			_tmp8_ = g_file_new_for_path (_tmp7_);
			_vala_array_add10 (&arr, &arr_length1, &_arr_size_, _tmp8_);
			_g_free0 (path);
		}
		_g_object_unref0 (_path_it);
	}
	_tmp9_ = arr;
	_tmp9__length1 = arr_length1;
	if (result_length1) {
		*result_length1 = _tmp9__length1;
	}
	result = _tmp9_;
	return result;
}


static void _font_manager_user_font_tree_on_font_toggled_gtk_cell_renderer_toggle_toggled (GtkCellRendererToggle* _sender, const gchar* path, gpointer self) {
	font_manager_user_font_tree_on_font_toggled ((FontManagerUserFontTree*) self, path);
}


static void font_manager_user_font_tree_connect_signals (FontManagerUserFontTree* self) {
	GtkCellRendererToggle* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->toggle;
	g_signal_connect_object (_tmp0_, "toggled", (GCallback) _font_manager_user_font_tree_on_font_toggled_gtk_cell_renderer_toggle_toggled, self, 0);
	return;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gint font_manager_user_font_tree_family_state (FontManagerUserFontTree* self, FontConfigFamily* family) {
	gint result = 0;
	GeeArrayList* faces = NULL;
	FontConfigFamily* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	gint total = 0;
	GeeArrayList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint active = 0;
	gboolean _tmp31_ = FALSE;
	gint _tmp32_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (family != NULL, 0);
	_tmp0_ = family;
	_tmp1_ = font_config_family_list_faces (_tmp0_);
	faces = _tmp1_;
	_tmp2_ = faces;
	_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	total = _tmp4_;
	active = 0;
	{
		GeeArrayList* _face_list = NULL;
		GeeArrayList* _tmp5_ = NULL;
		GeeArrayList* _tmp6_ = NULL;
		gint _face_size = 0;
		GeeArrayList* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gint _face_index = 0;
		_tmp5_ = faces;
		_tmp6_ = _g_object_ref0 (_tmp5_);
		_face_list = _tmp6_;
		_tmp7_ = _face_list;
		_tmp8_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp7_);
		_tmp9_ = _tmp8_;
		_face_size = _tmp9_;
		_face_index = -1;
		while (TRUE) {
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			gint _tmp12_ = 0;
			FontConfigFont* face = NULL;
			GeeArrayList* _tmp13_ = NULL;
			gint _tmp14_ = 0;
			gpointer _tmp15_ = NULL;
			GeeHashMap* _tmp16_ = NULL;
			FontConfigFont* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			_tmp10_ = _face_index;
			_face_index = _tmp10_ + 1;
			_tmp11_ = _face_index;
			_tmp12_ = _face_size;
			if (!(_tmp11_ < _tmp12_)) {
				break;
			}
			_tmp13_ = _face_list;
			_tmp14_ = _face_index;
			_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _tmp13_, _tmp14_);
			face = (FontConfigFont*) _tmp15_;
			_tmp16_ = self->priv->filemap;
			_tmp17_ = face;
			_tmp18_ = font_config_font_get_description (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp16_, _tmp19_);
			if (_tmp20_) {
				GeeHashSet* _tmp21_ = NULL;
				GeeHashMap* _tmp22_ = NULL;
				FontConfigFont* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				gpointer _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gboolean _tmp28_ = FALSE;
				gboolean _tmp29_ = FALSE;
				_tmp21_ = self->priv->selected_paths;
				_tmp22_ = self->priv->filemap;
				_tmp23_ = face;
				_tmp24_ = font_config_font_get_description (_tmp23_);
				_tmp25_ = _tmp24_;
				_tmp26_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp22_, _tmp25_);
				_tmp27_ = (gchar*) _tmp26_;
				_tmp28_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp21_, _tmp27_);
				_tmp29_ = _tmp28_;
				_g_free0 (_tmp27_);
				if (_tmp29_) {
					gint _tmp30_ = 0;
					_tmp30_ = active;
					active = _tmp30_ + 1;
				}
			}
			_g_object_unref0 (face);
		}
		_g_object_unref0 (_face_list);
	}
	_tmp32_ = active;
	if (_tmp32_ != 0) {
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		_tmp33_ = active;
		_tmp34_ = total;
		_tmp31_ = _tmp33_ < _tmp34_;
	} else {
		_tmp31_ = FALSE;
	}
	if (_tmp31_) {
		result = -1;
		_g_object_unref0 (faces);
		return result;
	} else {
		gint _tmp35_ = 0;
		gint _tmp36_ = 0;
		_tmp35_ = active;
		_tmp36_ = total;
		if (_tmp35_ == _tmp36_) {
			result = 1;
			_g_object_unref0 (faces);
			return result;
		} else {
			result = 0;
			_g_object_unref0 (faces);
			return result;
		}
	}
	_g_object_unref0 (faces);
}


static void font_manager_user_font_tree_on_font_toggled (FontManagerUserFontTree* self, const gchar* path) {
	GtkTreeIter iter = {0};
	GValue val = {0};
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeModel* _tmp5_ = NULL;
	GtkTreeIter _tmp6_ = {0};
	GValue _tmp7_ = {0};
	GObject* font = NULL;
	GObject* _tmp8_ = NULL;
	GObject* _tmp9_ = NULL;
	GObject* _tmp10_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = gtk_tree_view_get_model ((GtkTreeView*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = path;
	gtk_tree_model_get_iter_from_string (_tmp1_, &_tmp3_, _tmp2_);
	iter = _tmp3_;
	_tmp4_ = gtk_tree_view_get_model ((GtkTreeView*) self);
	_tmp5_ = _tmp4_;
	_tmp6_ = iter;
	gtk_tree_model_get_value (_tmp5_, &_tmp6_, (gint) FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT, &_tmp7_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp7_;
	_tmp8_ = g_value_get_object (&val);
	_tmp9_ = _g_object_ref0 (_tmp8_);
	font = _tmp9_;
	_tmp10_ = font;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp10_, FONT_CONFIG_TYPE_FAMILY)) {
		gboolean inconsistent = FALSE;
		GObject* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		_tmp11_ = font;
		_tmp12_ = font_manager_user_font_tree_family_state (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, FONT_CONFIG_TYPE_FAMILY, FontConfigFamily));
		inconsistent = _tmp12_ == (-1);
		{
			GeeArrayList* _face_list = NULL;
			GObject* _tmp13_ = NULL;
			GeeArrayList* _tmp14_ = NULL;
			gint _face_size = 0;
			GeeArrayList* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			gint _tmp17_ = 0;
			gint _face_index = 0;
			_tmp13_ = font;
			_tmp14_ = font_config_family_list_faces (G_TYPE_CHECK_INSTANCE_CAST (_tmp13_, FONT_CONFIG_TYPE_FAMILY, FontConfigFamily));
			_face_list = _tmp14_;
			_tmp15_ = _face_list;
			_tmp16_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp15_);
			_tmp17_ = _tmp16_;
			_face_size = _tmp17_;
			_face_index = -1;
			while (TRUE) {
				gint _tmp18_ = 0;
				gint _tmp19_ = 0;
				gint _tmp20_ = 0;
				FontConfigFont* face = NULL;
				GeeArrayList* _tmp21_ = NULL;
				gint _tmp22_ = 0;
				gpointer _tmp23_ = NULL;
				GeeHashMap* _tmp24_ = NULL;
				FontConfigFont* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				gboolean _tmp28_ = FALSE;
				gchar* _path = NULL;
				GeeHashMap* _tmp29_ = NULL;
				FontConfigFont* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				const gchar* _tmp32_ = NULL;
				gpointer _tmp33_ = NULL;
				gboolean _tmp34_ = FALSE;
				gboolean _tmp35_ = FALSE;
				_tmp18_ = _face_index;
				_face_index = _tmp18_ + 1;
				_tmp19_ = _face_index;
				_tmp20_ = _face_size;
				if (!(_tmp19_ < _tmp20_)) {
					break;
				}
				_tmp21_ = _face_list;
				_tmp22_ = _face_index;
				_tmp23_ = gee_abstract_list_get ((GeeAbstractList*) _tmp21_, _tmp22_);
				face = (FontConfigFont*) _tmp23_;
				_tmp24_ = self->priv->filemap;
				_tmp25_ = face;
				_tmp26_ = font_config_font_get_description (_tmp25_);
				_tmp27_ = _tmp26_;
				_tmp28_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp24_, _tmp27_);
				if (!_tmp28_) {
					_g_object_unref0 (face);
					continue;
				}
				_tmp29_ = self->priv->filemap;
				_tmp30_ = face;
				_tmp31_ = font_config_font_get_description (_tmp30_);
				_tmp32_ = _tmp31_;
				_tmp33_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, _tmp32_);
				_path = (gchar*) _tmp33_;
				_tmp35_ = inconsistent;
				if (!_tmp35_) {
					GeeHashSet* _tmp36_ = NULL;
					const gchar* _tmp37_ = NULL;
					gboolean _tmp38_ = FALSE;
					_tmp36_ = self->priv->selected_paths;
					_tmp37_ = _path;
					_tmp38_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp36_, _tmp37_);
					_tmp34_ = _tmp38_;
				} else {
					_tmp34_ = FALSE;
				}
				if (_tmp34_) {
					GeeHashSet* _tmp39_ = NULL;
					const gchar* _tmp40_ = NULL;
					_tmp39_ = self->priv->selected_paths;
					_tmp40_ = _path;
					gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp39_, _tmp40_);
				} else {
					GeeHashSet* _tmp41_ = NULL;
					const gchar* _tmp42_ = NULL;
					_tmp41_ = self->priv->selected_paths;
					_tmp42_ = _path;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp41_, _tmp42_);
				}
				_g_free0 (_path);
				_g_object_unref0 (face);
			}
			_g_object_unref0 (_face_list);
		}
	} else {
		gchar* _path = NULL;
		GeeHashMap* _tmp43_ = NULL;
		GObject* _tmp44_ = NULL;
		const gchar* _tmp45_ = NULL;
		const gchar* _tmp46_ = NULL;
		gpointer _tmp47_ = NULL;
		GeeHashSet* _tmp48_ = NULL;
		const gchar* _tmp49_ = NULL;
		gboolean _tmp50_ = FALSE;
		_tmp43_ = self->priv->filemap;
		_tmp44_ = font;
		_tmp45_ = font_config_font_get_description (G_TYPE_CHECK_INSTANCE_CAST (_tmp44_, FONT_CONFIG_TYPE_FONT, FontConfigFont));
		_tmp46_ = _tmp45_;
		_tmp47_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp43_, _tmp46_);
		_path = (gchar*) _tmp47_;
		_tmp48_ = self->priv->selected_paths;
		_tmp49_ = _path;
		_tmp50_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp48_, _tmp49_);
		if (_tmp50_) {
			GeeHashSet* _tmp51_ = NULL;
			const gchar* _tmp52_ = NULL;
			_tmp51_ = self->priv->selected_paths;
			_tmp52_ = _path;
			gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp51_, _tmp52_);
		} else {
			GeeHashSet* _tmp53_ = NULL;
			const gchar* _tmp54_ = NULL;
			_tmp53_ = self->priv->selected_paths;
			_tmp54_ = _path;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp53_, _tmp54_);
		}
		_g_free0 (_path);
	}
	g_value_unset (&val);
	gtk_widget_queue_draw ((GtkWidget*) self);
	_g_object_unref0 (font);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return;
}


static void font_manager_user_font_tree_preview_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter) {
	GValue val = {0};
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	GValue _tmp2_ = {0};
	GObject* obj = NULL;
	GObject* _tmp3_ = NULL;
	GObject* _tmp4_ = NULL;
	GObject* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (layout != NULL);
	g_return_if_fail (cell != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (treeiter != NULL);
	_tmp0_ = model;
	_tmp1_ = *treeiter;
	gtk_tree_model_get_value (_tmp0_, &_tmp1_, (gint) FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT, &_tmp2_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp2_;
	_tmp3_ = g_value_get_object (&val);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	obj = _tmp4_;
	_tmp5_ = obj;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, FONT_CONFIG_TYPE_FAMILY)) {
		GtkCellRenderer* _tmp6_ = NULL;
		GObject* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		GValue _tmp10_ = {0};
		GtkCellRenderer* _tmp11_ = NULL;
		GValue _tmp12_ = {0};
		GtkCellRenderer* _tmp13_ = NULL;
		GValue _tmp14_ = {0};
		GtkCellRenderer* _tmp15_ = NULL;
		GValue _tmp16_ = {0};
		_tmp6_ = cell;
		_tmp7_ = obj;
		_tmp8_ = font_config_family_get_description (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, FONT_CONFIG_TYPE_FAMILY, FontConfigFamily));
		_tmp9_ = _tmp8_;
		g_value_init (&_tmp10_, G_TYPE_STRING);
		g_value_set_string (&_tmp10_, _tmp9_);
		g_object_set_property ((GObject*) _tmp6_, "text", &_tmp10_);
		G_IS_VALUE (&_tmp10_) ? (g_value_unset (&_tmp10_), NULL) : NULL;
		_tmp11_ = cell;
		g_value_init (&_tmp12_, G_TYPE_INT);
		g_value_set_int (&_tmp12_, 0);
		g_object_set_property ((GObject*) _tmp11_, "ypad", &_tmp12_);
		G_IS_VALUE (&_tmp12_) ? (g_value_unset (&_tmp12_), NULL) : NULL;
		_tmp13_ = cell;
		g_value_init (&_tmp14_, G_TYPE_INT);
		g_value_set_int (&_tmp14_, 0);
		g_object_set_property ((GObject*) _tmp13_, "xpad", &_tmp14_);
		G_IS_VALUE (&_tmp14_) ? (g_value_unset (&_tmp14_), NULL) : NULL;
		_tmp15_ = cell;
		g_value_init (&_tmp16_, G_TYPE_BOOLEAN);
		g_value_set_boolean (&_tmp16_, FALSE);
		g_object_set_property ((GObject*) _tmp15_, "visible", &_tmp16_);
		G_IS_VALUE (&_tmp16_) ? (g_value_unset (&_tmp16_), NULL) : NULL;
	} else {
		GtkCellRenderer* _tmp17_ = NULL;
		GObject* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		GValue _tmp21_ = {0};
		GtkCellRenderer* _tmp22_ = NULL;
		GValue _tmp23_ = {0};
		GtkCellRenderer* _tmp24_ = NULL;
		GValue _tmp25_ = {0};
		GtkCellRenderer* _tmp26_ = NULL;
		GValue _tmp27_ = {0};
		GtkCellRenderer* _tmp28_ = NULL;
		GObject* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		GValue _tmp32_ = {0};
		_tmp17_ = cell;
		_tmp18_ = obj;
		_tmp19_ = font_config_font_get_description (G_TYPE_CHECK_INSTANCE_CAST (_tmp18_, FONT_CONFIG_TYPE_FONT, FontConfigFont));
		_tmp20_ = _tmp19_;
		g_value_init (&_tmp21_, G_TYPE_STRING);
		g_value_set_string (&_tmp21_, _tmp20_);
		g_object_set_property ((GObject*) _tmp17_, "text", &_tmp21_);
		G_IS_VALUE (&_tmp21_) ? (g_value_unset (&_tmp21_), NULL) : NULL;
		_tmp22_ = cell;
		g_value_init (&_tmp23_, G_TYPE_INT);
		g_value_set_int (&_tmp23_, 3);
		g_object_set_property ((GObject*) _tmp22_, "ypad", &_tmp23_);
		G_IS_VALUE (&_tmp23_) ? (g_value_unset (&_tmp23_), NULL) : NULL;
		_tmp24_ = cell;
		g_value_init (&_tmp25_, G_TYPE_INT);
		g_value_set_int (&_tmp25_, 6);
		g_object_set_property ((GObject*) _tmp24_, "xpad", &_tmp25_);
		G_IS_VALUE (&_tmp25_) ? (g_value_unset (&_tmp25_), NULL) : NULL;
		_tmp26_ = cell;
		g_value_init (&_tmp27_, G_TYPE_BOOLEAN);
		g_value_set_boolean (&_tmp27_, TRUE);
		g_object_set_property ((GObject*) _tmp26_, "visible", &_tmp27_);
		G_IS_VALUE (&_tmp27_) ? (g_value_unset (&_tmp27_), NULL) : NULL;
		_tmp28_ = cell;
		_tmp29_ = obj;
		_tmp30_ = font_config_font_get_description (G_TYPE_CHECK_INSTANCE_CAST (_tmp29_, FONT_CONFIG_TYPE_FONT, FontConfigFont));
		_tmp31_ = _tmp30_;
		g_value_init (&_tmp32_, G_TYPE_STRING);
		g_value_set_string (&_tmp32_, _tmp31_);
		g_object_set_property ((GObject*) _tmp28_, "font", &_tmp32_);
		G_IS_VALUE (&_tmp32_) ? (g_value_unset (&_tmp32_), NULL) : NULL;
	}
	g_value_unset (&val);
	_g_object_unref0 (obj);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return;
}


static void font_manager_user_font_tree_toggle_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter) {
	GValue val = {0};
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	GValue _tmp2_ = {0};
	GObject* obj = NULL;
	GObject* _tmp3_ = NULL;
	GObject* _tmp4_ = NULL;
	GtkCellRenderer* _tmp5_ = NULL;
	GValue _tmp6_ = {0};
	GtkCellRenderer* _tmp7_ = NULL;
	GValue _tmp8_ = {0};
	GtkCellRenderer* _tmp9_ = NULL;
	GValue _tmp10_ = {0};
	GObject* _tmp11_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (layout != NULL);
	g_return_if_fail (cell != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (treeiter != NULL);
	_tmp0_ = model;
	_tmp1_ = *treeiter;
	gtk_tree_model_get_value (_tmp0_, &_tmp1_, (gint) FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT, &_tmp2_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp2_;
	_tmp3_ = g_value_get_object (&val);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	obj = _tmp4_;
	_tmp5_ = cell;
	g_value_init (&_tmp6_, G_TYPE_BOOLEAN);
	g_value_set_boolean (&_tmp6_, TRUE);
	g_object_set_property ((GObject*) _tmp5_, "visible", &_tmp6_);
	G_IS_VALUE (&_tmp6_) ? (g_value_unset (&_tmp6_), NULL) : NULL;
	_tmp7_ = cell;
	g_value_init (&_tmp8_, G_TYPE_BOOLEAN);
	g_value_set_boolean (&_tmp8_, TRUE);
	g_object_set_property ((GObject*) _tmp7_, "sensitive", &_tmp8_);
	G_IS_VALUE (&_tmp8_) ? (g_value_unset (&_tmp8_), NULL) : NULL;
	_tmp9_ = cell;
	g_value_init (&_tmp10_, G_TYPE_BOOLEAN);
	g_value_set_boolean (&_tmp10_, FALSE);
	g_object_set_property ((GObject*) _tmp9_, "inconsistent", &_tmp10_);
	G_IS_VALUE (&_tmp10_) ? (g_value_unset (&_tmp10_), NULL) : NULL;
	_tmp11_ = obj;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp11_, FONT_CONFIG_TYPE_FAMILY)) {
		gint active = 0;
		GObject* _tmp12_ = NULL;
		gint _tmp13_ = 0;
		gint _tmp14_ = 0;
		_tmp12_ = obj;
		_tmp13_ = font_manager_user_font_tree_family_state (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp12_, FONT_CONFIG_TYPE_FAMILY, FontConfigFamily));
		active = _tmp13_;
		_tmp14_ = active;
		if (_tmp14_ == (-1)) {
			GtkCellRenderer* _tmp15_ = NULL;
			GValue _tmp16_ = {0};
			GtkCellRenderer* _tmp17_ = NULL;
			GValue _tmp18_ = {0};
			_tmp15_ = cell;
			g_value_init (&_tmp16_, G_TYPE_BOOLEAN);
			g_value_set_boolean (&_tmp16_, TRUE);
			g_object_set_property ((GObject*) _tmp15_, "inconsistent", &_tmp16_);
			G_IS_VALUE (&_tmp16_) ? (g_value_unset (&_tmp16_), NULL) : NULL;
			_tmp17_ = cell;
			g_value_init (&_tmp18_, G_TYPE_BOOLEAN);
			g_value_set_boolean (&_tmp18_, FALSE);
			g_object_set_property ((GObject*) _tmp17_, "active", &_tmp18_);
			G_IS_VALUE (&_tmp18_) ? (g_value_unset (&_tmp18_), NULL) : NULL;
		} else {
			GtkCellRenderer* _tmp19_ = NULL;
			gint _tmp20_ = 0;
			GValue _tmp21_ = {0};
			_tmp19_ = cell;
			_tmp20_ = active;
			g_value_init (&_tmp21_, G_TYPE_INT);
			g_value_set_int (&_tmp21_, _tmp20_);
			g_object_set_property ((GObject*) _tmp19_, "active", &_tmp21_);
			G_IS_VALUE (&_tmp21_) ? (g_value_unset (&_tmp21_), NULL) : NULL;
		}
	} else {
		gchar* _path = NULL;
		GeeHashMap* _tmp22_ = NULL;
		GObject* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		gpointer _tmp26_ = NULL;
		GtkCellRenderer* _tmp27_ = NULL;
		GeeHashSet* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		gboolean _tmp30_ = FALSE;
		GValue _tmp31_ = {0};
		_tmp22_ = self->priv->filemap;
		_tmp23_ = obj;
		_tmp24_ = font_config_font_get_description (G_TYPE_CHECK_INSTANCE_CAST (_tmp23_, FONT_CONFIG_TYPE_FONT, FontConfigFont));
		_tmp25_ = _tmp24_;
		_tmp26_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp22_, _tmp25_);
		_path = (gchar*) _tmp26_;
		_tmp27_ = cell;
		_tmp28_ = self->priv->selected_paths;
		_tmp29_ = _path;
		_tmp30_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp28_, _tmp29_);
		g_value_init (&_tmp31_, G_TYPE_BOOLEAN);
		g_value_set_boolean (&_tmp31_, _tmp30_);
		g_object_set_property ((GObject*) _tmp27_, "active", &_tmp31_);
		G_IS_VALUE (&_tmp31_) ? (g_value_unset (&_tmp31_), NULL) : NULL;
		_g_free0 (_path);
	}
	g_value_unset (&val);
	_g_object_unref0 (obj);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return;
}


static void font_manager_user_font_tree_text_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter) {
	GValue val = {0};
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	GValue _tmp2_ = {0};
	GObject* obj = NULL;
	GObject* _tmp3_ = NULL;
	GObject* _tmp4_ = NULL;
	GObject* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (layout != NULL);
	g_return_if_fail (cell != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (treeiter != NULL);
	_tmp0_ = model;
	_tmp1_ = *treeiter;
	gtk_tree_model_get_value (_tmp0_, &_tmp1_, (gint) FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT, &_tmp2_);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	val = _tmp2_;
	_tmp3_ = g_value_get_object (&val);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	obj = _tmp4_;
	_tmp5_ = obj;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, FONT_CONFIG_TYPE_FAMILY)) {
		GtkCellRenderer* _tmp6_ = NULL;
		GObject* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		GValue _tmp10_ = {0};
		GtkCellRenderer* _tmp11_ = NULL;
		GValue _tmp12_ = {0};
		GtkCellRenderer* _tmp13_ = NULL;
		GValue _tmp14_ = {0};
		_tmp6_ = cell;
		_tmp7_ = obj;
		_tmp8_ = font_config_family_get_name (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, FONT_CONFIG_TYPE_FAMILY, FontConfigFamily));
		_tmp9_ = _tmp8_;
		g_value_init (&_tmp10_, G_TYPE_STRING);
		g_value_set_string (&_tmp10_, _tmp9_);
		g_object_set_property ((GObject*) _tmp6_, "text", &_tmp10_);
		G_IS_VALUE (&_tmp10_) ? (g_value_unset (&_tmp10_), NULL) : NULL;
		_tmp11_ = cell;
		g_value_init (&_tmp12_, G_TYPE_INT);
		g_value_set_int (&_tmp12_, 0);
		g_object_set_property ((GObject*) _tmp11_, "ypad", &_tmp12_);
		G_IS_VALUE (&_tmp12_) ? (g_value_unset (&_tmp12_), NULL) : NULL;
		_tmp13_ = cell;
		g_value_init (&_tmp14_, G_TYPE_INT);
		g_value_set_int (&_tmp14_, 0);
		g_object_set_property ((GObject*) _tmp13_, "xpad", &_tmp14_);
		G_IS_VALUE (&_tmp14_) ? (g_value_unset (&_tmp14_), NULL) : NULL;
	} else {
		GtkCellRenderer* _tmp15_ = NULL;
		GObject* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		GValue _tmp19_ = {0};
		GtkCellRenderer* _tmp20_ = NULL;
		GValue _tmp21_ = {0};
		GtkCellRenderer* _tmp22_ = NULL;
		GValue _tmp23_ = {0};
		_tmp15_ = cell;
		_tmp16_ = obj;
		_tmp17_ = font_config_font_get_style (G_TYPE_CHECK_INSTANCE_CAST (_tmp16_, FONT_CONFIG_TYPE_FONT, FontConfigFont));
		_tmp18_ = _tmp17_;
		g_value_init (&_tmp19_, G_TYPE_STRING);
		g_value_set_string (&_tmp19_, _tmp18_);
		g_object_set_property ((GObject*) _tmp15_, "text", &_tmp19_);
		G_IS_VALUE (&_tmp19_) ? (g_value_unset (&_tmp19_), NULL) : NULL;
		_tmp20_ = cell;
		g_value_init (&_tmp21_, G_TYPE_INT);
		g_value_set_int (&_tmp21_, 3);
		g_object_set_property ((GObject*) _tmp20_, "ypad", &_tmp21_);
		G_IS_VALUE (&_tmp21_) ? (g_value_unset (&_tmp21_), NULL) : NULL;
		_tmp22_ = cell;
		g_value_init (&_tmp23_, G_TYPE_INT);
		g_value_set_int (&_tmp23_, 6);
		g_object_set_property ((GObject*) _tmp22_, "xpad", &_tmp23_);
		G_IS_VALUE (&_tmp23_) ? (g_value_unset (&_tmp23_), NULL) : NULL;
	}
	g_value_unset (&val);
	_g_object_unref0 (obj);
	G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
	return;
}


static void font_manager_user_font_tree_count_cell_data_func (FontManagerUserFontTree* self, GtkTreeViewColumn* layout, GtkCellRenderer* cell, GtkTreeModel* model, GtkTreeIter* treeiter) {
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (layout != NULL);
	g_return_if_fail (cell != NULL);
	g_return_if_fail (model != NULL);
	g_return_if_fail (treeiter != NULL);
	_tmp0_ = model;
	_tmp1_ = *treeiter;
	_tmp2_ = gtk_tree_model_iter_has_child (_tmp0_, &_tmp1_);
	if (_tmp2_) {
		gint count = 0;
		GtkTreeIter child = {0};
		gboolean have_child = FALSE;
		GtkTreeModel* _tmp3_ = NULL;
		GtkTreeIter _tmp4_ = {0};
		GtkTreeIter _tmp5_ = {0};
		gboolean _tmp6_ = FALSE;
		GtkCellRenderer* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		GValue _tmp13_ = {0};
		GtkCellRenderer* _tmp14_ = NULL;
		GValue _tmp15_ = {0};
		count = 0;
		_tmp3_ = model;
		_tmp4_ = *treeiter;
		_tmp6_ = gtk_tree_model_iter_children (_tmp3_, &_tmp5_, &_tmp4_);
		child = _tmp5_;
		have_child = _tmp6_;
		while (TRUE) {
			gboolean _tmp7_ = FALSE;
			gint _tmp8_ = 0;
			GtkTreeModel* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			_tmp7_ = have_child;
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = count;
			count = _tmp8_ + 1;
			_tmp9_ = model;
			_tmp10_ = gtk_tree_model_iter_next (_tmp9_, &child);
			have_child = _tmp10_;
		}
		_tmp11_ = cell;
		_tmp12_ = count;
		g_value_init (&_tmp13_, G_TYPE_INT);
		g_value_set_int (&_tmp13_, _tmp12_);
		g_object_set_property ((GObject*) _tmp11_, "count", &_tmp13_);
		G_IS_VALUE (&_tmp13_) ? (g_value_unset (&_tmp13_), NULL) : NULL;
		_tmp14_ = cell;
		g_value_init (&_tmp15_, G_TYPE_BOOLEAN);
		g_value_set_boolean (&_tmp15_, TRUE);
		g_object_set_property ((GObject*) _tmp14_, "visible", &_tmp15_);
		G_IS_VALUE (&_tmp15_) ? (g_value_unset (&_tmp15_), NULL) : NULL;
	} else {
		GtkCellRenderer* _tmp16_ = NULL;
		GValue _tmp17_ = {0};
		GtkCellRenderer* _tmp18_ = NULL;
		GValue _tmp19_ = {0};
		_tmp16_ = cell;
		g_value_init (&_tmp17_, G_TYPE_INT);
		g_value_set_int (&_tmp17_, 0);
		g_object_set_property ((GObject*) _tmp16_, "count", &_tmp17_);
		G_IS_VALUE (&_tmp17_) ? (g_value_unset (&_tmp17_), NULL) : NULL;
		_tmp18_ = cell;
		g_value_init (&_tmp19_, G_TYPE_BOOLEAN);
		g_value_set_boolean (&_tmp19_, FALSE);
		g_object_set_property ((GObject*) _tmp18_, "visible", &_tmp19_);
		G_IS_VALUE (&_tmp19_) ? (g_value_unset (&_tmp19_), NULL) : NULL;
	}
	return;
}


static GObject * font_manager_user_font_tree_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FontManagerUserFontTree * self;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (font_manager_user_font_tree_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTree);
	{
		FontManagerDatabase* _tmp0_ = NULL;
		FontManagerDatabase* _tmp1_ = NULL;
		GeeHashMap* _tmp2_ = NULL;
		GeeHashMap* _tmp3_ = NULL;
		GeeHashMap* _tmp4_ = NULL;
		_tmp1_ = font_manager_get_database (&_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch45_font_manager_database_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		_tmp3_ = font_manager_get_user_filemap (_tmp0_, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (_tmp0_);
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch45_font_manager_database_error;
			}
			_g_object_unref0 (_tmp0_);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		_tmp4_ = _tmp2_;
		_tmp2_ = NULL;
		_g_object_unref0 (self->priv->filemap);
		self->priv->filemap = _tmp4_;
		_g_object_unref0 (_tmp2_);
		_g_object_unref0 (_tmp0_);
	}
	goto __finally45;
	__catch45_font_manager_database_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_critical ("UserFontTree.vala:37: %s", _tmp6_);
		_tmp7_ = _ ("There was an error accessing the database");
		_tmp8_ = e;
		font_manager_show_error_message (_tmp7_, _tmp8_, NULL);
		_g_error_free0 (e);
	}
	__finally45:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void font_manager_user_font_tree_class_init (FontManagerUserFontTreeClass * klass) {
	font_manager_user_font_tree_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerUserFontTreePrivate));
	G_OBJECT_CLASS (klass)->constructor = font_manager_user_font_tree_constructor;
	G_OBJECT_CLASS (klass)->finalize = font_manager_user_font_tree_finalize;
}


static void font_manager_user_font_tree_instance_init (FontManagerUserFontTree * self) {
	self->priv = FONT_MANAGER_USER_FONT_TREE_GET_PRIVATE (self);
}


static void font_manager_user_font_tree_finalize (GObject* obj) {
	FontManagerUserFontTree * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTree);
	_g_object_unref0 (self->priv->toggle);
	_g_object_unref0 (self->priv->selected_paths);
	_g_object_unref0 (self->priv->filemap);
	G_OBJECT_CLASS (font_manager_user_font_tree_parent_class)->finalize (obj);
}


GType font_manager_user_font_tree_get_type (void) {
	static volatile gsize font_manager_user_font_tree_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_user_font_tree_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerUserFontTreeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_user_font_tree_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerUserFontTree), 0, (GInstanceInitFunc) font_manager_user_font_tree_instance_init, NULL };
		GType font_manager_user_font_tree_type_id;
		font_manager_user_font_tree_type_id = g_type_register_static (gtk_tree_view_get_type (), "FontManagerUserFontTree", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_user_font_tree_type_id__volatile, font_manager_user_font_tree_type_id);
	}
	return font_manager_user_font_tree_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



