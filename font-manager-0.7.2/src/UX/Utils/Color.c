/* Color.c generated by valac 0.26.1, the Vala compiler
 * generated from Color.vala, do not modify */

/* From libplank, namespace modified, "using" declarations removed. */
/**/
/*  Copyright (C) 2011 Robert Dyer*/
/**/
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

struct _Color {
	gdouble R;
	gdouble G;
	gdouble B;
	gdouble A;
};



GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
void color_from_gdk_color (GdkColor* color, Color* result);
void color_to_gdk_color (Color *self, GdkColor* result);
void color_from_gdk_rgba (GdkRGBA* color, Color* result);
void color_to_gdk_rgba (Color *self, GdkRGBA* result);
gboolean color_equal (Color *self, Color* color);
void color_set_hsv (Color *self, gdouble h, gdouble s, gdouble v);
static void color_hsv_to_rgb (gdouble h, gdouble s, gdouble v, gdouble* r, gdouble* g, gdouble* b);
void color_set_hue (Color *self, gdouble hue);
static void color_rgb_to_hsv (gdouble r, gdouble g, gdouble b, gdouble* h, gdouble* s, gdouble* v);
void color_set_sat (Color *self, gdouble sat);
void color_set_val (Color *self, gdouble val);
void color_set_alpha (Color *self, gdouble alpha);
void color_get_hsv (Color *self, gdouble* h, gdouble* s, gdouble* v);
gdouble color_get_hue (Color *self);
gdouble color_get_sat (Color *self);
gdouble color_get_val (Color *self);
void color_add_hue (Color *self, gdouble val);
void color_set_min_sat (Color *self, gdouble sat);
void color_set_min_value (Color *self, gdouble val);
void color_set_max_sat (Color *self, gdouble sat);
void color_set_max_val (Color *self, gdouble val);
void color_multiply_sat (Color *self, gdouble amount);
void color_brighten_val (Color *self, gdouble amount);
void color_darken_val (Color *self, gdouble amount);
void color_darken_by_sat (Color *self, gdouble amount);
gchar* color_to_string (Color *self);
void color_from_string (const gchar* s, Color* result);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


/**
     * Creates a new color from a {@link Gdk.Color}.
     *
     * @param color the color to use
     * @return new {@link Color} based on the given one
     */
void color_from_gdk_color (GdkColor* color, Color* result) {
	GdkColor _tmp0_ = {0};
	guint16 _tmp1_ = 0U;
	GdkColor _tmp2_ = {0};
	guint16 _tmp3_ = 0U;
	GdkColor _tmp4_ = {0};
	guint16 _tmp5_ = 0U;
	Color _tmp6_ = {0};
	g_return_if_fail (color != NULL);
	_tmp0_ = *color;
	_tmp1_ = _tmp0_.red;
	_tmp2_ = *color;
	_tmp3_ = _tmp2_.green;
	_tmp4_ = *color;
	_tmp5_ = _tmp4_.blue;
	_tmp6_.R = ((gdouble) _tmp1_) / G_MAXUINT16;
	_tmp6_.G = ((gdouble) _tmp3_) / G_MAXUINT16;
	_tmp6_.B = ((gdouble) _tmp5_) / G_MAXUINT16;
	_tmp6_.A = 1.0;
	*result = _tmp6_;
	return;
}


/**
     * Creates a new {@link Gdk.Color}.from this color
     *
     * @return new {@link Gdk.Color}
     */
void color_to_gdk_color (Color *self, GdkColor* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	GdkColor _tmp3_ = {0};
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	_tmp3_.pixel = (guint32) 0;
	_tmp3_.red = (guint16) (_tmp0_ * G_MAXUINT16);
	_tmp3_.green = (guint16) (_tmp1_ * G_MAXUINT16);
	_tmp3_.blue = (guint16) (_tmp2_ * G_MAXUINT16);
	*result = _tmp3_;
	return;
}


/**
     * Creates a new color from a {@link Gdk.RGBA}.
     *
     * @param color the color to use
     * @return new {@link Color} based on the given one
     */
void color_from_gdk_rgba (GdkRGBA* color, Color* result) {
	GdkRGBA _tmp0_ = {0};
	gdouble _tmp1_ = 0.0;
	GdkRGBA _tmp2_ = {0};
	gdouble _tmp3_ = 0.0;
	GdkRGBA _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	GdkRGBA _tmp6_ = {0};
	gdouble _tmp7_ = 0.0;
	Color _tmp8_ = {0};
	g_return_if_fail (color != NULL);
	_tmp0_ = *color;
	_tmp1_ = _tmp0_.red;
	_tmp2_ = *color;
	_tmp3_ = _tmp2_.green;
	_tmp4_ = *color;
	_tmp5_ = _tmp4_.blue;
	_tmp6_ = *color;
	_tmp7_ = _tmp6_.alpha;
	_tmp8_.R = _tmp1_;
	_tmp8_.G = _tmp3_;
	_tmp8_.B = _tmp5_;
	_tmp8_.A = _tmp7_;
	*result = _tmp8_;
	return;
}


/**
     * Creates a new {@link Gdk.RGBA}.from this color
     *
     * @return new {@link Gdk.RGBA}
     */
void color_to_gdk_rgba (Color *self, GdkRGBA* result) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	GdkRGBA _tmp4_ = {0};
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	_tmp3_ = (*self).A;
	_tmp4_.red = _tmp0_;
	_tmp4_.green = _tmp1_;
	_tmp4_.blue = _tmp2_;
	_tmp4_.alpha = _tmp3_;
	*result = _tmp4_;
	return;
}


/**
     * Check equality with the give color
     *
     * @return whether the give color equals this color.
     */
gboolean color_equal (Color *self, Color* color) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gdouble _tmp3_ = 0.0;
	Color _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	g_return_val_if_fail (color != NULL, FALSE);
	_tmp3_ = (*self).R;
	_tmp4_ = *color;
	_tmp5_ = _tmp4_.R;
	if (_tmp3_ == _tmp5_) {
		gdouble _tmp6_ = 0.0;
		Color _tmp7_ = {0};
		gdouble _tmp8_ = 0.0;
		_tmp6_ = (*self).G;
		_tmp7_ = *color;
		_tmp8_ = _tmp7_.G;
		_tmp2_ = _tmp6_ == _tmp8_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gdouble _tmp9_ = 0.0;
		Color _tmp10_ = {0};
		gdouble _tmp11_ = 0.0;
		_tmp9_ = (*self).B;
		_tmp10_ = *color;
		_tmp11_ = _tmp10_.B;
		_tmp1_ = _tmp9_ == _tmp11_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gdouble _tmp12_ = 0.0;
		Color _tmp13_ = {0};
		gdouble _tmp14_ = 0.0;
		_tmp12_ = (*self).A;
		_tmp13_ = *color;
		_tmp14_ = _tmp13_.A;
		_tmp0_ = _tmp12_ == _tmp14_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


/**
     * Set HSV color values of this color.
     */
void color_set_hsv (Color *self, gdouble h, gdouble s, gdouble v) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = h;
	_tmp1_ = s;
	_tmp2_ = v;
	color_hsv_to_rgb (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	(*self).R = _tmp3_;
	(*self).G = _tmp4_;
	(*self).B = _tmp5_;
}


/**
     * Sets the hue for the color.
     *
     * @param hue the new hue for the color
     */
void color_set_hue (Color *self, gdouble hue) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	_tmp0_ = hue;
	_tmp1_ = hue;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 360)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = hue;
	h = _tmp8_;
	_tmp9_ = h;
	color_hsv_to_rgb (_tmp9_, s, v, &_tmp10_, &_tmp11_, &_tmp12_);
	(*self).R = _tmp10_;
	(*self).G = _tmp11_;
	(*self).B = _tmp12_;
}


/**
     * Sets the saturation for the color.
     *
     * @param sat the new saturation for the color
     */
void color_set_sat (Color *self, gdouble sat) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	_tmp0_ = sat;
	_tmp1_ = sat;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = sat;
	s = _tmp8_;
	_tmp9_ = s;
	color_hsv_to_rgb (h, _tmp9_, v, &_tmp10_, &_tmp11_, &_tmp12_);
	(*self).R = _tmp10_;
	(*self).G = _tmp11_;
	(*self).B = _tmp12_;
}


/**
     * Sets the value for the color.
     *
     * @param val the new value for the color
     */
void color_set_val (Color *self, gdouble val) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	_tmp0_ = val;
	_tmp1_ = val;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = val;
	v = _tmp8_;
	_tmp9_ = v;
	color_hsv_to_rgb (h, s, _tmp9_, &_tmp10_, &_tmp11_, &_tmp12_);
	(*self).R = _tmp10_;
	(*self).G = _tmp11_;
	(*self).B = _tmp12_;
}


/**
     * Sets the alpha for the color.
     *
     * @param alpha the new alpha for the color
     */
void color_set_alpha (Color *self, gdouble alpha) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	_tmp0_ = alpha;
	_tmp1_ = alpha;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = alpha;
	(*self).A = _tmp2_;
}


/**
     * Get HSV color values of this color.
     */
void color_get_hsv (Color *self, gdouble* h, gdouble* s, gdouble* v) {
	gdouble _vala_h = 0.0;
	gdouble _vala_s = 0.0;
	gdouble _vala_v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	color_rgb_to_hsv (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	_vala_h = _tmp3_;
	_vala_s = _tmp4_;
	_vala_v = _tmp5_;
	if (h) {
		*h = _vala_h;
	}
	if (s) {
		*s = _vala_s;
	}
	if (v) {
		*v = _vala_v;
	}
}


/**
     * Returns the hue for the color.
     *
     * @return the hue for the color
     */
gdouble color_get_hue (Color *self) {
	gdouble result = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	color_rgb_to_hsv (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	h = _tmp3_;
	s = _tmp4_;
	v = _tmp5_;
	result = h;
	return result;
}


/**
     * Returns the saturation for the color.
     *
     * @return the saturation for the color
     */
gdouble color_get_sat (Color *self) {
	gdouble result = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	color_rgb_to_hsv (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	h = _tmp3_;
	s = _tmp4_;
	v = _tmp5_;
	result = s;
	return result;
}


/**
     * Returns the value for the color.
     *
     * @return the value for the color
     */
gdouble color_get_val (Color *self) {
	gdouble result = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	color_rgb_to_hsv (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	h = _tmp3_;
	s = _tmp4_;
	v = _tmp5_;
	result = v;
	return result;
}


/**
     * Increases the color's hue.
     *
     * @param val the amount to add to the hue
     */
void color_add_hue (Color *self, gdouble val) {
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	color_rgb_to_hsv (_tmp0_, _tmp1_, _tmp2_, &_tmp3_, &_tmp4_, &_tmp5_);
	h = _tmp3_;
	s = _tmp4_;
	v = _tmp5_;
	_tmp6_ = h;
	_tmp7_ = val;
	h = fmod (fmod (_tmp6_ + _tmp7_, 360) + 360, 360);
	_tmp8_ = h;
	color_hsv_to_rgb (_tmp8_, s, v, &_tmp9_, &_tmp10_, &_tmp11_);
	(*self).R = _tmp9_;
	(*self).G = _tmp10_;
	(*self).B = _tmp11_;
}


/**
     * Limits the color's saturation.
     *
     * @param sat the minimum saturation allowed
     */
void color_set_min_sat (Color *self, gdouble sat) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	_tmp0_ = sat;
	_tmp1_ = sat;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = s;
	_tmp9_ = sat;
	_tmp10_ = MAX (_tmp8_, _tmp9_);
	s = _tmp10_;
	_tmp11_ = s;
	color_hsv_to_rgb (h, _tmp11_, v, &_tmp12_, &_tmp13_, &_tmp14_);
	(*self).R = _tmp12_;
	(*self).G = _tmp13_;
	(*self).B = _tmp14_;
}


/**
     * Limits the color's value.
     *
     * @param val the minimum value allowed
     */
void color_set_min_value (Color *self, gdouble val) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	_tmp0_ = val;
	_tmp1_ = val;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = v;
	_tmp9_ = val;
	_tmp10_ = MAX (_tmp8_, _tmp9_);
	v = _tmp10_;
	_tmp11_ = v;
	color_hsv_to_rgb (h, s, _tmp11_, &_tmp12_, &_tmp13_, &_tmp14_);
	(*self).R = _tmp12_;
	(*self).G = _tmp13_;
	(*self).B = _tmp14_;
}


/**
     * Limits the color's saturation.
     *
     * @param sat the maximum saturation allowed
     */
void color_set_max_sat (Color *self, gdouble sat) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	_tmp0_ = sat;
	_tmp1_ = sat;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = s;
	_tmp9_ = sat;
	_tmp10_ = MIN (_tmp8_, _tmp9_);
	s = _tmp10_;
	_tmp11_ = s;
	color_hsv_to_rgb (h, _tmp11_, v, &_tmp12_, &_tmp13_, &_tmp14_);
	(*self).R = _tmp12_;
	(*self).G = _tmp13_;
	(*self).B = _tmp14_;
}


/**
     * Limits the color's value.
     *
     * @param val the maximum value allowed
     */
void color_set_max_val (Color *self, gdouble val) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	_tmp0_ = val;
	_tmp1_ = val;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = v;
	_tmp9_ = val;
	_tmp10_ = MIN (_tmp8_, _tmp9_);
	v = _tmp10_;
	_tmp11_ = v;
	color_hsv_to_rgb (h, s, _tmp11_, &_tmp12_, &_tmp13_, &_tmp14_);
	(*self).R = _tmp12_;
	(*self).G = _tmp13_;
	(*self).B = _tmp14_;
}


/**
     * Multiplies the color's saturation using the amount.
     *
     * @param amount amount to multiply the saturation by
     */
void color_multiply_sat (Color *self, gdouble amount) {
	gdouble _tmp0_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	_tmp0_ = amount;
	g_return_if_fail (_tmp0_ >= ((gdouble) 0));
	_tmp1_ = (*self).R;
	_tmp2_ = (*self).G;
	_tmp3_ = (*self).B;
	color_rgb_to_hsv (_tmp1_, _tmp2_, _tmp3_, &_tmp4_, &_tmp5_, &_tmp6_);
	h = _tmp4_;
	s = _tmp5_;
	v = _tmp6_;
	_tmp7_ = s;
	_tmp8_ = amount;
	_tmp9_ = MIN ((gdouble) 1, _tmp7_ * _tmp8_);
	s = _tmp9_;
	_tmp10_ = s;
	color_hsv_to_rgb (h, _tmp10_, v, &_tmp11_, &_tmp12_, &_tmp13_);
	(*self).R = _tmp11_;
	(*self).G = _tmp12_;
	(*self).B = _tmp13_;
}


/**
     * Brighten the color's value using the value.
     *
     * @param amount percent of the value to brighten by
     */
void color_brighten_val (Color *self, gdouble amount) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	gdouble _tmp15_ = 0.0;
	_tmp0_ = amount;
	_tmp1_ = amount;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = v;
	_tmp9_ = v;
	_tmp10_ = amount;
	_tmp11_ = MIN ((gdouble) 1, _tmp8_ + ((1 - _tmp9_) * _tmp10_));
	v = _tmp11_;
	_tmp12_ = v;
	color_hsv_to_rgb (h, s, _tmp12_, &_tmp13_, &_tmp14_, &_tmp15_);
	(*self).R = _tmp13_;
	(*self).G = _tmp14_;
	(*self).B = _tmp15_;
}


/**
     * Darkens the color's value using the value.
     *
     * @param amount percent of the value to darken by
     */
void color_darken_val (Color *self, gdouble amount) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	gdouble _tmp15_ = 0.0;
	_tmp0_ = amount;
	_tmp1_ = amount;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = v;
	_tmp9_ = v;
	_tmp10_ = amount;
	_tmp11_ = MAX ((gdouble) 0, _tmp8_ - ((1 - _tmp9_) * _tmp10_));
	v = _tmp11_;
	_tmp12_ = v;
	color_hsv_to_rgb (h, s, _tmp12_, &_tmp13_, &_tmp14_, &_tmp15_);
	(*self).R = _tmp13_;
	(*self).G = _tmp14_;
	(*self).B = _tmp15_;
}


/**
     * Darkens the color's value using the saturtion.
     *
     * @param amount percent of the saturation to darken by
     */
void color_darken_by_sat (Color *self, gdouble amount) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble h = 0.0;
	gdouble s = 0.0;
	gdouble v = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	_tmp0_ = amount;
	_tmp1_ = amount;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = (*self).R;
	_tmp3_ = (*self).G;
	_tmp4_ = (*self).B;
	color_rgb_to_hsv (_tmp2_, _tmp3_, _tmp4_, &_tmp5_, &_tmp6_, &_tmp7_);
	h = _tmp5_;
	s = _tmp6_;
	v = _tmp7_;
	_tmp8_ = v;
	_tmp9_ = amount;
	_tmp10_ = MAX ((gdouble) 0, _tmp8_ - (_tmp9_ * s));
	v = _tmp10_;
	_tmp11_ = v;
	color_hsv_to_rgb (h, s, _tmp11_, &_tmp12_, &_tmp13_, &_tmp14_);
	(*self).R = _tmp12_;
	(*self).G = _tmp13_;
	(*self).B = _tmp14_;
}


static void color_rgb_to_hsv (gdouble r, gdouble g, gdouble b, gdouble* h, gdouble* s, gdouble* v) {
	gdouble _vala_h = 0.0;
	gdouble _vala_s = 0.0;
	gdouble _vala_v = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gdouble _tmp7_ = 0.0;
	gdouble _tmp8_ = 0.0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	gdouble _tmp13_ = 0.0;
	gdouble _tmp14_ = 0.0;
	gdouble _tmp15_ = 0.0;
	gdouble _tmp16_ = 0.0;
	gdouble _tmp17_ = 0.0;
	gdouble min = 0.0;
	gdouble _tmp18_ = 0.0;
	gdouble _tmp19_ = 0.0;
	gdouble _tmp20_ = 0.0;
	gdouble _tmp21_ = 0.0;
	gdouble _tmp22_ = 0.0;
	gdouble max = 0.0;
	gdouble _tmp23_ = 0.0;
	gdouble _tmp24_ = 0.0;
	gdouble _tmp25_ = 0.0;
	gdouble _tmp26_ = 0.0;
	gdouble _tmp27_ = 0.0;
	gdouble delta = 0.0;
	gdouble _tmp28_ = 0.0;
	gdouble _tmp29_ = 0.0;
	gdouble _tmp30_ = 0.0;
	gdouble _tmp31_ = 0.0;
	gdouble _tmp32_ = 0.0;
	gdouble _tmp33_ = 0.0;
	gdouble _tmp34_ = 0.0;
	gdouble _tmp35_ = 0.0;
	gdouble _tmp36_ = 0.0;
	gdouble _tmp37_ = 0.0;
	gdouble _tmp38_ = 0.0;
	gdouble _tmp39_ = 0.0;
	gdouble _tmp40_ = 0.0;
	gdouble _tmp41_ = 0.0;
	gdouble _tmp42_ = 0.0;
	_tmp0_ = r;
	_tmp1_ = r;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 1)));
	_tmp2_ = g;
	_tmp3_ = g;
	g_return_if_fail ((_tmp2_ >= ((gdouble) 0)) && (_tmp3_ <= ((gdouble) 1)));
	_tmp4_ = b;
	_tmp5_ = b;
	g_return_if_fail ((_tmp4_ >= ((gdouble) 0)) && (_tmp5_ <= ((gdouble) 1)));
	_tmp6_ = r;
	_tmp7_ = g;
	_tmp8_ = b;
	_tmp9_ = MAX (_tmp7_, _tmp8_);
	_tmp10_ = MAX (_tmp6_, _tmp9_);
	_vala_v = _tmp10_;
	_tmp11_ = _vala_v;
	if (_tmp11_ == ((gdouble) 0)) {
		_vala_h = (gdouble) 0;
		_vala_s = (gdouble) 0;
		if (h) {
			*h = _vala_h;
		}
		if (s) {
			*s = _vala_s;
		}
		if (v) {
			*v = _vala_v;
		}
		return;
	}
	_tmp12_ = r;
	_tmp13_ = _vala_v;
	r = _tmp12_ / _tmp13_;
	_tmp14_ = g;
	_tmp15_ = _vala_v;
	g = _tmp14_ / _tmp15_;
	_tmp16_ = b;
	_tmp17_ = _vala_v;
	b = _tmp16_ / _tmp17_;
	_tmp18_ = r;
	_tmp19_ = g;
	_tmp20_ = b;
	_tmp21_ = MIN (_tmp19_, _tmp20_);
	_tmp22_ = MIN (_tmp18_, _tmp21_);
	min = _tmp22_;
	_tmp23_ = r;
	_tmp24_ = g;
	_tmp25_ = b;
	_tmp26_ = MAX (_tmp24_, _tmp25_);
	_tmp27_ = MAX (_tmp23_, _tmp26_);
	max = _tmp27_;
	_tmp28_ = max;
	_tmp29_ = min;
	delta = _tmp28_ - _tmp29_;
	_tmp30_ = delta;
	_vala_s = _tmp30_;
	_tmp31_ = _vala_s;
	if (_tmp31_ == ((gdouble) 0)) {
		_vala_h = (gdouble) 0;
		if (h) {
			*h = _vala_h;
		}
		if (s) {
			*s = _vala_s;
		}
		if (v) {
			*v = _vala_v;
		}
		return;
	}
	_tmp32_ = r;
	_tmp33_ = min;
	_tmp34_ = delta;
	r = (_tmp32_ - _tmp33_) / _tmp34_;
	_tmp35_ = g;
	_tmp36_ = min;
	_tmp37_ = delta;
	g = (_tmp35_ - _tmp36_) / _tmp37_;
	_tmp38_ = b;
	_tmp39_ = min;
	_tmp40_ = delta;
	b = (_tmp38_ - _tmp39_) / _tmp40_;
	_tmp41_ = max;
	_tmp42_ = r;
	if (_tmp41_ == _tmp42_) {
		gdouble _tmp43_ = 0.0;
		gdouble _tmp44_ = 0.0;
		gdouble _tmp45_ = 0.0;
		_tmp43_ = g;
		_tmp44_ = b;
		_vala_h = 0 + (60 * (_tmp43_ - _tmp44_));
		_tmp45_ = _vala_h;
		if (_tmp45_ < ((gdouble) 0)) {
			gdouble _tmp46_ = 0.0;
			_tmp46_ = _vala_h;
			_vala_h = _tmp46_ + 360;
		}
	} else {
		gdouble _tmp47_ = 0.0;
		gdouble _tmp48_ = 0.0;
		_tmp47_ = max;
		_tmp48_ = g;
		if (_tmp47_ == _tmp48_) {
			gdouble _tmp49_ = 0.0;
			gdouble _tmp50_ = 0.0;
			_tmp49_ = b;
			_tmp50_ = r;
			_vala_h = 120 + (60 * (_tmp49_ - _tmp50_));
		} else {
			gdouble _tmp51_ = 0.0;
			gdouble _tmp52_ = 0.0;
			_tmp51_ = r;
			_tmp52_ = g;
			_vala_h = 240 + (60 * (_tmp51_ - _tmp52_));
		}
	}
	if (h) {
		*h = _vala_h;
	}
	if (s) {
		*s = _vala_s;
	}
	if (v) {
		*v = _vala_v;
	}
}


static void color_hsv_to_rgb (gdouble h, gdouble s, gdouble v, gdouble* r, gdouble* g, gdouble* b) {
	gdouble _vala_r = 0.0;
	gdouble _vala_g = 0.0;
	gdouble _vala_b = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	_tmp0_ = h;
	_tmp1_ = h;
	g_return_if_fail ((_tmp0_ >= ((gdouble) 0)) && (_tmp1_ <= ((gdouble) 360)));
	_tmp2_ = s;
	_tmp3_ = s;
	g_return_if_fail ((_tmp2_ >= ((gdouble) 0)) && (_tmp3_ <= ((gdouble) 1)));
	_tmp4_ = v;
	_tmp5_ = v;
	g_return_if_fail ((_tmp4_ >= ((gdouble) 0)) && (_tmp5_ <= ((gdouble) 1)));
	_vala_r = (gdouble) 0;
	_vala_g = (gdouble) 0;
	_vala_b = (gdouble) 0;
	_tmp6_ = s;
	if (_tmp6_ == ((gdouble) 0)) {
		gdouble _tmp7_ = 0.0;
		gdouble _tmp8_ = 0.0;
		gdouble _tmp9_ = 0.0;
		_tmp7_ = v;
		_vala_r = _tmp7_;
		_tmp8_ = v;
		_vala_g = _tmp8_;
		_tmp9_ = v;
		_vala_b = _tmp9_;
	} else {
		gint secNum = 0;
		gdouble _tmp10_ = 0.0;
		gdouble _tmp11_ = 0.0;
		gdouble fracSec = 0.0;
		gdouble _tmp12_ = 0.0;
		gint _tmp13_ = 0;
		gdouble p = 0.0;
		gdouble _tmp14_ = 0.0;
		gdouble _tmp15_ = 0.0;
		gdouble q = 0.0;
		gdouble _tmp16_ = 0.0;
		gdouble _tmp17_ = 0.0;
		gdouble _tmp18_ = 0.0;
		gdouble t = 0.0;
		gdouble _tmp19_ = 0.0;
		gdouble _tmp20_ = 0.0;
		gdouble _tmp21_ = 0.0;
		gint _tmp22_ = 0;
		_tmp10_ = h;
		_tmp11_ = floor (_tmp10_ / 60);
		secNum = (gint) _tmp11_;
		_tmp12_ = h;
		_tmp13_ = secNum;
		fracSec = (_tmp12_ / 60.0) - _tmp13_;
		_tmp14_ = v;
		_tmp15_ = s;
		p = _tmp14_ * (1 - _tmp15_);
		_tmp16_ = v;
		_tmp17_ = s;
		_tmp18_ = fracSec;
		q = _tmp16_ * (1 - (_tmp17_ * _tmp18_));
		_tmp19_ = v;
		_tmp20_ = s;
		_tmp21_ = fracSec;
		t = _tmp19_ * (1 - (_tmp20_ * (1 - _tmp21_)));
		_tmp22_ = secNum;
		switch (_tmp22_) {
			case 0:
			{
				gdouble _tmp23_ = 0.0;
				gdouble _tmp24_ = 0.0;
				gdouble _tmp25_ = 0.0;
				_tmp23_ = v;
				_vala_r = _tmp23_;
				_tmp24_ = t;
				_vala_g = _tmp24_;
				_tmp25_ = p;
				_vala_b = _tmp25_;
				break;
			}
			case 1:
			{
				gdouble _tmp26_ = 0.0;
				gdouble _tmp27_ = 0.0;
				gdouble _tmp28_ = 0.0;
				_tmp26_ = q;
				_vala_r = _tmp26_;
				_tmp27_ = v;
				_vala_g = _tmp27_;
				_tmp28_ = p;
				_vala_b = _tmp28_;
				break;
			}
			case 2:
			{
				gdouble _tmp29_ = 0.0;
				gdouble _tmp30_ = 0.0;
				gdouble _tmp31_ = 0.0;
				_tmp29_ = p;
				_vala_r = _tmp29_;
				_tmp30_ = v;
				_vala_g = _tmp30_;
				_tmp31_ = t;
				_vala_b = _tmp31_;
				break;
			}
			case 3:
			{
				gdouble _tmp32_ = 0.0;
				gdouble _tmp33_ = 0.0;
				gdouble _tmp34_ = 0.0;
				_tmp32_ = p;
				_vala_r = _tmp32_;
				_tmp33_ = q;
				_vala_g = _tmp33_;
				_tmp34_ = v;
				_vala_b = _tmp34_;
				break;
			}
			case 4:
			{
				gdouble _tmp35_ = 0.0;
				gdouble _tmp36_ = 0.0;
				gdouble _tmp37_ = 0.0;
				_tmp35_ = t;
				_vala_r = _tmp35_;
				_tmp36_ = p;
				_vala_g = _tmp36_;
				_tmp37_ = v;
				_vala_b = _tmp37_;
				break;
			}
			case 5:
			{
				gdouble _tmp38_ = 0.0;
				gdouble _tmp39_ = 0.0;
				gdouble _tmp40_ = 0.0;
				_tmp38_ = v;
				_vala_r = _tmp38_;
				_tmp39_ = p;
				_vala_g = _tmp39_;
				_tmp40_ = q;
				_vala_b = _tmp40_;
				break;
			}
			default:
			break;
		}
	}
	if (r) {
		*r = _vala_r;
	}
	if (g) {
		*g = _vala_g;
	}
	if (b) {
		*b = _vala_b;
	}
}


/**
     * Convert color to string formatted like "%d;;%d;;%d;;%d"
     * with numeric entries ranged in 0..255
     *
     * @return the string representation of this color
     */
gchar* color_to_string (Color *self) {
	gchar* result = NULL;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gchar* _tmp4_ = NULL;
	_tmp0_ = (*self).R;
	_tmp1_ = (*self).G;
	_tmp2_ = (*self).B;
	_tmp3_ = (*self).A;
	_tmp4_ = g_strdup_printf ("%d;;%d;;%d;;%d", (gint) (_tmp0_ * G_MAXUINT8), (gint) (_tmp1_ * G_MAXUINT8), (gint) (_tmp2_ * G_MAXUINT8), (gint) (_tmp3_ * G_MAXUINT8));
	result = _tmp4_;
	return result;
}


/**
     * Create new color converted from string formatted like
     * "%d;;%d;;%d;;%d" with numeric entries ranged in 0..255
     *
     * @return new {@link Color} based on the given string
     */
void color_from_string (const gchar* s, Color* result) {
	gchar** parts = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint parts_length1 = 0;
	gint _parts_size_ = 0;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gchar** _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	const gchar* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gdouble _tmp9_ = 0.0;
	gdouble _tmp10_ = 0.0;
	gchar** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	const gchar* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	gdouble _tmp14_ = 0.0;
	gdouble _tmp15_ = 0.0;
	gchar** _tmp16_ = NULL;
	gint _tmp16__length1 = 0;
	const gchar* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	gdouble _tmp19_ = 0.0;
	gdouble _tmp20_ = 0.0;
	gchar** _tmp21_ = NULL;
	gint _tmp21__length1 = 0;
	const gchar* _tmp22_ = NULL;
	gint _tmp23_ = 0;
	gdouble _tmp24_ = 0.0;
	gdouble _tmp25_ = 0.0;
	Color _tmp26_ = {0};
	g_return_if_fail (s != NULL);
	_tmp0_ = s;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ";;", 0);
	parts = _tmp2_;
	parts_length1 = _vala_array_length (_tmp1_);
	_parts_size_ = parts_length1;
	_tmp3_ = parts;
	_tmp3__length1 = parts_length1;
	if (_tmp3__length1 != 4) {
		const gchar* _tmp4_ = NULL;
		Color _tmp5_ = {0};
		_tmp4_ = s;
		g_critical ("Color.vala:427: Malformed color string '%s'", _tmp4_);
		_tmp5_.R = (gdouble) 0;
		*result = _tmp5_;
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		return;
	}
	_tmp6_ = parts;
	_tmp6__length1 = parts_length1;
	_tmp7_ = _tmp6_[0];
	_tmp8_ = atoi (_tmp7_);
	_tmp9_ = MAX ((gdouble) 0, (gdouble) _tmp8_);
	_tmp10_ = MIN ((gdouble) G_MAXUINT8, _tmp9_);
	_tmp11_ = parts;
	_tmp11__length1 = parts_length1;
	_tmp12_ = _tmp11_[1];
	_tmp13_ = atoi (_tmp12_);
	_tmp14_ = MAX ((gdouble) 0, (gdouble) _tmp13_);
	_tmp15_ = MIN ((gdouble) G_MAXUINT8, _tmp14_);
	_tmp16_ = parts;
	_tmp16__length1 = parts_length1;
	_tmp17_ = _tmp16_[2];
	_tmp18_ = atoi (_tmp17_);
	_tmp19_ = MAX ((gdouble) 0, (gdouble) _tmp18_);
	_tmp20_ = MIN ((gdouble) G_MAXUINT8, _tmp19_);
	_tmp21_ = parts;
	_tmp21__length1 = parts_length1;
	_tmp22_ = _tmp21_[3];
	_tmp23_ = atoi (_tmp22_);
	_tmp24_ = MAX ((gdouble) 0, (gdouble) _tmp23_);
	_tmp25_ = MIN ((gdouble) G_MAXUINT8, _tmp24_);
	_tmp26_.R = _tmp10_ / G_MAXUINT8;
	_tmp26_.G = _tmp15_ / G_MAXUINT8;
	_tmp26_.B = _tmp20_ / G_MAXUINT8;
	_tmp26_.A = _tmp25_ / G_MAXUINT8;
	*result = _tmp26_;
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return;
}


Color* color_dup (const Color* self) {
	Color* dup;
	dup = g_new0 (Color, 1);
	memcpy (dup, self, sizeof (Color));
	return dup;
}


void color_free (Color* self) {
	g_free (self);
}


GType color_get_type (void) {
	static volatile gsize color_type_id__volatile = 0;
	if (g_once_init_enter (&color_type_id__volatile)) {
		GType color_type_id;
		color_type_id = g_boxed_type_register_static ("Color", (GBoxedCopyFunc) color_dup, (GBoxedFreeFunc) color_free);
		g_once_init_leave (&color_type_id__volatile, color_type_id);
	}
	return color_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



