/* Utils.c generated by valac 0.26.1, the Vala compiler
 * generated from Utils.vala, do not modify */

/* Utils.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gio/gio.h>
#include <pango/pango.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define FONT_MANAGER_TYPE_DRAG_TARGET_TYPE (font_manager_drag_target_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define FONT_MANAGER_TYPE_MAIN (font_manager_main_get_type ())
#define FONT_MANAGER_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_MAIN, FontManagerMain))
#define FONT_MANAGER_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_MAIN, FontManagerMainClass))
#define FONT_MANAGER_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_MAIN))
#define FONT_MANAGER_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_MAIN))
#define FONT_MANAGER_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_MAIN, FontManagerMainClass))

typedef struct _FontManagerMain FontManagerMain;
typedef struct _FontManagerMainClass FontManagerMainClass;

#define FONT_MANAGER_TYPE_APPLICATION (font_manager_application_get_type ())
#define FONT_MANAGER_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplication))
#define FONT_MANAGER_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplicationClass))
#define FONT_MANAGER_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_APPLICATION))
#define FONT_MANAGER_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_APPLICATION))
#define FONT_MANAGER_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplicationClass))

typedef struct _FontManagerApplication FontManagerApplication;
typedef struct _FontManagerApplicationClass FontManagerApplicationClass;

#define FONT_MANAGER_TYPE_MAIN_WINDOW (font_manager_main_window_get_type ())
#define FONT_MANAGER_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindow))
#define FONT_MANAGER_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindowClass))
#define FONT_MANAGER_IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW))
#define FONT_MANAGER_IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_MAIN_WINDOW))
#define FONT_MANAGER_MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindowClass))

typedef struct _FontManagerMainWindow FontManagerMainWindow;
typedef struct _FontManagerMainWindowClass FontManagerMainWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __vala_PangoFontDescription_free0(var) ((var == NULL) ? NULL : (var = (_vala_PangoFontDescription_free (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define TYPE_COLOR (color_get_type ())
typedef struct _Color Color;

typedef enum  {
	FONT_MANAGER_DRAG_TARGET_TYPE_FAMILY,
	FONT_MANAGER_DRAG_TARGET_TYPE_COLLECTION,
	FONT_MANAGER_DRAG_TARGET_TYPE_EXTERNAL
} FontManagerDragTargetType;

struct _Color {
	gdouble R;
	gdouble G;
	gdouble B;
	gdouble A;
};



GType font_manager_drag_target_type_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_AppDragActions GDK_ACTION_COPY
void font_manager_show_help_dialog (void);
#define FONT_MANAGER_NAME "font-manager"
void font_manager_show_error_message (const gchar* message, GError* e, GtkWindow* parent);
GType font_manager_main_get_type (void) G_GNUC_CONST;
FontManagerMain* font_manager_main_get_instance (void);
GType font_manager_application_get_type (void) G_GNUC_CONST;
guint font_manager_application_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
FontManagerApplication* font_manager_main_get_application (FontManagerMain* self);
GType font_manager_main_window_get_type (void) G_GNUC_CONST;
FontManagerMainWindow* font_manager_application_get_main_window (FontManagerApplication* self);
void font_manager_set_g_app_menu (GtkApplication* app, GtkBuilder* builder);
void font_manager_set_application_style (void);
PangoFontDescription* get_font (GtkWidget* widget, GtkStateFlags flags);
static void _vala_PangoFontDescription_free (PangoFontDescription* self);
gboolean Gnome3 (void);
void ensure_ui_update (void);
gboolean is_left_to_right (GtkWidget* widget);
GtkSeparator* add_separator (GtkBox* box, GtkOrientation orientation, GtkPackType pack_type);
void set_default_button_relief (GtkContainer* container);
void cr_set_source_rgba (cairo_t* cr, GdkRGBA* color, gdouble* alpha);
void darker (GdkRGBA* rgba, gdouble factor, GdkRGBA* result);
GType color_get_type (void) G_GNUC_CONST;
Color* color_dup (const Color* self);
void color_free (Color* self);
void color_from_gdk_rgba (GdkRGBA* color, Color* result);
void color_darken_by_sat (Color *self, gdouble amount);
void color_to_gdk_rgba (Color *self, GdkRGBA* result);
gboolean color_is_light (Color* color);

const GtkTargetEntry FONT_MANAGER_AppDragTargets[2] = {{"font-family", (guint) GTK_TARGET_SAME_APP, (guint) FONT_MANAGER_DRAG_TARGET_TYPE_FAMILY}, {"text/uri-list", (guint) 0, (guint) FONT_MANAGER_DRAG_TARGET_TYPE_EXTERNAL}};

GType font_manager_drag_target_type_get_type (void) {
	static volatile gsize font_manager_drag_target_type_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_drag_target_type_type_id__volatile)) {
		static const GEnumValue values[] = {{FONT_MANAGER_DRAG_TARGET_TYPE_FAMILY, "FONT_MANAGER_DRAG_TARGET_TYPE_FAMILY", "family"}, {FONT_MANAGER_DRAG_TARGET_TYPE_COLLECTION, "FONT_MANAGER_DRAG_TARGET_TYPE_COLLECTION", "collection"}, {FONT_MANAGER_DRAG_TARGET_TYPE_EXTERNAL, "FONT_MANAGER_DRAG_TARGET_TYPE_EXTERNAL", "external"}, {0, NULL, NULL}};
		GType font_manager_drag_target_type_type_id;
		font_manager_drag_target_type_type_id = g_enum_register_static ("FontManagerDragTargetType", values);
		g_once_init_leave (&font_manager_drag_target_type_type_id__volatile, font_manager_drag_target_type_type_id);
	}
	return font_manager_drag_target_type_type_id__volatile;
}


void font_manager_show_help_dialog (void) {
	GError * _inner_error_ = NULL;
	{
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		_tmp0_ = g_strdup_printf ("help:%s", FONT_MANAGER_NAME);
		_tmp1_ = _tmp0_;
		gtk_show_uri (NULL, _tmp1_, (guint32) GDK_CURRENT_TIME, &_inner_error_);
		_g_free0 (_tmp1_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch46_g_error;
		}
	}
	goto __finally46;
	__catch46_g_error:
	{
		GError* e = NULL;
		GError* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		GError* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_critical ("Utils.vala:43: Error launching uri handler : %s", _tmp3_);
		_tmp4_ = _ ("There was an error displaying help contents");
		_tmp5_ = e;
		font_manager_show_error_message (_tmp4_, _tmp5_, NULL);
		_g_error_free0 (e);
	}
	__finally46:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	return;
}


void font_manager_show_error_message (const gchar* message, GError* e, GtkWindow* parent) {
	gboolean _tmp0_ = FALSE;
	GtkWindow* _tmp1_ = NULL;
	GtkMessageDialog* dialog = NULL;
	GtkWindow* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	GError* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	GtkMessageDialog* _tmp18_ = NULL;
	GtkMessageDialog* _tmp19_ = NULL;
	g_return_if_fail (message != NULL);
	_tmp1_ = parent;
	if (_tmp1_ == NULL) {
		FontManagerMain* _tmp2_ = NULL;
		FontManagerMain* _tmp3_ = NULL;
		FontManagerApplication* _tmp4_ = NULL;
		FontManagerApplication* _tmp5_ = NULL;
		_tmp2_ = font_manager_main_get_instance ();
		_tmp3_ = _tmp2_;
		_tmp4_ = font_manager_main_get_application (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp0_ = _tmp5_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		FontManagerMain* _tmp6_ = NULL;
		FontManagerMain* _tmp7_ = NULL;
		FontManagerApplication* _tmp8_ = NULL;
		FontManagerApplication* _tmp9_ = NULL;
		FontManagerMainWindow* _tmp10_ = NULL;
		FontManagerMainWindow* _tmp11_ = NULL;
		_tmp6_ = font_manager_main_get_instance ();
		_tmp7_ = _tmp6_;
		_tmp8_ = font_manager_main_get_application (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = font_manager_application_get_main_window (_tmp9_);
		_tmp11_ = _tmp10_;
		parent = (GtkWindow*) _tmp11_;
	}
	_tmp12_ = parent;
	_tmp13_ = message;
	_tmp14_ = e;
	_tmp15_ = _tmp14_->message;
	_tmp16_ = g_strdup_printf ("<b>%s</b>\n\n%s", _tmp13_, _tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = (GtkMessageDialog*) gtk_message_dialog_new (_tmp12_, GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_OK, _tmp17_);
	g_object_ref_sink (_tmp18_);
	_tmp19_ = _tmp18_;
	_g_free0 (_tmp17_);
	dialog = _tmp19_;
	g_object_set (dialog, "use-markup", TRUE, NULL);
	gtk_dialog_run ((GtkDialog*) dialog);
	gtk_widget_destroy ((GtkWidget*) dialog);
	_g_object_unref0 (dialog);
	return;
}


void font_manager_set_g_app_menu (GtkApplication* app, GtkBuilder* builder) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (app != NULL);
	g_return_if_fail (builder != NULL);
	{
		GtkBuilder* _tmp0_ = NULL;
		GtkApplication* _tmp1_ = NULL;
		GtkBuilder* _tmp2_ = NULL;
		GObject* _tmp3_ = NULL;
		_tmp0_ = builder;
		gtk_builder_add_from_resource (_tmp0_, "/org/gnome/FontManager/ApplicationMenu.ui", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch47_g_error;
		}
		_tmp1_ = app;
		_tmp2_ = builder;
		_tmp3_ = gtk_builder_get_object (_tmp2_, "ApplicationMenu");
		gtk_application_set_app_menu (_tmp1_, G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, g_menu_model_get_type ()) ? ((GMenuModel*) _tmp3_) : NULL);
	}
	goto __finally47;
	__catch47_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("Utils.vala:70: Failed to set application menu : %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally47:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	return;
}


void font_manager_set_application_style (void) {
	GtkIconTheme* _tmp0_ = NULL;
	gchar* css_uri = NULL;
	gchar* _tmp1_ = NULL;
	GFile* css_file = NULL;
	GFile* _tmp2_ = NULL;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp3_ = NULL;
	GdkScreen* _tmp6_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = gtk_icon_theme_get_default ();
	gtk_icon_theme_add_resource_path (_tmp0_, "/org/gnome/FontManager/icons");
	_tmp1_ = g_strdup ("resource:///org/gnome/FontManager/FontManager.css");
	css_uri = _tmp1_;
	_tmp2_ = g_file_new_for_uri (css_uri);
	css_file = _tmp2_;
	_tmp3_ = gtk_css_provider_new ();
	provider = _tmp3_;
	{
		gtk_css_provider_load_from_file (provider, css_file, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch48_g_error;
		}
	}
	goto __finally48;
	__catch48_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("Utils.vala:85: Failed to load Css Provider! Application will not appea" \
"r as expected.");
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("Utils.vala:86: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally48:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (provider);
		_g_object_unref0 (css_file);
		_g_free0 (css_uri);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp6_ = gdk_screen_get_default ();
	gtk_style_context_add_provider_for_screen (_tmp6_, (GtkStyleProvider*) provider, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_g_object_unref0 (provider);
	_g_object_unref0 (css_file);
	_g_free0 (css_uri);
	return;
}


static void _vala_PangoFontDescription_free (PangoFontDescription* self) {
	g_boxed_free (pango_font_description_get_type (), self);
}


PangoFontDescription* get_font (GtkWidget* widget, GtkStateFlags flags) {
	PangoFontDescription* result = NULL;
	PangoFontDescription* desc = NULL;
	GtkWidget* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStateFlags _tmp2_ = 0;
	PangoFontDescription* _tmp3_ = NULL;
	g_return_val_if_fail (widget != NULL, NULL);
	_tmp0_ = widget;
	_tmp1_ = gtk_widget_get_style_context (_tmp0_);
	_tmp2_ = flags;
	gtk_style_context_get (_tmp1_, _tmp2_, "font", &desc, NULL, NULL);
	_tmp3_ = pango_font_description_copy (desc);
	result = _tmp3_;
	__vala_PangoFontDescription_free0 (desc);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gboolean Gnome3 (void) {
	gboolean result = FALSE;
	GtkSettings* settings = NULL;
	GtkSettings* _tmp0_ = NULL;
	GtkSettings* _tmp1_ = NULL;
	gboolean has_app_menu = FALSE;
	GtkSettings* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean has_menubar = FALSE;
	GtkSettings* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	_tmp0_ = gtk_settings_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	settings = _tmp1_;
	_tmp2_ = settings;
	g_object_get (_tmp2_, "gtk-shell-shows-app-menu", &_tmp3_, NULL);
	_tmp4_ = _tmp3_;
	has_app_menu = _tmp4_;
	_tmp5_ = settings;
	g_object_get (_tmp5_, "gtk-shell-shows-menubar", &_tmp6_, NULL);
	_tmp7_ = _tmp6_;
	has_menubar = _tmp7_;
	_tmp9_ = has_app_menu;
	if (_tmp9_) {
		gboolean _tmp10_ = FALSE;
		_tmp10_ = has_menubar;
		_tmp8_ = !_tmp10_;
	} else {
		_tmp8_ = FALSE;
	}
	result = _tmp8_;
	_g_object_unref0 (settings);
	return result;
}


void ensure_ui_update (void) {
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		_tmp0_ = gtk_events_pending ();
		if (!_tmp0_) {
			break;
		}
		gtk_main_iteration ();
	}
	return;
}


gboolean is_left_to_right (GtkWidget* widget) {
	gboolean result = FALSE;
	GtkStyleContext* context = NULL;
	GtkWidget* _tmp0_ = NULL;
	GtkStyleContext* _tmp1_ = NULL;
	GtkStyleContext* _tmp2_ = NULL;
	GtkStateFlags state = 0;
	GtkStyleContext* _tmp3_ = NULL;
	GtkStateFlags _tmp4_ = 0;
	GtkStateFlags _tmp5_ = 0;
	g_return_val_if_fail (widget != NULL, FALSE);
	_tmp0_ = widget;
	_tmp1_ = gtk_widget_get_style_context (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	context = _tmp2_;
	_tmp3_ = context;
	_tmp4_ = gtk_style_context_get_state (_tmp3_);
	state = _tmp4_;
	_tmp5_ = state;
	if ((_tmp5_ & GTK_STATE_FLAG_DIR_LTR) != 0) {
		result = TRUE;
		_g_object_unref0 (context);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (context);
	return result;
}


GtkSeparator* add_separator (GtkBox* box, GtkOrientation orientation, GtkPackType pack_type) {
	GtkSeparator* result = NULL;
	GtkSeparator* separator = NULL;
	GtkOrientation _tmp0_ = 0;
	GtkSeparator* _tmp1_ = NULL;
	GtkOrientation _tmp2_ = 0;
	GtkPackType _tmp5_ = 0;
	GtkSeparator* _tmp10_ = NULL;
	g_return_val_if_fail (box != NULL, NULL);
	_tmp0_ = orientation;
	_tmp1_ = (GtkSeparator*) gtk_separator_new (_tmp0_);
	g_object_ref_sink (_tmp1_);
	separator = _tmp1_;
	_tmp2_ = orientation;
	switch (_tmp2_) {
		case GTK_ORIENTATION_HORIZONTAL:
		{
			GtkSeparator* _tmp3_ = NULL;
			_tmp3_ = separator;
			gtk_widget_set_size_request ((GtkWidget*) _tmp3_, -1, 1);
			break;
		}
		default:
		{
			GtkSeparator* _tmp4_ = NULL;
			_tmp4_ = separator;
			gtk_widget_set_size_request ((GtkWidget*) _tmp4_, 1, -1);
			break;
		}
	}
	_tmp5_ = pack_type;
	switch (_tmp5_) {
		case GTK_PACK_END:
		{
			GtkBox* _tmp6_ = NULL;
			GtkSeparator* _tmp7_ = NULL;
			_tmp6_ = box;
			_tmp7_ = separator;
			gtk_box_pack_end (_tmp6_, (GtkWidget*) _tmp7_, FALSE, TRUE, (guint) 0);
			break;
		}
		default:
		{
			GtkBox* _tmp8_ = NULL;
			GtkSeparator* _tmp9_ = NULL;
			_tmp8_ = box;
			_tmp9_ = separator;
			gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, FALSE, TRUE, (guint) 0);
			break;
		}
	}
	_tmp10_ = separator;
	gtk_widget_show ((GtkWidget*) _tmp10_);
	result = separator;
	return result;
}


void set_default_button_relief (GtkContainer* container) {
	GtkContainer* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	g_return_if_fail (container != NULL);
	_tmp0_ = container;
	_tmp1_ = gtk_container_get_children (_tmp0_);
	{
		GList* widget_collection = NULL;
		GList* widget_it = NULL;
		widget_collection = _tmp1_;
		for (widget_it = widget_collection; widget_it != NULL; widget_it = widget_it->next) {
			GtkWidget* _tmp2_ = NULL;
			GtkWidget* widget = NULL;
			_tmp2_ = _g_object_ref0 ((GtkWidget*) widget_it->data);
			widget = _tmp2_;
			{
				GtkWidget* _tmp3_ = NULL;
				_tmp3_ = widget;
				if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, gtk_button_get_type ())) {
					GtkWidget* _tmp4_ = NULL;
					_tmp4_ = widget;
					gtk_button_set_relief (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, gtk_button_get_type (), GtkButton), GTK_RELIEF_NONE);
				}
				_g_object_unref0 (widget);
			}
		}
		_g_list_free0 (widget_collection);
	}
	return;
}


void cr_set_source_rgba (cairo_t* cr, GdkRGBA* color, gdouble* alpha) {
	gdouble* _tmp0_ = NULL;
	g_return_if_fail (cr != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = alpha;
	if (_tmp0_ == NULL) {
		cairo_t* _tmp1_ = NULL;
		GdkRGBA _tmp2_ = {0};
		gdouble _tmp3_ = 0.0;
		GdkRGBA _tmp4_ = {0};
		gdouble _tmp5_ = 0.0;
		GdkRGBA _tmp6_ = {0};
		gdouble _tmp7_ = 0.0;
		GdkRGBA _tmp8_ = {0};
		gdouble _tmp9_ = 0.0;
		_tmp1_ = cr;
		_tmp2_ = *color;
		_tmp3_ = _tmp2_.red;
		_tmp4_ = *color;
		_tmp5_ = _tmp4_.green;
		_tmp6_ = *color;
		_tmp7_ = _tmp6_.blue;
		_tmp8_ = *color;
		_tmp9_ = _tmp8_.alpha;
		cairo_set_source_rgba (_tmp1_, _tmp3_, _tmp5_, _tmp7_, _tmp9_);
	} else {
		cairo_t* _tmp10_ = NULL;
		GdkRGBA _tmp11_ = {0};
		gdouble _tmp12_ = 0.0;
		GdkRGBA _tmp13_ = {0};
		gdouble _tmp14_ = 0.0;
		GdkRGBA _tmp15_ = {0};
		gdouble _tmp16_ = 0.0;
		gdouble* _tmp17_ = NULL;
		_tmp10_ = cr;
		_tmp11_ = *color;
		_tmp12_ = _tmp11_.red;
		_tmp13_ = *color;
		_tmp14_ = _tmp13_.green;
		_tmp15_ = *color;
		_tmp16_ = _tmp15_.blue;
		_tmp17_ = alpha;
		cairo_set_source_rgba (_tmp10_, _tmp12_, _tmp14_, _tmp16_, *_tmp17_);
	}
	return;
}


void darker (GdkRGBA* rgba, gdouble factor, GdkRGBA* result) {
	Color color = {0};
	GdkRGBA _tmp0_ = {0};
	Color _tmp1_ = {0};
	gdouble _tmp2_ = 0.0;
	GdkRGBA _tmp3_ = {0};
	g_return_if_fail (rgba != NULL);
	_tmp0_ = *rgba;
	color_from_gdk_rgba (&_tmp0_, &_tmp1_);
	color = _tmp1_;
	_tmp2_ = factor;
	color_darken_by_sat (&color, _tmp2_);
	color_to_gdk_rgba (&color, &_tmp3_);
	*result = _tmp3_;
	return;
}


gboolean color_is_light (Color* color) {
	gboolean result = FALSE;
	gdouble Pr = 0.0;
	Color _tmp0_ = {0};
	gdouble _tmp1_ = 0.0;
	Color _tmp2_ = {0};
	gdouble _tmp3_ = 0.0;
	gdouble Pg = 0.0;
	Color _tmp4_ = {0};
	gdouble _tmp5_ = 0.0;
	Color _tmp6_ = {0};
	gdouble _tmp7_ = 0.0;
	gdouble Pb = 0.0;
	Color _tmp8_ = {0};
	gdouble _tmp9_ = 0.0;
	Color _tmp10_ = {0};
	gdouble _tmp11_ = 0.0;
	gdouble _tmp12_ = 0.0;
	g_return_val_if_fail (color != NULL, FALSE);
	_tmp0_ = *color;
	_tmp1_ = _tmp0_.R;
	_tmp2_ = *color;
	_tmp3_ = _tmp2_.R;
	Pr = (_tmp1_ * _tmp3_) * 0.2126;
	_tmp4_ = *color;
	_tmp5_ = _tmp4_.G;
	_tmp6_ = *color;
	_tmp7_ = _tmp6_.G;
	Pg = (_tmp5_ * _tmp7_) * 0.7152;
	_tmp8_ = *color;
	_tmp9_ = _tmp8_.B;
	_tmp10_ = *color;
	_tmp11_ = _tmp10_.B;
	Pb = (_tmp9_ * _tmp11_) * 0.0722;
	_tmp12_ = sqrt ((Pr + Pg) + Pb);
	result = _tmp12_ > 127.5;
	return result;
}



