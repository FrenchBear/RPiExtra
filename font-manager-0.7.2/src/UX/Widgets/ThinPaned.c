/* ThinPaned.c generated by valac 0.26.1, the Vala compiler
 * generated from ThinPaned.vala, do not modify */

/* From libgranite, modified namespace, css application */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_THIN_PANED (thin_paned_get_type ())
#define THIN_PANED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_THIN_PANED, ThinPaned))
#define THIN_PANED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_THIN_PANED, ThinPanedClass))
#define IS_THIN_PANED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_THIN_PANED))
#define IS_THIN_PANED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_THIN_PANED))
#define THIN_PANED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_THIN_PANED, ThinPanedClass))

typedef struct _ThinPaned ThinPaned;
typedef struct _ThinPanedClass ThinPanedClass;
typedef struct _ThinPanedPrivate ThinPanedPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))

struct _ThinPaned {
	GtkPaned parent_instance;
	ThinPanedPrivate * priv;
};

struct _ThinPanedClass {
	GtkPanedClass parent_class;
};

struct _ThinPanedPrivate {
	GdkWindow* overlay_handle;
	gboolean in_resize;
};


static gpointer thin_paned_parent_class = NULL;

GType thin_paned_get_type (void) G_GNUC_CONST;
#define THIN_PANED_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_THIN_PANED, ThinPanedPrivate))
enum  {
	THIN_PANED_DUMMY_PROPERTY
};
#define THIN_PANED_STYLE_PROP_OVERLAY_HANDLE_SIZE "overlay-handle-size"
ThinPaned* thin_paned_new (GtkOrientation orientation);
ThinPaned* thin_paned_construct (GType object_type, GtkOrientation orientation);
GdkWindow* thin_paned_get_overlay_handle_window (ThinPaned* self);
static void thin_paned_real_realize (GtkWidget* base);
static void thin_paned_update_overlay_handle (ThinPaned* self);
static void thin_paned_real_unrealize (GtkWidget* base);
static void thin_paned_real_map (GtkWidget* base);
static void thin_paned_real_unmap (GtkWidget* base);
static gboolean thin_paned_real_draw (GtkWidget* base, cairo_t* ctx);
static void thin_paned_real_size_allocate (GtkWidget* base, GtkAllocation* allocation);
static void thin_paned_real_state_flags_changed (GtkWidget* base, GtkStateFlags previous_state);
static gboolean thin_paned_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event);
gboolean is_left_to_right (GtkWidget* widget);
static gboolean thin_paned_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static gboolean thin_paned_real_button_release_event (GtkWidget* base, GdkEventButton* event);
static gboolean thin_paned_real_grab_broken_event (GtkWidget* base, GdkEventGrabBroken* event);
static void thin_paned_finalize (GObject* obj);


ThinPaned* thin_paned_construct (GType object_type, GtkOrientation orientation) {
	ThinPaned * self = NULL;
	GtkOrientation _tmp0_ = 0;
	self = (ThinPaned*) g_object_new (object_type, NULL);
	_tmp0_ = orientation;
	gtk_orientable_set_orientation ((GtkOrientable*) self, _tmp0_);
	return self;
}


ThinPaned* thin_paned_new (GtkOrientation orientation) {
	return thin_paned_construct (TYPE_THIN_PANED, orientation);
}


GdkWindow* thin_paned_get_overlay_handle_window (ThinPaned* self) {
	GdkWindow* result = NULL;
	GdkWindow* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->overlay_handle;
	result = _tmp0_;
	return result;
}


static void thin_paned_real_realize (GtkWidget* base) {
	ThinPaned * self;
	GdkWindowAttr attributes = {0};
	GdkWindowAttributesType attributes_mask = 0;
	GdkWindow* _tmp0_ = NULL;
	GdkWindowAttr _tmp1_ = {0};
	GdkWindow* _tmp2_ = NULL;
	GdkWindow* _tmp3_ = NULL;
	self = (ThinPaned*) base;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->realize ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned));
	memset (&attributes, 0, sizeof (GdkWindowAttr));
	attributes.window_type = GDK_WINDOW_CHILD;
	attributes.x = 0;
	attributes.y = 0;
	attributes.width = 0;
	attributes.height = 0;
	attributes.wclass = GDK_INPUT_ONLY;
	attributes.event_mask = (gint) (((((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_ENTER_NOTIFY_MASK) | GDK_LEAVE_NOTIFY_MASK) | GDK_POINTER_MOTION_MASK) | GDK_POINTER_MOTION_HINT_MASK);
	attributes_mask = (GDK_WA_X | GDK_WA_Y) | GDK_WA_CURSOR;
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = attributes;
	_tmp2_ = gdk_window_new (_tmp0_, &_tmp1_, attributes_mask);
	_g_object_unref0 (self->priv->overlay_handle);
	self->priv->overlay_handle = _tmp2_;
	_tmp3_ = self->priv->overlay_handle;
	gdk_window_set_user_data (_tmp3_, (GObject*) self);
	thin_paned_update_overlay_handle (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void thin_paned_real_unrealize (GtkWidget* base) {
	ThinPaned * self;
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	self = (ThinPaned*) base;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->unrealize ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned));
	_tmp0_ = self->priv->overlay_handle;
	gdk_window_set_user_data (_tmp0_, NULL);
	_tmp1_ = self->priv->overlay_handle;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	gdk_window_destroy (_tmp2_);
	_g_object_unref0 (self->priv->overlay_handle);
	self->priv->overlay_handle = NULL;
}


static void thin_paned_real_map (GtkWidget* base) {
	ThinPaned * self;
	GdkWindow* _tmp0_ = NULL;
	self = (ThinPaned*) base;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->map ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned));
	_tmp0_ = self->priv->overlay_handle;
	gdk_window_show (_tmp0_);
}


static void thin_paned_real_unmap (GtkWidget* base) {
	ThinPaned * self;
	GdkWindow* _tmp0_ = NULL;
	self = (ThinPaned*) base;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->unmap ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned));
	_tmp0_ = self->priv->overlay_handle;
	gdk_window_hide (_tmp0_);
}


static gboolean thin_paned_real_draw (GtkWidget* base, cairo_t* ctx) {
	ThinPaned * self;
	gboolean result = FALSE;
	cairo_t* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GtkAllocation allocation = {0};
	GtkAllocation _tmp3_ = {0};
	GtkStyleContext* style_context = NULL;
	GtkStyleContext* _tmp4_ = NULL;
	GtkStyleContext* _tmp5_ = NULL;
	GtkStateFlags state = 0;
	GtkStyleContext* _tmp6_ = NULL;
	GtkStateFlags _tmp7_ = 0;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp11_ = FALSE;
	gdouble width = 0.0;
	gdouble height = 0.0;
	GtkOrientation _tmp13_ = 0;
	GtkOrientation _tmp14_ = 0;
	cairo_t* _tmp19_ = NULL;
	cairo_t* _tmp20_ = NULL;
	GdkWindow* _tmp21_ = NULL;
	GtkStyleContext* _tmp22_ = NULL;
	cairo_t* _tmp23_ = NULL;
	gdouble _tmp24_ = 0.0;
	gdouble _tmp25_ = 0.0;
	GtkStyleContext* _tmp26_ = NULL;
	GtkStyleContext* _tmp27_ = NULL;
	GtkStyleContext* _tmp28_ = NULL;
	GtkStateFlags _tmp29_ = 0;
	GtkStyleContext* _tmp30_ = NULL;
	cairo_t* _tmp31_ = NULL;
	gdouble _tmp32_ = 0.0;
	gdouble _tmp33_ = 0.0;
	cairo_t* _tmp34_ = NULL;
	GtkStyleContext* _tmp35_ = NULL;
	self = (ThinPaned*) base;
	g_return_val_if_fail (ctx != NULL, FALSE);
	_tmp0_ = ctx;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->draw ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp0_);
	_tmp1_ = self->priv->overlay_handle;
	_tmp2_ = gdk_window_is_visible (_tmp1_);
	if (!_tmp2_) {
		result = FALSE;
		return result;
	}
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp3_);
	allocation = _tmp3_;
	_tmp4_ = gtk_widget_get_style_context ((GtkWidget*) self);
	_tmp5_ = _g_object_ref0 (_tmp4_);
	style_context = _tmp5_;
	_tmp6_ = style_context;
	_tmp7_ = gtk_style_context_get_state (_tmp6_);
	state = _tmp7_;
	g_object_get ((GtkWidget*) self, "is-focus", &_tmp8_, NULL);
	_tmp9_ = _tmp8_;
	if (_tmp9_) {
		GtkStateFlags _tmp10_ = 0;
		_tmp10_ = state;
		state = _tmp10_ | GTK_STATE_FLAG_SELECTED;
	}
	_tmp11_ = self->priv->in_resize;
	if (_tmp11_) {
		GtkStateFlags _tmp12_ = 0;
		_tmp12_ = state;
		state = _tmp12_ | GTK_STATE_FLAG_PRELIGHT;
	}
	_tmp13_ = gtk_orientable_get_orientation ((GtkOrientable*) self);
	_tmp14_ = _tmp13_;
	if (_tmp14_ == GTK_ORIENTATION_HORIZONTAL) {
		GtkAllocation _tmp15_ = {0};
		gint _tmp16_ = 0;
		width = (gdouble) 1;
		_tmp15_ = allocation;
		_tmp16_ = _tmp15_.height;
		height = (gdouble) _tmp16_;
	} else {
		GtkAllocation _tmp17_ = {0};
		gint _tmp18_ = 0;
		_tmp17_ = allocation;
		_tmp18_ = _tmp17_.width;
		width = (gdouble) _tmp18_;
		height = (gdouble) 1;
	}
	_tmp19_ = ctx;
	cairo_save (_tmp19_);
	_tmp20_ = ctx;
	_tmp21_ = gtk_paned_get_handle_window ((GtkPaned*) self);
	gtk_cairo_transform_to_window (_tmp20_, (GtkWidget*) self, _tmp21_);
	_tmp22_ = style_context;
	_tmp23_ = ctx;
	_tmp24_ = width;
	_tmp25_ = height;
	gtk_render_background (_tmp22_, _tmp23_, (gdouble) 0, (gdouble) 0, _tmp24_, _tmp25_);
	_tmp26_ = style_context;
	gtk_style_context_save (_tmp26_);
	_tmp27_ = style_context;
	gtk_style_context_add_class (_tmp27_, "ThinPaned");
	_tmp28_ = style_context;
	_tmp29_ = state;
	gtk_style_context_set_state (_tmp28_, _tmp29_);
	_tmp30_ = style_context;
	_tmp31_ = ctx;
	_tmp32_ = width;
	_tmp33_ = height;
	gtk_render_background (_tmp30_, _tmp31_, (gdouble) 0, (gdouble) 0, _tmp32_, _tmp33_);
	_tmp34_ = ctx;
	cairo_restore (_tmp34_);
	_tmp35_ = style_context;
	gtk_style_context_restore (_tmp35_);
	result = FALSE;
	_g_object_unref0 (style_context);
	return result;
}


static void thin_paned_real_size_allocate (GtkWidget* base, GtkAllocation* allocation) {
	ThinPaned * self;
	GtkAllocation _tmp0_ = {0};
	self = (ThinPaned*) base;
	g_return_if_fail (allocation != NULL);
	_tmp0_ = *allocation;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->size_allocate ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), &_tmp0_);
	thin_paned_update_overlay_handle (self);
}


static void thin_paned_update_overlay_handle (ThinPaned* self) {
	gboolean _tmp0_ = FALSE;
	GdkWindow* _tmp1_ = NULL;
	gint overlay_handle_x = 0;
	gint overlay_handle_y = 0;
	gint overlay_handle_width = 0;
	gint overlay_handle_height = 0;
	GdkWindow* default_handle = NULL;
	GdkWindow* _tmp3_ = NULL;
	GdkWindow* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GdkWindow* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	GdkWindow* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint overlay_handle_size = 0;
	GtkOrientation _tmp12_ = 0;
	GtkOrientation _tmp13_ = 0;
	GdkWindow* _tmp22_ = NULL;
	gint _tmp23_ = 0;
	gint _tmp24_ = 0;
	gint _tmp25_ = 0;
	gint _tmp26_ = 0;
	gboolean _tmp27_ = FALSE;
	gboolean _tmp28_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->overlay_handle;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = gtk_widget_get_realized ((GtkWidget*) self);
		_tmp0_ = !_tmp2_;
	}
	if (_tmp0_) {
		return;
	}
	_tmp3_ = gtk_paned_get_handle_window ((GtkPaned*) self);
	_tmp4_ = _g_object_ref0 (_tmp3_);
	default_handle = _tmp4_;
	_tmp5_ = default_handle;
	gdk_window_get_position (_tmp5_, &_tmp6_, &_tmp7_);
	overlay_handle_x = _tmp6_;
	overlay_handle_y = _tmp7_;
	_tmp8_ = default_handle;
	_tmp9_ = gdk_window_get_width (_tmp8_);
	overlay_handle_width = _tmp9_;
	_tmp10_ = default_handle;
	_tmp11_ = gdk_window_get_height (_tmp10_);
	overlay_handle_height = _tmp11_;
	gtk_widget_style_get ((GtkWidget*) self, THIN_PANED_STYLE_PROP_OVERLAY_HANDLE_SIZE, &overlay_handle_size, NULL);
	_tmp12_ = gtk_orientable_get_orientation ((GtkOrientable*) self);
	_tmp13_ = _tmp12_;
	if (_tmp13_ == GTK_ORIENTATION_HORIZONTAL) {
		gint _tmp14_ = 0;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		_tmp14_ = overlay_handle_x;
		_tmp15_ = overlay_handle_size;
		overlay_handle_x = _tmp14_ - (_tmp15_ / 2);
		_tmp16_ = overlay_handle_width;
		_tmp17_ = overlay_handle_size;
		overlay_handle_width = _tmp16_ + _tmp17_;
	} else {
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		gint _tmp20_ = 0;
		gint _tmp21_ = 0;
		_tmp18_ = overlay_handle_y;
		_tmp19_ = overlay_handle_size;
		overlay_handle_y = _tmp18_ - (_tmp19_ / 2);
		_tmp20_ = overlay_handle_height;
		_tmp21_ = overlay_handle_size;
		overlay_handle_height = _tmp20_ + _tmp21_;
	}
	_tmp22_ = self->priv->overlay_handle;
	_tmp23_ = overlay_handle_x;
	_tmp24_ = overlay_handle_y;
	_tmp25_ = overlay_handle_width;
	_tmp26_ = overlay_handle_height;
	gdk_window_move_resize (_tmp22_, _tmp23_, _tmp24_, _tmp25_, _tmp26_);
	g_signal_emit_by_name ((GtkWidget*) self, "state-flags-changed", 0);
	_tmp28_ = gtk_widget_get_mapped ((GtkWidget*) self);
	if (_tmp28_) {
		GdkWindow* _tmp29_ = NULL;
		gboolean _tmp30_ = FALSE;
		_tmp29_ = default_handle;
		_tmp30_ = gdk_window_is_visible (_tmp29_);
		_tmp27_ = _tmp30_;
	} else {
		_tmp27_ = FALSE;
	}
	if (_tmp27_) {
		GdkWindow* _tmp31_ = NULL;
		_tmp31_ = self->priv->overlay_handle;
		gdk_window_show (_tmp31_);
	} else {
		GdkWindow* _tmp32_ = NULL;
		_tmp32_ = self->priv->overlay_handle;
		gdk_window_hide (_tmp32_);
	}
	_g_object_unref0 (default_handle);
}


static void thin_paned_real_state_flags_changed (GtkWidget* base, GtkStateFlags previous_state) {
	ThinPaned * self;
	GtkStateFlags _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	self = (ThinPaned*) base;
	_tmp0_ = previous_state;
	GTK_WIDGET_CLASS (thin_paned_parent_class)->state_flags_changed ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp0_);
	_tmp1_ = gtk_widget_get_realized ((GtkWidget*) self);
	if (_tmp1_) {
		GdkCursor* default_handle_cursor = NULL;
		GdkWindow* _tmp2_ = NULL;
		GdkCursor* _tmp3_ = NULL;
		GdkCursor* _tmp4_ = NULL;
		GdkWindow* _tmp5_ = NULL;
		GdkCursor* _tmp6_ = NULL;
		GdkCursor* _tmp7_ = NULL;
		_tmp2_ = gtk_paned_get_handle_window ((GtkPaned*) self);
		_tmp3_ = gdk_window_get_cursor (_tmp2_);
		_tmp4_ = _g_object_ref0 (_tmp3_);
		default_handle_cursor = _tmp4_;
		_tmp5_ = self->priv->overlay_handle;
		_tmp6_ = gdk_window_get_cursor (_tmp5_);
		_tmp7_ = default_handle_cursor;
		if (_tmp6_ != _tmp7_) {
			GdkWindow* _tmp8_ = NULL;
			GdkCursor* _tmp9_ = NULL;
			_tmp8_ = self->priv->overlay_handle;
			_tmp9_ = default_handle_cursor;
			gdk_window_set_cursor (_tmp8_, _tmp9_);
		}
		_g_object_unref0 (default_handle_cursor);
	}
}


static gboolean thin_paned_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event) {
	ThinPaned * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GdkDevice* _tmp3_ = NULL;
	GdkEventMotion* _tmp4_ = NULL;
	GdkDevice* _tmp5_ = NULL;
	GdkDevice* device = NULL;
	GdkDevice* _tmp7_ = NULL;
	GdkDevice* _tmp8_ = NULL;
	GdkDevice* _tmp21_ = NULL;
	self = (ThinPaned*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->in_resize;
	if (!_tmp0_) {
		GdkEventMotion* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		_tmp1_ = event;
		_tmp2_ = GTK_WIDGET_CLASS (thin_paned_parent_class)->motion_notify_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp1_);
		result = _tmp2_;
		return result;
	}
	_tmp4_ = event;
	_tmp5_ = _tmp4_->device;
	_tmp3_ = _tmp5_;
	if (_tmp3_ == NULL) {
		GdkDevice* _tmp6_ = NULL;
		_tmp6_ = gtk_get_current_event_device ();
		_tmp3_ = _tmp6_;
	}
	_tmp7_ = _g_object_ref0 (_tmp3_);
	device = _tmp7_;
	_tmp8_ = device;
	if (_tmp8_ == NULL) {
		GdkDisplay* display = NULL;
		GdkDisplay* _tmp9_ = NULL;
		GdkDisplay* _tmp10_ = NULL;
		GdkDisplay* _tmp11_ = NULL;
		_tmp9_ = gtk_widget_get_display ((GtkWidget*) self);
		_tmp10_ = _g_object_ref0 (_tmp9_);
		display = _tmp10_;
		_tmp11_ = display;
		if (_tmp11_ != NULL) {
			GdkDeviceManager* dev_manager = NULL;
			GdkDisplay* _tmp12_ = NULL;
			GdkDeviceManager* _tmp13_ = NULL;
			GdkDeviceManager* _tmp14_ = NULL;
			GdkDeviceManager* _tmp15_ = NULL;
			_tmp12_ = display;
			_tmp13_ = gdk_display_get_device_manager (_tmp12_);
			_tmp14_ = _g_object_ref0 (_tmp13_);
			dev_manager = _tmp14_;
			_tmp15_ = dev_manager;
			if (_tmp15_ != NULL) {
				GdkDeviceManager* _tmp16_ = NULL;
				GList* _tmp17_ = NULL;
				GList* _tmp18_ = NULL;
				gconstpointer _tmp19_ = NULL;
				GdkDevice* _tmp20_ = NULL;
				_tmp16_ = dev_manager;
				_tmp17_ = gdk_device_manager_list_devices (_tmp16_, GDK_DEVICE_TYPE_MASTER);
				_tmp18_ = _tmp17_;
				_tmp19_ = g_list_nth_data (_tmp18_, (guint) 0);
				_tmp20_ = _g_object_ref0 ((GdkDevice*) _tmp19_);
				_g_object_unref0 (device);
				device = _tmp20_;
				_g_list_free0 (_tmp18_);
			}
			_g_object_unref0 (dev_manager);
		}
		_g_object_unref0 (display);
	}
	_tmp21_ = device;
	if (_tmp21_ != NULL) {
		gint x = 0;
		gint y = 0;
		gint pos = 0;
		GdkWindow* _tmp22_ = NULL;
		GdkDevice* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		gint _tmp25_ = 0;
		GtkOrientation _tmp26_ = 0;
		GtkOrientation _tmp27_ = 0;
		gint _tmp34_ = 0;
		gint _tmp35_ = 0;
		gint _tmp36_ = 0;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		pos = 0;
		_tmp22_ = gtk_widget_get_window ((GtkWidget*) self);
		_tmp23_ = device;
		gdk_window_get_device_position (_tmp22_, _tmp23_, &_tmp24_, &_tmp25_, NULL);
		x = _tmp24_;
		y = _tmp25_;
		_tmp26_ = gtk_orientable_get_orientation ((GtkOrientable*) self);
		_tmp27_ = _tmp26_;
		if (_tmp27_ == GTK_ORIENTATION_HORIZONTAL) {
			gint _tmp28_ = 0;
			gboolean _tmp29_ = FALSE;
			_tmp29_ = is_left_to_right ((GtkWidget*) self);
			if (_tmp29_) {
				gint _tmp30_ = 0;
				_tmp30_ = x;
				_tmp28_ = _tmp30_;
			} else {
				gint _tmp31_ = 0;
				gint _tmp32_ = 0;
				_tmp31_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
				_tmp32_ = x;
				_tmp28_ = _tmp31_ - _tmp32_;
			}
			pos = _tmp28_;
		} else {
			gint _tmp33_ = 0;
			_tmp33_ = y;
			pos = _tmp33_;
		}
		_tmp34_ = pos;
		g_object_get ((GtkPaned*) self, "min-position", &_tmp35_, NULL);
		_tmp36_ = _tmp35_;
		g_object_get ((GtkPaned*) self, "max-position", &_tmp37_, NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = CLAMP (_tmp34_, _tmp36_, _tmp38_);
		gtk_paned_set_position ((GtkPaned*) self, _tmp39_);
		result = TRUE;
		_g_object_unref0 (device);
		return result;
	}
	g_return_val_if_reached (FALSE);
	_g_object_unref0 (device);
}


static gboolean thin_paned_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	ThinPaned * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	GdkEventButton* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	self = (ThinPaned*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp2_ = self->priv->in_resize;
	if (!_tmp2_) {
		GdkEventButton* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		_tmp3_ = event;
		_tmp4_ = _tmp3_->button;
		_tmp1_ = _tmp4_ == ((guint) GDK_BUTTON_PRIMARY);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GdkEventButton* _tmp5_ = NULL;
		GdkWindow* _tmp6_ = NULL;
		GdkWindow* _tmp7_ = NULL;
		_tmp5_ = event;
		_tmp6_ = _tmp5_->window;
		_tmp7_ = self->priv->overlay_handle;
		_tmp0_ = _tmp6_ == _tmp7_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		self->priv->in_resize = TRUE;
		gtk_grab_add ((GtkWidget*) self);
		result = TRUE;
		return result;
	}
	_tmp8_ = event;
	_tmp9_ = GTK_WIDGET_CLASS (thin_paned_parent_class)->button_press_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp8_);
	result = _tmp9_;
	return result;
}


static gboolean thin_paned_real_button_release_event (GtkWidget* base, GdkEventButton* event) {
	ThinPaned * self;
	gboolean result = FALSE;
	GdkEventButton* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	GdkEventButton* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	self = (ThinPaned*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->window;
	_tmp2_ = self->priv->overlay_handle;
	if (_tmp1_ == _tmp2_) {
		self->priv->in_resize = FALSE;
		gtk_grab_remove ((GtkWidget*) self);
		result = TRUE;
		return result;
	}
	_tmp3_ = event;
	_tmp4_ = GTK_WIDGET_CLASS (thin_paned_parent_class)->button_release_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp3_);
	result = _tmp4_;
	return result;
}


static gboolean thin_paned_real_grab_broken_event (GtkWidget* base, GdkEventGrabBroken* event) {
	ThinPaned * self;
	gboolean result = FALSE;
	GdkEventGrabBroken* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	self = (ThinPaned*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	self->priv->in_resize = FALSE;
	_tmp0_ = event;
	_tmp1_ = GTK_WIDGET_CLASS (thin_paned_parent_class)->grab_broken_event ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_paned_get_type (), GtkPaned), _tmp0_);
	result = _tmp1_;
	return result;
}


static void thin_paned_class_init (ThinPanedClass * klass) {
	GParamSpecInt* _tmp0_ = NULL;
	GParamSpecInt* _tmp1_ = NULL;
	thin_paned_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ThinPanedPrivate));
	((GtkWidgetClass *) klass)->realize = thin_paned_real_realize;
	((GtkWidgetClass *) klass)->unrealize = thin_paned_real_unrealize;
	((GtkWidgetClass *) klass)->map = thin_paned_real_map;
	((GtkWidgetClass *) klass)->unmap = thin_paned_real_unmap;
	((GtkWidgetClass *) klass)->draw = thin_paned_real_draw;
	((GtkWidgetClass *) klass)->size_allocate = thin_paned_real_size_allocate;
	((GtkWidgetClass *) klass)->state_flags_changed = thin_paned_real_state_flags_changed;
	((GtkWidgetClass *) klass)->motion_notify_event = thin_paned_real_motion_notify_event;
	((GtkWidgetClass *) klass)->button_press_event = thin_paned_real_button_press_event;
	((GtkWidgetClass *) klass)->button_release_event = thin_paned_real_button_release_event;
	((GtkWidgetClass *) klass)->grab_broken_event = thin_paned_real_grab_broken_event;
	G_OBJECT_CLASS (klass)->finalize = thin_paned_finalize;
	_tmp0_ = g_param_spec_int (THIN_PANED_STYLE_PROP_OVERLAY_HANDLE_SIZE, "Overlay handle's size", "Width of the invisible overlay handle", 1, 48, 8, G_PARAM_READABLE);
	_tmp1_ = _tmp0_;
	gtk_widget_class_install_style_property (GTK_WIDGET_CLASS (klass), (GParamSpec*) _tmp1_);
	_g_param_spec_unref0 (_tmp1_);
}


static void thin_paned_instance_init (ThinPaned * self) {
	self->priv = THIN_PANED_GET_PRIVATE (self);
	self->priv->in_resize = FALSE;
}


static void thin_paned_finalize (GObject* obj) {
	ThinPaned * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_THIN_PANED, ThinPaned);
	_g_object_unref0 (self->priv->overlay_handle);
	G_OBJECT_CLASS (thin_paned_parent_class)->finalize (obj);
}


/***
    Copyright (C) 2012-2013 Victor Eduardo <victoreduardm@gmal.com>

    This program or library is free software; you can redistribute it
    and/or modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General
    Public License along with this library; if not, write to the
    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301 USA.
***/
GType thin_paned_get_type (void) {
	static volatile gsize thin_paned_type_id__volatile = 0;
	if (g_once_init_enter (&thin_paned_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ThinPanedClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) thin_paned_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ThinPaned), 0, (GInstanceInitFunc) thin_paned_instance_init, NULL };
		GType thin_paned_type_id;
		thin_paned_type_id = g_type_register_static (gtk_paned_get_type (), "ThinPaned", &g_define_type_info, 0);
		g_once_init_leave (&thin_paned_type_id__volatile, thin_paned_type_id);
	}
	return thin_paned_type_id__volatile;
}



