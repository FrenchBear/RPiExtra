/* Migration.c generated by valac 0.26.1, the Vala compiler
 * generated from Migration.vala, do not modify */

/* Migration.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <gee.h>

typedef struct _FontManagerMigration FontManagerMigration;

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_MANAGER_TYPE_COLLECTIONS (font_manager_collections_get_type ())
#define FONT_MANAGER_COLLECTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_COLLECTIONS, FontManagerCollections))
#define FONT_MANAGER_COLLECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_COLLECTIONS, FontManagerCollectionsClass))
#define FONT_MANAGER_IS_COLLECTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_COLLECTIONS))
#define FONT_MANAGER_IS_COLLECTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_COLLECTIONS))
#define FONT_MANAGER_COLLECTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_COLLECTIONS, FontManagerCollectionsClass))

typedef struct _FontManagerCollections FontManagerCollections;
typedef struct _FontManagerCollectionsClass FontManagerCollectionsClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block10Data Block10Data;

#define FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW (font_manager_standard_text_view_get_type ())
#define FONT_MANAGER_STANDARD_TEXT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW, FontManagerStandardTextView))
#define FONT_MANAGER_STANDARD_TEXT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW, FontManagerStandardTextViewClass))
#define FONT_MANAGER_IS_STANDARD_TEXT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW))
#define FONT_MANAGER_IS_STANDARD_TEXT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW))
#define FONT_MANAGER_STANDARD_TEXT_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_VIEW, FontManagerStandardTextViewClass))

typedef struct _FontManagerStandardTextView FontManagerStandardTextView;
typedef struct _FontManagerStandardTextViewClass FontManagerStandardTextViewClass;

#define FONT_MANAGER_TYPE_STATIC_TEXT_VIEW (font_manager_static_text_view_get_type ())
#define FONT_MANAGER_STATIC_TEXT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_STATIC_TEXT_VIEW, FontManagerStaticTextView))
#define FONT_MANAGER_STATIC_TEXT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_STATIC_TEXT_VIEW, FontManagerStaticTextViewClass))
#define FONT_MANAGER_IS_STATIC_TEXT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_STATIC_TEXT_VIEW))
#define FONT_MANAGER_IS_STATIC_TEXT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_STATIC_TEXT_VIEW))
#define FONT_MANAGER_STATIC_TEXT_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_STATIC_TEXT_VIEW, FontManagerStaticTextViewClass))

typedef struct _FontManagerStaticTextView FontManagerStaticTextView;
typedef struct _FontManagerStaticTextViewClass FontManagerStaticTextViewClass;

#define FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE (font_manager_standard_text_tag_table_get_type ())
#define FONT_MANAGER_STANDARD_TEXT_TAG_TABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE, FontManagerStandardTextTagTable))
#define FONT_MANAGER_STANDARD_TEXT_TAG_TABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE, FontManagerStandardTextTagTableClass))
#define FONT_MANAGER_IS_STANDARD_TEXT_TAG_TABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE))
#define FONT_MANAGER_IS_STANDARD_TEXT_TAG_TABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE))
#define FONT_MANAGER_STANDARD_TEXT_TAG_TABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_STANDARD_TEXT_TAG_TABLE, FontManagerStandardTextTagTableClass))

typedef struct _FontManagerStandardTextTagTable FontManagerStandardTextTagTable;
typedef struct _FontManagerStandardTextTagTableClass FontManagerStandardTextTagTableClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define FONT_MANAGER_TYPE_FILTER (font_manager_filter_get_type ())
#define FONT_MANAGER_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilter))
#define FONT_MANAGER_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))
#define FONT_MANAGER_IS_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_IS_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))

typedef struct _FontManagerFilter FontManagerFilter;
typedef struct _FontManagerFilterClass FontManagerFilterClass;

#define FONT_MANAGER_TYPE_COLLECTION (font_manager_collection_get_type ())
#define FONT_MANAGER_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollection))
#define FONT_MANAGER_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollectionClass))
#define FONT_MANAGER_IS_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_COLLECTION))
#define FONT_MANAGER_IS_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_COLLECTION))
#define FONT_MANAGER_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollectionClass))

typedef struct _FontManagerCollection FontManagerCollection;
typedef struct _FontManagerCollectionClass FontManagerCollectionClass;
#define _xmlXPathFreeContext0(var) ((var == NULL) ? NULL : (var = (xmlXPathFreeContext (var), NULL)))

struct _FontManagerMigration {
};

struct _Block10Data {
	int _ref_count_;
	GtkResponseType response;
	GtkDialog* dialog;
};


static gchar* font_manager_migration_old_prefs_file;
static gchar* font_manager_migration_old_prefs_file = NULL;
static gchar* font_manager_migration_old_cache_file;
static gchar* font_manager_migration_old_cache_file = NULL;
static gchar* font_manager_migration_old_collections_file;
static gchar* font_manager_migration_old_collections_file = NULL;
static FontManagerCollections* font_manager_migration_collections;
static FontManagerCollections* font_manager_migration_collections = NULL;

gboolean font_manager_update_declined (void);
gboolean font_manager_migration_required (void);
gboolean font_manager_migration_approved (GtkWindow* parent);
void font_manager_migration_run (void);
void font_manager_migration_free (FontManagerMigration* self);
static void font_manager_migration_instance_init (FontManagerMigration * self);
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_manager_collections_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_NAME "font-manager"
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (void * _userdata_);
GType font_manager_standard_text_view_get_type (void) G_GNUC_CONST;
GType font_manager_static_text_view_get_type (void) G_GNUC_CONST;
GType font_manager_standard_text_tag_table_get_type (void) G_GNUC_CONST;
FontManagerStaticTextView* font_manager_static_text_view_new (FontManagerStandardTextTagTable* tag_table);
FontManagerStaticTextView* font_manager_static_text_view_construct (GType object_type, FontManagerStandardTextTagTable* tag_table);
GtkTextBuffer* font_manager_standard_text_view_get_buffer (FontManagerStandardTextView* self);
#define update_notice _ ("\n" \
"Font Manager has detected files from a previous installation. Some fil" \
"es from previous versions are incompatible with this release. Others h" \
"ave been deprecated or moved.\n" \
"\n" \
"Font Manager will now attempt to migrate your fonts and collections. F" \
"iles and settings which are no longer necessary or valid will be delet" \
"ed. Any configuration files that could cause a conflict will also be d" \
"eleted.\n" \
"\n" \
"It is strongly recommended that you back up any important files before" \
" proceeding.\n")
static void __lambda132_ (Block10Data* _data10_);
static void ___lambda132__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda133_ (Block10Data* _data10_);
static void ___lambda133__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda134_ (Block10Data* _data10_, gint i);
static void ___lambda134__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static void __lambda135_ (Block10Data* _data10_);
static void ___lambda135__gtk_dialog_close (GtkDialog* _sender, gpointer self);
static gboolean __lambda136_ (Block10Data* _data10_);
static gboolean ___lambda136__gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self);
static void font_manager_migration_import_fonts (void);
static gboolean font_manager_migration_import_collections (void);
static gboolean font_manager_migration_purge_cache (void);
static gboolean font_manager_migration_purge_config (void);
static gboolean font_manager_migration_purge_fontconfig_config (void);
static gboolean font_manager_migration_purge_data (void);
static gboolean font_manager_migration_purge_obsolete (void);
gboolean font_manager_collections_cache (FontManagerCollections* self);
gboolean remove_directory (GFile* dir, gboolean recursive);
static void _vala_array_add6 (GFile*** array, int* length, int* size, GFile* value);
static void _vala_array_add7 (GFile*** array, int* length, int* size, GFile* value);
void font_manager_library_install_from_file_array (GFile** files, int files_length1);
FontManagerCollections* font_manager_load_collections (void);
GType font_manager_filter_get_type (void) G_GNUC_CONST;
GType font_manager_collection_get_type (void) G_GNUC_CONST;
FontManagerCollection* font_manager_collection_new (const gchar* name);
FontManagerCollection* font_manager_collection_construct (GType object_type, const gchar* name);
GeeHashMap* font_manager_collections_get_entries (FontManagerCollections* self);
void font_manager_filter_set_comment (FontManagerFilter* self, const gchar* value);
GeeHashSet* font_manager_filter_get_families (FontManagerFilter* self);
FontManagerMigration* font_manager_migration_new (void);
FontManagerMigration* font_manager_migration_new (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


gboolean font_manager_update_declined (void) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = font_manager_migration_required ();
	if (_tmp0_) {
		gboolean _tmp1_ = FALSE;
		_tmp1_ = font_manager_migration_approved (NULL);
		if (_tmp1_) {
			font_manager_migration_run ();
		} else {
			result = TRUE;
			return result;
		}
	}
	result = FALSE;
	return result;
}


gboolean font_manager_migration_required (void) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GFile* old_prefs = NULL;
	const gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	GFile* old_cache = NULL;
	const gchar* _tmp6_ = NULL;
	GFile* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GFile* old_collections = NULL;
	const gchar* _tmp10_ = NULL;
	GFile* _tmp11_ = NULL;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	GFile* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	_tmp0_ = g_get_user_config_dir ();
	_tmp1_ = g_build_filename (_tmp0_, FONT_MANAGER_NAME, "preferences.ini", NULL);
	_g_free0 (font_manager_migration_old_prefs_file);
	font_manager_migration_old_prefs_file = _tmp1_;
	_tmp2_ = font_manager_migration_old_prefs_file;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	old_prefs = _tmp3_;
	_tmp4_ = g_get_user_cache_dir ();
	_tmp5_ = g_build_filename (_tmp4_, FONT_MANAGER_NAME, "font-manager.cache", NULL);
	_g_free0 (font_manager_migration_old_cache_file);
	font_manager_migration_old_cache_file = _tmp5_;
	_tmp6_ = font_manager_migration_old_cache_file;
	_tmp7_ = g_file_new_for_path (_tmp6_);
	old_cache = _tmp7_;
	_tmp8_ = g_get_user_data_dir ();
	_tmp9_ = g_build_filename (_tmp8_, FONT_MANAGER_NAME, "Collections.xml", NULL);
	_g_free0 (font_manager_migration_old_collections_file);
	font_manager_migration_old_collections_file = _tmp9_;
	_tmp10_ = font_manager_migration_old_collections_file;
	_tmp11_ = g_file_new_for_path (_tmp10_);
	old_collections = _tmp11_;
	_tmp14_ = old_prefs;
	_tmp15_ = g_file_query_exists (_tmp14_, NULL);
	if (_tmp15_) {
		_tmp13_ = TRUE;
	} else {
		GFile* _tmp16_ = NULL;
		gboolean _tmp17_ = FALSE;
		_tmp16_ = old_cache;
		_tmp17_ = g_file_query_exists (_tmp16_, NULL);
		_tmp13_ = _tmp17_;
	}
	if (_tmp13_) {
		_tmp12_ = TRUE;
	} else {
		GFile* _tmp18_ = NULL;
		gboolean _tmp19_ = FALSE;
		_tmp18_ = old_collections;
		_tmp19_ = g_file_query_exists (_tmp18_, NULL);
		_tmp12_ = _tmp19_;
	}
	result = _tmp12_;
	_g_object_unref0 (old_collections);
	_g_object_unref0 (old_cache);
	_g_object_unref0 (old_prefs);
	return result;
}


static Block10Data* block10_data_ref (Block10Data* _data10_) {
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}


static void block10_data_unref (void * _userdata_) {
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		_g_object_unref0 (_data10_->dialog);
		g_slice_free (Block10Data, _data10_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda132_ (Block10Data* _data10_) {
	gtk_dialog_response (_data10_->dialog, (gint) GTK_RESPONSE_CANCEL);
}


static void ___lambda132__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda132_ (self);
}


static void __lambda133_ (Block10Data* _data10_) {
	gtk_dialog_response (_data10_->dialog, (gint) GTK_RESPONSE_ACCEPT);
}


static void ___lambda133__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda133_ (self);
}


static void __lambda134_ (Block10Data* _data10_, gint i) {
	gint _tmp0_ = 0;
	_tmp0_ = i;
	_data10_->response = (GtkResponseType) _tmp0_;
	gtk_widget_destroy ((GtkWidget*) _data10_->dialog);
}


static void ___lambda134__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda134_ (self, response_id);
}


static void __lambda135_ (Block10Data* _data10_) {
	gtk_widget_destroy ((GtkWidget*) _data10_->dialog);
}


static void ___lambda135__gtk_dialog_close (GtkDialog* _sender, gpointer self) {
	__lambda135_ (self);
}


static gboolean __lambda136_ (Block10Data* _data10_) {
	gboolean result = FALSE;
	gtk_widget_destroy ((GtkWidget*) _data10_->dialog);
	result = FALSE;
	return result;
}


static gboolean ___lambda136__gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self) {
	gboolean result;
	result = __lambda136_ (self);
	return result;
}


gboolean font_manager_migration_approved (GtkWindow* parent) {
	gboolean result = FALSE;
	Block10Data* _data10_;
	GtkDialog* _tmp0_ = NULL;
	GtkButton* cancel = NULL;
	const gchar* _tmp1_ = NULL;
	GtkButton* _tmp2_ = NULL;
	GtkButton* accept = NULL;
	const gchar* _tmp3_ = NULL;
	GtkButton* _tmp4_ = NULL;
	GtkHeaderBar* header = NULL;
	GtkHeaderBar* _tmp5_ = NULL;
	GtkBox* box = NULL;
	GtkBox* _tmp6_ = NULL;
	GtkBox* _tmp7_ = NULL;
	GtkScrolledWindow* scrolled = NULL;
	GtkScrolledWindow* _tmp8_ = NULL;
	FontManagerStaticTextView* textview = NULL;
	FontManagerStaticTextView* _tmp9_ = NULL;
	GtkTextBuffer* _tmp10_ = NULL;
	GtkTextBuffer* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	GtkWindow* _tmp13_ = NULL;
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->response = GTK_RESPONSE_NONE;
	_tmp0_ = (GtkDialog*) gtk_dialog_new ();
	g_object_ref_sink (_tmp0_);
	_data10_->dialog = _tmp0_;
	_tmp1_ = _ ("_Cancel");
	_tmp2_ = (GtkButton*) gtk_button_new_with_mnemonic (_tmp1_);
	g_object_ref_sink (_tmp2_);
	cancel = _tmp2_;
	_tmp3_ = _ ("_Continue");
	_tmp4_ = (GtkButton*) gtk_button_new_with_mnemonic (_tmp3_);
	g_object_ref_sink (_tmp4_);
	accept = _tmp4_;
	_tmp5_ = (GtkHeaderBar*) gtk_header_bar_new ();
	g_object_ref_sink (_tmp5_);
	header = _tmp5_;
	_tmp6_ = (GtkBox*) gtk_dialog_get_content_area (_data10_->dialog);
	_tmp7_ = _g_object_ref0 (_tmp6_);
	box = _tmp7_;
	_tmp8_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp8_);
	scrolled = _tmp8_;
	_tmp9_ = font_manager_static_text_view_new (NULL);
	g_object_ref_sink (_tmp9_);
	textview = _tmp9_;
	gtk_orientable_set_orientation ((GtkOrientable*) box, GTK_ORIENTATION_VERTICAL);
	gtk_container_add ((GtkContainer*) scrolled, (GtkWidget*) textview);
	gtk_box_pack_start (box, (GtkWidget*) scrolled, TRUE, TRUE, (guint) 0);
	_tmp10_ = font_manager_standard_text_view_get_buffer ((FontManagerStandardTextView*) textview);
	_tmp11_ = _tmp10_;
	gtk_text_buffer_set_text (_tmp11_, update_notice, -1);
	_tmp12_ = _ ("Update Required");
	gtk_header_bar_set_title (header, _tmp12_);
	gtk_header_bar_pack_start (header, (GtkWidget*) cancel);
	gtk_header_bar_pack_end (header, (GtkWidget*) accept);
	gtk_window_set_titlebar ((GtkWindow*) _data10_->dialog, (GtkWidget*) header);
	_tmp13_ = parent;
	gtk_window_set_transient_for ((GtkWindow*) _data10_->dialog, _tmp13_);
	gtk_window_set_modal ((GtkWindow*) _data10_->dialog, TRUE);
	gtk_window_set_destroy_with_parent ((GtkWindow*) _data10_->dialog, TRUE);
	gtk_widget_set_size_request ((GtkWidget*) _data10_->dialog, 540, 360);
	gtk_widget_show_all ((GtkWidget*) header);
	gtk_widget_show_all ((GtkWidget*) box);
	g_signal_connect_data (cancel, "clicked", (GCallback) ___lambda132__gtk_button_clicked, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	g_signal_connect_data (accept, "clicked", (GCallback) ___lambda133__gtk_button_clicked, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	g_signal_connect_data (_data10_->dialog, "response", (GCallback) ___lambda134__gtk_dialog_response, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	g_signal_connect_data (_data10_->dialog, "close", (GCallback) ___lambda135__gtk_dialog_close, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	g_signal_connect_data ((GtkWidget*) _data10_->dialog, "delete-event", (GCallback) ___lambda136__gtk_widget_delete_event, block10_data_ref (_data10_), (GClosureNotify) block10_data_unref, 0);
	gtk_dialog_run (_data10_->dialog);
	result = _data10_->response == GTK_RESPONSE_ACCEPT;
	_g_object_unref0 (textview);
	_g_object_unref0 (scrolled);
	_g_object_unref0 (box);
	_g_object_unref0 (header);
	_g_object_unref0 (accept);
	_g_object_unref0 (cancel);
	block10_data_unref (_data10_);
	_data10_ = NULL;
	return result;
}


void font_manager_migration_run (void) {
	FontManagerCollections* _tmp0_ = NULL;
	g_debug ("Migration.vala:89: Importing fonts");
	font_manager_migration_import_fonts ();
	g_debug ("Migration.vala:91: Importing collections");
	font_manager_migration_import_collections ();
	g_debug ("Migration.vala:93: Purging old cache files");
	font_manager_migration_purge_cache ();
	g_debug ("Migration.vala:95: Purging old configuration files");
	font_manager_migration_purge_config ();
	g_debug ("Migration.vala:97: Purging old FontConfig configuration files");
	font_manager_migration_purge_fontconfig_config ();
	g_debug ("Migration.vala:99: Purging outdated data");
	font_manager_migration_purge_data ();
	g_debug ("Migration.vala:101: Purging obsolete files");
	font_manager_migration_purge_obsolete ();
	g_debug ("Migration.vala:103: Saving imported collections");
	_tmp0_ = font_manager_migration_collections;
	font_manager_collections_cache (_tmp0_);
	return;
}


static gboolean font_manager_migration_purge_cache (void) {
	gboolean result = FALSE;
	GFile* cache_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	_tmp0_ = g_get_user_cache_dir ();
	_tmp1_ = g_build_filename (_tmp0_, FONT_MANAGER_NAME, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	cache_dir = _tmp4_;
	_tmp5_ = remove_directory (cache_dir, TRUE);
	result = _tmp5_;
	_g_object_unref0 (cache_dir);
	return result;
}


static gboolean font_manager_migration_purge_config (void) {
	gboolean result = FALSE;
	GFile* config_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	_tmp0_ = g_get_user_config_dir ();
	_tmp1_ = g_build_filename (_tmp0_, FONT_MANAGER_NAME, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	config_dir = _tmp4_;
	_tmp5_ = remove_directory (config_dir, TRUE);
	result = _tmp5_;
	_g_object_unref0 (config_dir);
	return result;
}


static gboolean font_manager_migration_purge_fontconfig_config (void) {
	gboolean result = FALSE;
	GFile* fontconfig_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	_tmp0_ = g_get_user_config_dir ();
	_tmp1_ = g_build_filename (_tmp0_, "fontconfig", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	fontconfig_dir = _tmp4_;
	_tmp5_ = remove_directory (fontconfig_dir, TRUE);
	result = _tmp5_;
	_g_object_unref0 (fontconfig_dir);
	return result;
}


static gboolean font_manager_migration_purge_data (void) {
	gboolean result = FALSE;
	GFile* data_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	_tmp0_ = g_get_user_data_dir ();
	_tmp1_ = g_build_filename (_tmp0_, FONT_MANAGER_NAME, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	data_dir = _tmp4_;
	_tmp5_ = remove_directory (data_dir, TRUE);
	result = _tmp5_;
	_g_object_unref0 (data_dir);
	return result;
}


static gboolean font_manager_migration_purge_obsolete (void) {
	gboolean result = FALSE;
	GFile* fontsconf = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	GFile* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_build_filename (_tmp0_, ".fonts.conf", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	fontsconf = _tmp4_;
	_tmp5_ = fontsconf;
	_tmp6_ = g_file_query_exists (_tmp5_, NULL);
	if (_tmp6_) {
		{
			GFile* _tmp7_ = NULL;
			_tmp7_ = fontsconf;
			g_file_delete (_tmp7_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch43_g_error;
			}
			result = TRUE;
			_g_object_unref0 (fontsconf);
			return result;
		}
		goto __finally43;
		__catch43_g_error:
		{
			GError* e = NULL;
			GError* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = e;
			_tmp9_ = _tmp8_->message;
			g_warning ("Migration.vala:135: Failed to remove obsolete file : %s", _tmp9_);
			_g_error_free0 (e);
		}
		__finally43:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (fontsconf);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = FALSE;
	_g_object_unref0 (fontsconf);
	return result;
}


static void _vala_array_add6 (GFile*** array, int* length, int* size, GFile* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add7 (GFile*** array, int* length, int* size, GFile* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void font_manager_migration_import_fonts (void) {
	GFile** font_dirs = NULL;
	gint font_dirs_length1 = 0;
	gint _font_dirs_size_ = 0;
	gchar* old_font_dir = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GFile* ofd = NULL;
	const gchar* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gchar* old_library = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	GFile* ol = NULL;
	const gchar* _tmp11_ = NULL;
	GFile* _tmp12_ = NULL;
	GFile* _tmp13_ = NULL;
	gboolean _tmp14_ = FALSE;
	GFile** _tmp18_ = NULL;
	gint _tmp18__length1 = 0;
	font_dirs = NULL;
	font_dirs_length1 = 0;
	_font_dirs_size_ = font_dirs_length1;
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_build_filename (_tmp0_, ".fonts", NULL);
	old_font_dir = _tmp1_;
	_tmp2_ = old_font_dir;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	ofd = _tmp3_;
	_tmp4_ = ofd;
	_tmp5_ = g_file_query_exists (_tmp4_, NULL);
	if (_tmp5_) {
		GFile** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		GFile* _tmp7_ = NULL;
		GFile* _tmp8_ = NULL;
		_tmp6_ = font_dirs;
		_tmp6__length1 = font_dirs_length1;
		_tmp7_ = ofd;
		_tmp8_ = _g_object_ref0 (_tmp7_);
		_vala_array_add6 (&font_dirs, &font_dirs_length1, &_font_dirs_size_, _tmp8_);
	}
	_tmp9_ = g_get_user_data_dir ();
	_tmp10_ = g_build_filename (_tmp9_, FONT_MANAGER_NAME, "Library", NULL);
	old_library = _tmp10_;
	_tmp11_ = old_library;
	_tmp12_ = g_file_new_for_path (_tmp11_);
	ol = _tmp12_;
	_tmp13_ = ol;
	_tmp14_ = g_file_query_exists (_tmp13_, NULL);
	if (_tmp14_) {
		GFile** _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		GFile* _tmp16_ = NULL;
		GFile* _tmp17_ = NULL;
		_tmp15_ = font_dirs;
		_tmp15__length1 = font_dirs_length1;
		_tmp16_ = ol;
		_tmp17_ = _g_object_ref0 (_tmp16_);
		_vala_array_add7 (&font_dirs, &font_dirs_length1, &_font_dirs_size_, _tmp17_);
	}
	_tmp18_ = font_dirs;
	_tmp18__length1 = font_dirs_length1;
	font_manager_library_install_from_file_array (_tmp18_, _tmp18__length1);
	_g_object_unref0 (ol);
	_g_free0 (old_library);
	_g_object_unref0 (ofd);
	_g_free0 (old_font_dir);
	font_dirs = (_vala_array_free (font_dirs, font_dirs_length1, (GDestroyNotify) g_object_unref), NULL);
	return;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static gboolean font_manager_migration_import_collections (void) {
	gboolean result = FALSE;
	FontManagerCollections* _tmp4_ = NULL;
	xmlDoc* doc = NULL;
	const gchar* _tmp5_ = NULL;
	xmlDoc* _tmp6_ = NULL;
	xmlDoc* _tmp7_ = NULL;
	xmlXPathContext* ctx = NULL;
	xmlDoc* _tmp8_ = NULL;
	xmlXPathContext* _tmp9_ = NULL;
	xmlXPathObject* res = NULL;
	xmlXPathContext* _tmp10_ = NULL;
	xmlXPathObject* _tmp11_ = NULL;
	xmlXPathObject* _tmp51_ = NULL;
	xmlDoc* _tmp52_ = NULL;
	{
		GFile* file = NULL;
		const gchar* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		GFile* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp0_ = font_manager_migration_old_collections_file;
		_tmp1_ = g_file_new_for_path (_tmp0_);
		file = _tmp1_;
		_tmp2_ = file;
		_tmp3_ = g_file_query_exists (_tmp2_, NULL);
		if (!_tmp3_) {
			result = FALSE;
			_g_object_unref0 (file);
			return result;
		}
		_g_object_unref0 (file);
	}
	_tmp4_ = font_manager_load_collections ();
	_g_object_unref0 (font_manager_migration_collections);
	font_manager_migration_collections = _tmp4_;
	xmlInitParser ();
	_tmp5_ = font_manager_migration_old_collections_file;
	_tmp6_ = xmlParseFile (_tmp5_);
	doc = _tmp6_;
	_tmp7_ = doc;
	if (_tmp7_ == NULL) {
		xmlCleanupParser ();
		result = FALSE;
		return result;
	}
	_tmp8_ = doc;
	_tmp9_ = xmlXPathNewContext (_tmp8_);
	ctx = _tmp9_;
	_tmp10_ = ctx;
	_tmp11_ = xmlXPathEvalExpression ((xmlChar*) "//fontcollection", _tmp10_);
	res = _tmp11_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp12_ = FALSE;
			_tmp12_ = TRUE;
			while (TRUE) {
				gint _tmp14_ = 0;
				xmlXPathObject* _tmp15_ = NULL;
				xmlNodeSet* _tmp16_ = NULL;
				gint _tmp17_ = 0;
				xmlNode* node = NULL;
				xmlXPathObject* _tmp18_ = NULL;
				xmlNodeSet* _tmp19_ = NULL;
				gint _tmp20_ = 0;
				xmlNode* _tmp21_ = NULL;
				gchar* name = NULL;
				xmlNode* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				FontManagerCollection* collection = NULL;
				const gchar* _tmp24_ = NULL;
				FontManagerCollection* _tmp25_ = NULL;
				FontManagerCollections* _tmp26_ = NULL;
				GeeHashMap* _tmp27_ = NULL;
				GeeHashMap* _tmp28_ = NULL;
				const gchar* _tmp29_ = NULL;
				FontManagerCollection* _tmp30_ = NULL;
				FontManagerCollection* _tmp31_ = NULL;
				xmlNode* _tmp32_ = NULL;
				gchar* _tmp33_ = NULL;
				gchar* _tmp34_ = NULL;
				if (!_tmp12_) {
					gint _tmp13_ = 0;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp12_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = res;
				_tmp16_ = _tmp15_->nodesetval;
				_tmp17_ = xmlXPathNodeSetGetLength (_tmp16_);
				if (!(_tmp14_ < _tmp17_)) {
					break;
				}
				_tmp18_ = res;
				_tmp19_ = _tmp18_->nodesetval;
				_tmp20_ = i;
				_tmp21_ = xmlXPathNodeSetItem (_tmp19_, _tmp20_);
				node = _tmp21_;
				_tmp22_ = node;
				_tmp23_ = (gchar*) xmlGetProp (_tmp22_, (xmlChar*) "name");
				name = _tmp23_;
				_tmp24_ = name;
				_tmp25_ = font_manager_collection_new (_tmp24_);
				collection = _tmp25_;
				_tmp26_ = font_manager_migration_collections;
				_tmp27_ = font_manager_collections_get_entries (_tmp26_);
				_tmp28_ = _tmp27_;
				_tmp29_ = name;
				_tmp30_ = collection;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp28_, _tmp29_, _tmp30_);
				_tmp31_ = collection;
				_tmp32_ = node;
				_tmp33_ = (gchar*) xmlGetProp (_tmp32_, (xmlChar*) "comment");
				_tmp34_ = _tmp33_;
				font_manager_filter_set_comment ((FontManagerFilter*) _tmp31_, _tmp34_);
				_g_free0 (_tmp34_);
				{
					xmlNode* iter = NULL;
					xmlNode* _tmp35_ = NULL;
					xmlNode* _tmp36_ = NULL;
					_tmp35_ = node;
					_tmp36_ = _tmp35_->children;
					iter = _tmp36_;
					{
						gboolean _tmp37_ = FALSE;
						_tmp37_ = TRUE;
						while (TRUE) {
							xmlNode* _tmp40_ = NULL;
							xmlNode* _tmp41_ = NULL;
							xmlElementType _tmp42_ = 0;
							FontManagerCollection* _tmp43_ = NULL;
							GeeHashSet* _tmp44_ = NULL;
							GeeHashSet* _tmp45_ = NULL;
							xmlNode* _tmp46_ = NULL;
							gchar* _tmp47_ = NULL;
							gchar* _tmp48_ = NULL;
							gchar* _tmp49_ = NULL;
							gchar* _tmp50_ = NULL;
							if (!_tmp37_) {
								xmlNode* _tmp38_ = NULL;
								xmlNode* _tmp39_ = NULL;
								_tmp38_ = iter;
								_tmp39_ = _tmp38_->next;
								iter = _tmp39_;
							}
							_tmp37_ = FALSE;
							_tmp40_ = iter;
							if (!(_tmp40_ != NULL)) {
								break;
							}
							_tmp41_ = iter;
							_tmp42_ = _tmp41_->type;
							if (_tmp42_ != XML_ELEMENT_NODE) {
								continue;
							}
							_tmp43_ = collection;
							_tmp44_ = font_manager_filter_get_families ((FontManagerFilter*) _tmp43_);
							_tmp45_ = _tmp44_;
							_tmp46_ = iter;
							_tmp47_ = (gchar*) xmlNodeGetContent (_tmp46_);
							_tmp48_ = _tmp47_;
							_tmp49_ = string_strip (_tmp48_);
							_tmp50_ = _tmp49_;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp45_, _tmp50_);
							_g_free0 (_tmp50_);
							_g_free0 (_tmp48_);
						}
					}
				}
				_g_object_unref0 (collection);
				_g_free0 (name);
			}
		}
	}
	_tmp51_ = res;
	xmlXPathFreeObject (_tmp51_);
	_tmp52_ = doc;
	xmlFreeDoc (_tmp52_);
	xmlCleanupParser ();
	result = TRUE;
	_xmlXPathFreeContext0 (ctx);
	return result;
}


FontManagerMigration* font_manager_migration_new (void) {
	FontManagerMigration* self;
	self = g_slice_new0 (FontManagerMigration);
	font_manager_migration_instance_init (self);
	return self;
}


static void font_manager_migration_instance_init (FontManagerMigration * self) {
}


void font_manager_migration_free (FontManagerMigration* self) {
	g_slice_free (FontManagerMigration, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



