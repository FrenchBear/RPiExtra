/* FileSelector.c generated by valac 0.26.1, the Vala compiler
 * generated from FileSelector.vala, do not modify */

/* FileSelector.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gee.h>
#include <gio/gio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_slist_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_ARCHIVE_MANAGER (archive_manager_get_type ())
#define ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManager))
#define ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))
#define IS_ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ARCHIVE_MANAGER))
#define IS_ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ARCHIVE_MANAGER))
#define ARCHIVE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))

typedef struct _ArchiveManager ArchiveManager;
typedef struct _ArchiveManagerClass ArchiveManagerClass;

#define FONT_MANAGER_TYPE_FONT_MODEL (font_manager_font_model_get_type ())
#define FONT_MANAGER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel))
#define FONT_MANAGER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))
#define FONT_MANAGER_IS_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_IS_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))

typedef struct _FontManagerFontModel FontManagerFontModel;
typedef struct _FontManagerFontModelClass FontManagerFontModelClass;

#define FONT_MANAGER_TYPE_USER_FONT_MODEL (font_manager_user_font_model_get_type ())
#define FONT_MANAGER_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel))
#define FONT_MANAGER_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))
#define FONT_MANAGER_IS_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_IS_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_USER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))

typedef struct _FontManagerUserFontModel FontManagerUserFontModel;
typedef struct _FontManagerUserFontModelClass FontManagerUserFontModelClass;
typedef struct _Block9Data Block9Data;

#define FONT_MANAGER_TYPE_USER_FONT_TREE (font_manager_user_font_tree_get_type ())
#define FONT_MANAGER_USER_FONT_TREE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTree))
#define FONT_MANAGER_USER_FONT_TREE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTreeClass))
#define FONT_MANAGER_IS_USER_FONT_TREE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE))
#define FONT_MANAGER_IS_USER_FONT_TREE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_USER_FONT_TREE))
#define FONT_MANAGER_USER_FONT_TREE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_USER_FONT_TREE, FontManagerUserFontTreeClass))

typedef struct _FontManagerUserFontTree FontManagerUserFontTree;
typedef struct _FontManagerUserFontTreeClass FontManagerUserFontTreeClass;

struct _Block9Data {
	int _ref_count_;
	GtkDialog* dialog;
};



gchar** font_manager_file_selector_source_selection (GtkWindow* parent, int* result_length1);
static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value);
static void _g_free0_ (gpointer var);
static void _g_slist_free__g_free0_ (GSList* self);
gchar** font_manager_file_selector_run_install (GtkWindow* parent, int* result_length1);
GType archive_manager_get_type (void) G_GNUC_CONST;
ArchiveManager* archive_manager_new (void);
ArchiveManager* archive_manager_construct (GType object_type);
GeeArrayList* archive_manager_get_supported_types (ArchiveManager* self, const gchar* action);
static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle);
static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value);
GType font_manager_font_model_get_type (void) G_GNUC_CONST;
GType font_manager_user_font_model_get_type (void) G_GNUC_CONST;
GFile** font_manager_file_selector_run_removal (GtkWindow* parent, FontManagerUserFontModel* font_model, int* result_length1);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
GType font_manager_user_font_tree_get_type (void) G_GNUC_CONST;
FontManagerUserFontTree* font_manager_user_font_tree_new (FontManagerUserFontModel* model);
FontManagerUserFontTree* font_manager_user_font_tree_construct (GType object_type, FontManagerUserFontModel* model);
static void __lambda121_ (Block9Data* _data9_);
static void ___lambda121__gtk_button_clicked (GtkButton* _sender, gpointer self);
static void __lambda122_ (Block9Data* _data9_);
static void ___lambda122__gtk_button_clicked (GtkButton* _sender, gpointer self);
GFile** font_manager_user_font_tree_to_file_array (FontManagerUserFontTree* self, int* result_length1);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

extern const gchar* FONT_MANAGER_ARCHIVE_IGNORE_LIST[1];
extern const gchar* FONT_MANAGER_FONT_MIMETYPES[4];

static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_slist_free__g_free0_ (GSList* self) {
	g_slist_foreach (self, (GFunc) _g_free0_, NULL);
	g_slist_free (self);
}


gchar** font_manager_file_selector_source_selection (GtkWindow* parent, int* result_length1) {
	gchar** result = NULL;
	gchar** arr = NULL;
	gchar** _tmp0_ = NULL;
	gint arr_length1 = 0;
	gint _arr_size_ = 0;
	GtkFileChooserDialog* dialog = NULL;
	const gchar* _tmp1_ = NULL;
	GtkWindow* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	GtkFileChooserDialog* _tmp5_ = NULL;
	GtkFileChooserDialog* _tmp6_ = NULL;
	GtkFileChooserDialog* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	GtkFileChooserDialog* _tmp16_ = NULL;
	gchar** _tmp17_ = NULL;
	gint _tmp17__length1 = 0;
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	arr = _tmp0_;
	arr_length1 = 0;
	_arr_size_ = arr_length1;
	_tmp1_ = _ ("Select source folders");
	_tmp2_ = parent;
	_tmp3_ = _ ("_Cancel");
	_tmp4_ = _ ("_Open");
	_tmp5_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_tmp1_, _tmp2_, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _tmp3_, GTK_RESPONSE_CANCEL, _tmp4_, GTK_RESPONSE_ACCEPT, NULL, NULL);
	g_object_ref_sink (_tmp5_);
	dialog = _tmp5_;
	_tmp6_ = dialog;
	gtk_file_chooser_set_select_multiple ((GtkFileChooser*) _tmp6_, TRUE);
	_tmp7_ = dialog;
	_tmp8_ = gtk_dialog_run ((GtkDialog*) _tmp7_);
	if (_tmp8_ == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkFileChooserDialog* _tmp9_ = NULL;
		GtkFileChooserDialog* _tmp10_ = NULL;
		GSList* _tmp11_ = NULL;
		_tmp9_ = dialog;
		gtk_widget_hide ((GtkWidget*) _tmp9_);
		_tmp10_ = dialog;
		_tmp11_ = gtk_file_chooser_get_uris ((GtkFileChooser*) _tmp10_);
		{
			GSList* uri_collection = NULL;
			GSList* uri_it = NULL;
			uri_collection = _tmp11_;
			for (uri_it = uri_collection; uri_it != NULL; uri_it = uri_it->next) {
				gchar* _tmp12_ = NULL;
				gchar* uri = NULL;
				_tmp12_ = g_strdup ((const gchar*) uri_it->data);
				uri = _tmp12_;
				{
					gchar** _tmp13_ = NULL;
					gint _tmp13__length1 = 0;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					_tmp13_ = arr;
					_tmp13__length1 = arr_length1;
					_tmp14_ = uri;
					_tmp15_ = g_strdup (_tmp14_);
					_vala_array_add4 (&arr, &arr_length1, &_arr_size_, _tmp15_);
					_g_free0 (uri);
				}
			}
			__g_slist_free__g_free0_0 (uri_collection);
		}
	}
	_tmp16_ = dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp16_);
	_tmp17_ = arr;
	_tmp17__length1 = arr_length1;
	if (result_length1) {
		*result_length1 = _tmp17__length1;
	}
	result = _tmp17_;
	_g_object_unref0 (dialog);
	return result;
}


static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gchar** font_manager_file_selector_run_install (GtkWindow* parent, int* result_length1) {
	gchar** result = NULL;
	gchar** arr = NULL;
	gchar** _tmp0_ = NULL;
	gint arr_length1 = 0;
	gint _arr_size_ = 0;
	GtkFileChooserDialog* dialog = NULL;
	const gchar* _tmp1_ = NULL;
	GtkWindow* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	GtkFileChooserDialog* _tmp5_ = NULL;
	GtkFileFilter* filter = NULL;
	GtkFileFilter* _tmp6_ = NULL;
	ArchiveManager* archive_manager = NULL;
	ArchiveManager* _tmp7_ = NULL;
	GtkFileChooserDialog* _tmp24_ = NULL;
	GtkFileFilter* _tmp25_ = NULL;
	GtkFileChooserDialog* _tmp26_ = NULL;
	GtkFileChooserDialog* _tmp27_ = NULL;
	gint _tmp28_ = 0;
	GtkFileChooserDialog* _tmp36_ = NULL;
	gchar** _tmp37_ = NULL;
	gint _tmp37__length1 = 0;
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	arr = _tmp0_;
	arr_length1 = 0;
	_arr_size_ = arr_length1;
	_tmp1_ = _ ("Select files to install");
	_tmp2_ = parent;
	_tmp3_ = _ ("_Cancel");
	_tmp4_ = _ ("_Open");
	_tmp5_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_tmp1_, _tmp2_, GTK_FILE_CHOOSER_ACTION_OPEN, _tmp3_, GTK_RESPONSE_CANCEL, _tmp4_, GTK_RESPONSE_ACCEPT, NULL, NULL);
	g_object_ref_sink (_tmp5_);
	dialog = _tmp5_;
	_tmp6_ = gtk_file_filter_new ();
	g_object_ref_sink (_tmp6_);
	filter = _tmp6_;
	_tmp7_ = archive_manager_new ();
	archive_manager = _tmp7_;
	{
		GeeArrayList* _mimetype_list = NULL;
		ArchiveManager* _tmp8_ = NULL;
		GeeArrayList* _tmp9_ = NULL;
		gint _mimetype_size = 0;
		GeeArrayList* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		gint _mimetype_index = 0;
		_tmp8_ = archive_manager;
		_tmp9_ = archive_manager_get_supported_types (_tmp8_, "extract");
		_mimetype_list = _tmp9_;
		_tmp10_ = _mimetype_list;
		_tmp11_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp10_);
		_tmp12_ = _tmp11_;
		_mimetype_size = _tmp12_;
		_mimetype_index = -1;
		while (TRUE) {
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gint _tmp15_ = 0;
			gchar* mimetype = NULL;
			GeeArrayList* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gpointer _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			_tmp13_ = _mimetype_index;
			_mimetype_index = _tmp13_ + 1;
			_tmp14_ = _mimetype_index;
			_tmp15_ = _mimetype_size;
			if (!(_tmp14_ < _tmp15_)) {
				break;
			}
			_tmp16_ = _mimetype_list;
			_tmp17_ = _mimetype_index;
			_tmp18_ = gee_abstract_list_get ((GeeAbstractList*) _tmp16_, _tmp17_);
			mimetype = (gchar*) _tmp18_;
			_tmp19_ = mimetype;
			if (!_vala_string_array_contains (FONT_MANAGER_ARCHIVE_IGNORE_LIST, G_N_ELEMENTS (FONT_MANAGER_ARCHIVE_IGNORE_LIST), _tmp19_)) {
				GtkFileFilter* _tmp20_ = NULL;
				const gchar* _tmp21_ = NULL;
				_tmp20_ = filter;
				_tmp21_ = mimetype;
				gtk_file_filter_add_mime_type (_tmp20_, _tmp21_);
			}
			_g_free0 (mimetype);
		}
		_g_object_unref0 (_mimetype_list);
	}
	{
		const gchar** mimetype_collection = NULL;
		gint mimetype_collection_length1 = 0;
		gint _mimetype_collection_size_ = 0;
		gint mimetype_it = 0;
		mimetype_collection = FONT_MANAGER_FONT_MIMETYPES;
		mimetype_collection_length1 = G_N_ELEMENTS (FONT_MANAGER_FONT_MIMETYPES);
		for (mimetype_it = 0; mimetype_it < G_N_ELEMENTS (FONT_MANAGER_FONT_MIMETYPES); mimetype_it = mimetype_it + 1) {
			const gchar* mimetype = NULL;
			mimetype = mimetype_collection[mimetype_it];
			{
				GtkFileFilter* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				_tmp22_ = filter;
				_tmp23_ = mimetype;
				gtk_file_filter_add_mime_type (_tmp22_, _tmp23_);
			}
		}
	}
	_tmp24_ = dialog;
	_tmp25_ = filter;
	gtk_file_chooser_set_filter ((GtkFileChooser*) _tmp24_, _tmp25_);
	_tmp26_ = dialog;
	gtk_file_chooser_set_select_multiple ((GtkFileChooser*) _tmp26_, TRUE);
	_tmp27_ = dialog;
	_tmp28_ = gtk_dialog_run ((GtkDialog*) _tmp27_);
	if (_tmp28_ == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkFileChooserDialog* _tmp29_ = NULL;
		GtkFileChooserDialog* _tmp30_ = NULL;
		GSList* _tmp31_ = NULL;
		_tmp29_ = dialog;
		gtk_widget_hide ((GtkWidget*) _tmp29_);
		_tmp30_ = dialog;
		_tmp31_ = gtk_file_chooser_get_uris ((GtkFileChooser*) _tmp30_);
		{
			GSList* uri_collection = NULL;
			GSList* uri_it = NULL;
			uri_collection = _tmp31_;
			for (uri_it = uri_collection; uri_it != NULL; uri_it = uri_it->next) {
				gchar* _tmp32_ = NULL;
				gchar* uri = NULL;
				_tmp32_ = g_strdup ((const gchar*) uri_it->data);
				uri = _tmp32_;
				{
					gchar** _tmp33_ = NULL;
					gint _tmp33__length1 = 0;
					const gchar* _tmp34_ = NULL;
					gchar* _tmp35_ = NULL;
					_tmp33_ = arr;
					_tmp33__length1 = arr_length1;
					_tmp34_ = uri;
					_tmp35_ = g_strdup (_tmp34_);
					_vala_array_add5 (&arr, &arr_length1, &_arr_size_, _tmp35_);
					_g_free0 (uri);
				}
			}
			__g_slist_free__g_free0_0 (uri_collection);
		}
	}
	_tmp36_ = dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp36_);
	_tmp37_ = arr;
	_tmp37__length1 = arr_length1;
	if (result_length1) {
		*result_length1 = _tmp37__length1;
	}
	result = _tmp37_;
	_g_object_unref0 (archive_manager);
	_g_object_unref0 (filter);
	_g_object_unref0 (dialog);
	return result;
}


static Block9Data* block9_data_ref (Block9Data* _data9_) {
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}


static void block9_data_unref (void * _userdata_) {
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		_g_object_unref0 (_data9_->dialog);
		g_slice_free (Block9Data, _data9_);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda121_ (Block9Data* _data9_) {
	GtkDialog* _tmp0_ = NULL;
	_tmp0_ = _data9_->dialog;
	gtk_dialog_response (_tmp0_, (gint) GTK_RESPONSE_CANCEL);
}


static void ___lambda121__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda121_ (self);
}


static void __lambda122_ (Block9Data* _data9_) {
	GtkDialog* _tmp0_ = NULL;
	_tmp0_ = _data9_->dialog;
	gtk_dialog_response (_tmp0_, (gint) GTK_RESPONSE_ACCEPT);
}


static void ___lambda122__gtk_button_clicked (GtkButton* _sender, gpointer self) {
	__lambda122_ (self);
}


GFile** font_manager_file_selector_run_removal (GtkWindow* parent, FontManagerUserFontModel* font_model, int* result_length1) {
	GFile** result = NULL;
	Block9Data* _data9_;
	GFile** res = NULL;
	gint res_length1 = 0;
	gint _res_size_ = 0;
	GtkDialog* _tmp0_ = NULL;
	GtkButton* cancel = NULL;
	const gchar* _tmp1_ = NULL;
	GtkButton* _tmp2_ = NULL;
	GtkButton* remove = NULL;
	const gchar* _tmp3_ = NULL;
	GtkButton* _tmp4_ = NULL;
	GtkHeaderBar* header = NULL;
	GtkHeaderBar* _tmp5_ = NULL;
	GtkBox* content_area = NULL;
	GtkDialog* _tmp6_ = NULL;
	GtkBox* _tmp7_ = NULL;
	GtkBox* _tmp8_ = NULL;
	GtkScrolledWindow* scroll = NULL;
	GtkScrolledWindow* _tmp9_ = NULL;
	FontManagerUserFontTree* tree = NULL;
	FontManagerUserFontModel* _tmp10_ = NULL;
	FontManagerUserFontTree* _tmp11_ = NULL;
	GtkHeaderBar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	GtkHeaderBar* _tmp14_ = NULL;
	GtkButton* _tmp15_ = NULL;
	GtkHeaderBar* _tmp16_ = NULL;
	GtkButton* _tmp17_ = NULL;
	GtkDialog* _tmp18_ = NULL;
	GtkHeaderBar* _tmp19_ = NULL;
	GtkDialog* _tmp20_ = NULL;
	GtkDialog* _tmp21_ = NULL;
	GtkDialog* _tmp22_ = NULL;
	GtkDialog* _tmp23_ = NULL;
	GtkWindow* _tmp24_ = NULL;
	FontManagerUserFontTree* _tmp25_ = NULL;
	GtkScrolledWindow* _tmp26_ = NULL;
	FontManagerUserFontTree* _tmp27_ = NULL;
	GtkBox* _tmp28_ = NULL;
	GtkScrolledWindow* _tmp29_ = NULL;
	GtkScrolledWindow* _tmp30_ = NULL;
	GtkHeaderBar* _tmp31_ = NULL;
	GtkButton* _tmp32_ = NULL;
	GtkButton* _tmp33_ = NULL;
	GtkDialog* _tmp34_ = NULL;
	gint _tmp35_ = 0;
	GtkDialog* _tmp40_ = NULL;
	GFile** _tmp41_ = NULL;
	gint _tmp41__length1 = 0;
	g_return_val_if_fail (font_model != NULL, NULL);
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	res = NULL;
	res_length1 = 0;
	_res_size_ = res_length1;
	_tmp0_ = (GtkDialog*) gtk_dialog_new ();
	g_object_ref_sink (_tmp0_);
	_data9_->dialog = _tmp0_;
	_tmp1_ = _ ("_Cancel");
	_tmp2_ = (GtkButton*) gtk_button_new_with_mnemonic (_tmp1_);
	g_object_ref_sink (_tmp2_);
	cancel = _tmp2_;
	_tmp3_ = _ ("_Delete");
	_tmp4_ = (GtkButton*) gtk_button_new_with_mnemonic (_tmp3_);
	g_object_ref_sink (_tmp4_);
	remove = _tmp4_;
	_tmp5_ = (GtkHeaderBar*) gtk_header_bar_new ();
	g_object_ref_sink (_tmp5_);
	header = _tmp5_;
	_tmp6_ = _data9_->dialog;
	_tmp7_ = (GtkBox*) gtk_dialog_get_content_area (_tmp6_);
	_tmp8_ = _g_object_ref0 (_tmp7_);
	content_area = _tmp8_;
	_tmp9_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp9_);
	scroll = _tmp9_;
	_tmp10_ = font_model;
	_tmp11_ = font_manager_user_font_tree_new (_tmp10_);
	g_object_ref_sink (_tmp11_);
	tree = _tmp11_;
	_tmp12_ = header;
	_tmp13_ = _ ("Select fonts to remove");
	gtk_header_bar_set_title (_tmp12_, _tmp13_);
	_tmp14_ = header;
	_tmp15_ = cancel;
	gtk_header_bar_pack_start (_tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = header;
	_tmp17_ = remove;
	gtk_header_bar_pack_end (_tmp16_, (GtkWidget*) _tmp17_);
	_tmp18_ = _data9_->dialog;
	_tmp19_ = header;
	gtk_window_set_titlebar ((GtkWindow*) _tmp18_, (GtkWidget*) _tmp19_);
	_tmp20_ = _data9_->dialog;
	gtk_window_set_modal ((GtkWindow*) _tmp20_, TRUE);
	_tmp21_ = _data9_->dialog;
	gtk_window_set_destroy_with_parent ((GtkWindow*) _tmp21_, TRUE);
	_tmp22_ = _data9_->dialog;
	gtk_widget_set_size_request ((GtkWidget*) _tmp22_, 540, 480);
	_tmp23_ = _data9_->dialog;
	_tmp24_ = parent;
	gtk_window_set_transient_for ((GtkWindow*) _tmp23_, _tmp24_);
	_tmp25_ = tree;
	g_object_set ((GtkWidget*) _tmp25_, "expand", TRUE, NULL);
	_tmp26_ = scroll;
	_tmp27_ = tree;
	gtk_container_add ((GtkContainer*) _tmp26_, (GtkWidget*) _tmp27_);
	_tmp28_ = content_area;
	_tmp29_ = scroll;
	gtk_box_pack_start (_tmp28_, (GtkWidget*) _tmp29_, TRUE, TRUE, (guint) 0);
	_tmp30_ = scroll;
	gtk_widget_show_all ((GtkWidget*) _tmp30_);
	_tmp31_ = header;
	gtk_widget_show_all ((GtkWidget*) _tmp31_);
	_tmp32_ = cancel;
	g_signal_connect_data (_tmp32_, "clicked", (GCallback) ___lambda121__gtk_button_clicked, block9_data_ref (_data9_), (GClosureNotify) block9_data_unref, 0);
	_tmp33_ = remove;
	g_signal_connect_data (_tmp33_, "clicked", (GCallback) ___lambda122__gtk_button_clicked, block9_data_ref (_data9_), (GClosureNotify) block9_data_unref, 0);
	_tmp34_ = _data9_->dialog;
	_tmp35_ = gtk_dialog_run (_tmp34_);
	if (_tmp35_ == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkDialog* _tmp36_ = NULL;
		FontManagerUserFontTree* _tmp37_ = NULL;
		gint _tmp38_ = 0;
		GFile** _tmp39_ = NULL;
		_tmp36_ = _data9_->dialog;
		gtk_widget_hide ((GtkWidget*) _tmp36_);
		_tmp37_ = tree;
		_tmp39_ = font_manager_user_font_tree_to_file_array (_tmp37_, &_tmp38_);
		res = (_vala_array_free (res, res_length1, (GDestroyNotify) g_object_unref), NULL);
		res = _tmp39_;
		res_length1 = _tmp38_;
		_res_size_ = res_length1;
	}
	_tmp40_ = _data9_->dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp40_);
	_tmp41_ = res;
	_tmp41__length1 = res_length1;
	if (result_length1) {
		*result_length1 = _tmp41__length1;
	}
	result = _tmp41_;
	_g_object_unref0 (tree);
	_g_object_unref0 (scroll);
	_g_object_unref0 (content_area);
	_g_object_unref0 (header);
	_g_object_unref0 (remove);
	_g_object_unref0 (cancel);
	block9_data_unref (_data9_);
	_data9_ = NULL;
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



