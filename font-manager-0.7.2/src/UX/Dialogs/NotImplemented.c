/* NotImplemented.c generated by valac 0.26.1, the Vala compiler
 * generated from NotImplemented.vala, do not modify */

/* NotImplemented.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>

typedef struct _Block11Data Block11Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Block11Data {
	int _ref_count_;
	GtkMessageDialog* ni;
};


extern GtkWindow* font_manager_not_implemented_parent;
GtkWindow* font_manager_not_implemented_parent = NULL;

void font_manager_not_implemented_run (const gchar* message);
static Block11Data* block11_data_ref (Block11Data* _data11_);
static void block11_data_unref (void * _userdata_);
static void __lambda63_ (Block11Data* _data11_, gint i);
static void ___lambda63__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static void __lambda64_ (Block11Data* _data11_);
static void ___lambda64__gtk_dialog_close (GtkDialog* _sender, gpointer self);


static Block11Data* block11_data_ref (Block11Data* _data11_) {
	g_atomic_int_inc (&_data11_->_ref_count_);
	return _data11_;
}


static void block11_data_unref (void * _userdata_) {
	Block11Data* _data11_;
	_data11_ = (Block11Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data11_->_ref_count_)) {
		_g_object_unref0 (_data11_->ni);
		g_slice_free (Block11Data, _data11_);
	}
}


static void __lambda63_ (Block11Data* _data11_, gint i) {
	gtk_widget_destroy ((GtkWidget*) _data11_->ni);
}


static void ___lambda63__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda63_ (self, response_id);
}


static void __lambda64_ (Block11Data* _data11_) {
	gtk_widget_destroy ((GtkWidget*) _data11_->ni);
}


static void ___lambda64__gtk_dialog_close (GtkDialog* _sender, gpointer self) {
	__lambda64_ (self);
}


void font_manager_not_implemented_run (const gchar* message) {
	Block11Data* _data11_;
	GtkWindow* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GtkMessageDialog* _tmp4_ = NULL;
	GtkMessageDialog* _tmp5_ = NULL;
	GtkWindow* _tmp6_ = NULL;
	_data11_ = g_slice_new0 (Block11Data);
	_data11_->_ref_count_ = 1;
	_tmp0_ = font_manager_not_implemented_parent;
	_tmp1_ = message;
	_tmp2_ = g_markup_escape_text (_tmp1_, (gssize) (-1));
	_tmp3_ = _tmp2_;
	_tmp4_ = (GtkMessageDialog*) gtk_message_dialog_new_with_markup (_tmp0_, GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_CLOSE, "%s has not been implemented yet.", _tmp3_);
	g_object_ref_sink (_tmp4_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	_data11_->ni = _tmp5_;
	g_signal_connect_data ((GtkDialog*) _data11_->ni, "response", (GCallback) ___lambda63__gtk_dialog_response, block11_data_ref (_data11_), (GClosureNotify) block11_data_unref, 0);
	g_signal_connect_data ((GtkDialog*) _data11_->ni, "close", (GCallback) ___lambda64__gtk_dialog_close, block11_data_ref (_data11_), (GClosureNotify) block11_data_unref, 0);
	_tmp6_ = font_manager_not_implemented_parent;
	gtk_window_set_transient_for ((GtkWindow*) _data11_->ni, _tmp6_);
	gtk_dialog_run ((GtkDialog*) _data11_->ni);
	block11_data_unref (_data11_);
	_data11_ = NULL;
	return;
}



