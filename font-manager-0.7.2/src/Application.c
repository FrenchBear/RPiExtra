/* Application.c generated by valac 0.26.1, the Vala compiler
 * generated from Application.vala, do not modify */

/* Application.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <string.h>


#define FONT_MANAGER_TYPE_APPLICATION (font_manager_application_get_type ())
#define FONT_MANAGER_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplication))
#define FONT_MANAGER_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplicationClass))
#define FONT_MANAGER_IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_APPLICATION))
#define FONT_MANAGER_IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_APPLICATION))
#define FONT_MANAGER_APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplicationClass))

typedef struct _FontManagerApplication FontManagerApplication;
typedef struct _FontManagerApplicationClass FontManagerApplicationClass;
typedef struct _FontManagerApplicationPrivate FontManagerApplicationPrivate;

#define FONT_MANAGER_TYPE_MAIN_WINDOW (font_manager_main_window_get_type ())
#define FONT_MANAGER_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindow))
#define FONT_MANAGER_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindowClass))
#define FONT_MANAGER_IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW))
#define FONT_MANAGER_IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_MAIN_WINDOW))
#define FONT_MANAGER_MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_MAIN_WINDOW, FontManagerMainWindowClass))

typedef struct _FontManagerMainWindow FontManagerMainWindow;
typedef struct _FontManagerMainWindowClass FontManagerMainWindowClass;

#define FONT_MANAGER_TYPE_VIEWER (font_manager_viewer_get_type ())
#define FONT_MANAGER_VIEWER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_VIEWER, FontManagerViewer))
#define FONT_MANAGER_VIEWER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_VIEWER, FontManagerViewerClass))
#define FONT_MANAGER_IS_VIEWER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_VIEWER))
#define FONT_MANAGER_IS_VIEWER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_VIEWER))
#define FONT_MANAGER_VIEWER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_VIEWER, FontManagerViewerClass))

typedef struct _FontManagerViewer FontManagerViewer;
typedef struct _FontManagerViewerClass FontManagerViewerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FONT_MANAGER_TYPE_FONT_DATA (font_manager_font_data_get_type ())

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_CONFIG_TYPE_FONT (font_config_font_get_type ())
#define FONT_CONFIG_FONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFont))
#define FONT_CONFIG_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))
#define FONT_CONFIG_IS_FONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_FONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))

typedef struct _FontConfigFont FontConfigFont;
typedef struct _FontConfigFontClass FontConfigFontClass;

#define FONT_MANAGER_TYPE_FONT_INFO (font_manager_font_info_get_type ())
#define FONT_MANAGER_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfo))
#define FONT_MANAGER_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))
#define FONT_MANAGER_IS_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_IS_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_FONT_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))

typedef struct _FontManagerFontInfo FontManagerFontInfo;
typedef struct _FontManagerFontInfoClass FontManagerFontInfoClass;
typedef struct _FontManagerFontData FontManagerFontData;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_variant_dict_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_dict_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_LOG_LEVEL (log_level_get_type ())

#define FONT_MANAGER_TYPE_MAIN (font_manager_main_get_type ())
#define FONT_MANAGER_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_MAIN, FontManagerMain))
#define FONT_MANAGER_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_MAIN, FontManagerMainClass))
#define FONT_MANAGER_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_MAIN))
#define FONT_MANAGER_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_MAIN))
#define FONT_MANAGER_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_MAIN, FontManagerMainClass))

typedef struct _FontManagerMain FontManagerMain;
typedef struct _FontManagerMainClass FontManagerMainClass;

struct _FontManagerApplication {
	GtkApplication parent_instance;
	FontManagerApplicationPrivate * priv;
};

struct _FontManagerApplicationClass {
	GtkApplicationClass parent_class;
};

struct _FontManagerApplicationPrivate {
	FontManagerMainWindow* _main_window;
	GtkBuilder* _builder;
	guint fv_dbus_id;
	FontManagerViewer* fv;
};

struct _FontManagerFontData {
	GFile* file;
	FontConfigFont* font;
	FontManagerFontInfo* fontinfo;
};

typedef enum  {
	LOG_LEVEL_VERBOSE,
	LOG_LEVEL_DEBUG,
	LOG_LEVEL_INFO,
	LOG_LEVEL_NOTIFY,
	LOG_LEVEL_WARN,
	LOG_LEVEL_ERROR,
	LOG_LEVEL_FATAL
} LogLevel;


static gpointer font_manager_application_parent_class = NULL;

GType font_manager_application_get_type (void) G_GNUC_CONST;
guint font_manager_application_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType font_manager_main_window_get_type (void) G_GNUC_CONST;
GType font_manager_viewer_get_type (void) G_GNUC_CONST;
guint font_manager_viewer_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
#define FONT_MANAGER_APPLICATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_TYPE_APPLICATION, FontManagerApplicationPrivate))
enum  {
	FONT_MANAGER_APPLICATION_DUMMY_PROPERTY,
	FONT_MANAGER_APPLICATION_MAIN_WINDOW,
	FONT_MANAGER_APPLICATION_BUILDER,
	FONT_MANAGER_APPLICATION_FONT_VIEWER
};
FontManagerApplication* font_manager_application_new (const gchar* app_id, GApplicationFlags app_flags);
FontManagerApplication* font_manager_application_construct (GType object_type, const gchar* app_id, GApplicationFlags app_flags);
static void font_manager_application_real_startup (GApplication* base);
void logging_show_version_information (void);
static void font_manager_application_real_open (GApplication* base, GFile** files, int files_length1, const gchar* hint);
FontManagerViewer* font_manager_application_get_font_viewer (FontManagerApplication* self);
GType font_manager_font_data_get_type (void) G_GNUC_CONST;
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_config_font_get_type (void) G_GNUC_CONST;
GType font_manager_font_info_get_type (void) G_GNUC_CONST;
FontManagerFontData* font_manager_font_data_dup (const FontManagerFontData* self);
void font_manager_font_data_free (FontManagerFontData* self);
void font_manager_font_data_copy (const FontManagerFontData* self, FontManagerFontData* dest);
void font_manager_font_data_destroy (FontManagerFontData* self);
void font_manager_font_data_init (FontManagerFontData *self, GFile* file, const gchar* rmdir);
void font_manager_viewer_set_fontdata (FontManagerViewer* self, FontManagerFontData* value);
void font_manager_application_install (FontManagerApplication* self, GFile** files, int files_length1);
void font_manager_library_install_from_file_array (GFile** files, int files_length1);
static GFile** font_manager_application_get_command_line_files (FontManagerApplication* self, GApplicationCommandLine* cl, int* result_length1);
static void _vala_array_add1 (GFile*** array, int* length, int* size, GFile* value);
static gint font_manager_application_real_command_line (GApplication* base, GApplicationCommandLine* cl);
static gint font_manager_application_real_handle_local_options (GApplication* base, GVariantDict* options);
void font_manager_show_about (void);
void font_manager_show_version (void);
GType log_level_get_type (void) G_GNUC_CONST;
LogLevel logger_get_DisplayLevel (void);
void logger_set_DisplayLevel (LogLevel value);
static gboolean font_manager_application_real_dbus_register (GApplication* base, GDBusConnection* conn, const gchar* path, GError** error);
static void font_manager_application_real_dbus_unregister (GApplication* base, GDBusConnection* conn, const gchar* path);
static void font_manager_application_real_activate (GApplication* base);
void font_manager_application_set_builder (FontManagerApplication* self, GtkBuilder* value);
void font_manager_set_g_app_menu (GtkApplication* app, GtkBuilder* builder);
GtkBuilder* font_manager_application_get_builder (FontManagerApplication* self);
GType font_manager_main_get_type (void) G_GNUC_CONST;
FontManagerMain* font_manager_main_get_instance (void);
void font_manager_main_on_activate (FontManagerMain* self);
void font_manager_application_quit (FontManagerApplication* self);
GSettings* font_manager_main_get_settings (FontManagerMain* self);
FontManagerMainWindow* font_manager_application_get_main_window (FontManagerApplication* self);
void font_manager_application_set_main_window (FontManagerApplication* self, FontManagerMainWindow* value);
void font_manager_application_about (FontManagerApplication* self);
void font_manager_show_about_dialog (GtkWindow* parent);
void font_manager_application_help (FontManagerApplication* self);
void font_manager_show_help_dialog (void);
gint font_manager_application_main (gchar** args, int args_length1);
#define FONT_MANAGER_ABOUT_NAME _ ("Font Manager")
gboolean font_config_enable_user_config (gboolean enable);
void logging_setup (LogLevel level);
void intl_setup (const gchar* name);
#define FONT_MANAGER_NAME "font-manager"
void font_manager_set_application_style (void);
gboolean font_manager_update_declined (void);
#define FONT_MANAGER_SCHEMA_ID "org.gnome.FontManager"
#define FONT_MANAGER_BUS_ID FONT_MANAGER_SCHEMA_ID
FontManagerViewer* font_manager_viewer_new (void);
FontManagerViewer* font_manager_viewer_construct (GType object_type);
static void font_manager_application_finalize (GObject* obj);
static void _vala_font_manager_application_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_manager_application_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _dbus_font_manager_application_quit (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_font_manager_application_about (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_font_manager_application_help (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void font_manager_application_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* font_manager_application_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean font_manager_application_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _font_manager_application_unregister_object (gpointer user_data);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GOptionEntry FONT_MANAGER_APPLICATION_options[7] = {{"about", 'a', 0, G_OPTION_ARG_NONE, NULL, "About the application", NULL}, {"version", 'v', 0, G_OPTION_ARG_NONE, NULL, "Show application version", NULL}, {"install", 'i', 0, G_OPTION_ARG_NONE, NULL, "Space separated list of files to install.", NULL}, {"debug", 'd', 0, G_OPTION_ARG_NONE, NULL, "Enable logging. Fatal errors.", NULL}, {"verbose", 'V', 0, G_OPTION_ARG_NONE, NULL, "Verbose logging. Lots of output.", NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, NULL, NULL, NULL}, {NULL}};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_quit_in[] = {NULL};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_quit_out[] = {NULL};
static const GDBusMethodInfo _font_manager_application_dbus_method_info_quit = {-1, "Quit", (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_quit_in), (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_quit_out)};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_about_in[] = {NULL};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_about_out[] = {NULL};
static const GDBusMethodInfo _font_manager_application_dbus_method_info_about = {-1, "About", (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_about_in), (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_about_out)};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_help_in[] = {NULL};
static const GDBusArgInfo * const _font_manager_application_dbus_arg_info_help_out[] = {NULL};
static const GDBusMethodInfo _font_manager_application_dbus_method_info_help = {-1, "Help", (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_help_in), (GDBusArgInfo **) (&_font_manager_application_dbus_arg_info_help_out)};
static const GDBusMethodInfo * const _font_manager_application_dbus_method_info[] = {&_font_manager_application_dbus_method_info_quit, &_font_manager_application_dbus_method_info_about, &_font_manager_application_dbus_method_info_help, NULL};
static const GDBusSignalInfo * const _font_manager_application_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _font_manager_application_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _font_manager_application_dbus_interface_info = {-1, "org.gnome.FontManager", (GDBusMethodInfo **) (&_font_manager_application_dbus_method_info), (GDBusSignalInfo **) (&_font_manager_application_dbus_signal_info), (GDBusPropertyInfo **) (&_font_manager_application_dbus_property_info)};
static const GDBusInterfaceVTable _font_manager_application_dbus_interface_vtable = {font_manager_application_dbus_interface_method_call, font_manager_application_dbus_interface_get_property, font_manager_application_dbus_interface_set_property};

FontManagerApplication* font_manager_application_construct (GType object_type, const gchar* app_id, GApplicationFlags app_flags) {
	FontManagerApplication * self = NULL;
	const gchar* _tmp0_ = NULL;
	GApplicationFlags _tmp1_ = 0;
	g_return_val_if_fail (app_id != NULL, NULL);
	_tmp0_ = app_id;
	_tmp1_ = app_flags;
	self = (FontManagerApplication*) g_object_new (object_type, "application-id", _tmp0_, "flags", _tmp1_, NULL);
	g_application_add_main_option_entries ((GApplication*) self, FONT_MANAGER_APPLICATION_options);
	return self;
}


FontManagerApplication* font_manager_application_new (const gchar* app_id, GApplicationFlags app_flags) {
	return font_manager_application_construct (FONT_MANAGER_TYPE_APPLICATION, app_id, app_flags);
}


static void font_manager_application_real_startup (GApplication* base) {
	FontManagerApplication * self;
	self = (FontManagerApplication*) base;
	G_APPLICATION_CLASS (font_manager_application_parent_class)->startup ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
	logging_show_version_information ();
	return;
}


static void font_manager_application_real_open (GApplication* base, GFile** files, int files_length1, const gchar* hint) {
	FontManagerApplication * self;
	FontManagerViewer* _tmp0_ = NULL;
	FontManagerViewer* _tmp1_ = NULL;
	GFile** _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	GFile* _tmp3_ = NULL;
	FontManagerFontData _tmp4_ = {0};
	FontManagerFontData _tmp5_ = {0};
	FontManagerFontData _tmp6_ = {0};
	FontManagerViewer* _tmp7_ = NULL;
	FontManagerViewer* _tmp8_ = NULL;
	self = (FontManagerApplication*) base;
	g_return_if_fail (hint != NULL);
	_tmp0_ = font_manager_application_get_font_viewer (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = files;
	_tmp2__length1 = files_length1;
	_tmp3_ = _tmp2_[0];
	font_manager_font_data_init (&_tmp4_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = _tmp5_;
	font_manager_viewer_set_fontdata (_tmp1_, &_tmp6_);
	font_manager_font_data_destroy (&_tmp5_);
	_tmp7_ = font_manager_application_get_font_viewer (self);
	_tmp8_ = _tmp7_;
	gtk_widget_show ((GtkWidget*) _tmp8_);
	return;
}


void font_manager_application_install (FontManagerApplication* self, GFile** files, int files_length1) {
	GFile** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = files;
	_tmp0__length1 = files_length1;
	font_manager_library_install_from_file_array (_tmp0_, _tmp0__length1);
	return;
}


static gpointer _g_variant_dict_ref0 (gpointer self) {
	return self ? g_variant_dict_ref (self) : NULL;
}


static void _vala_array_add1 (GFile*** array, int* length, int* size, GFile* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GFile*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static GFile** font_manager_application_get_command_line_files (FontManagerApplication* self, GApplicationCommandLine* cl, int* result_length1) {
	GFile** result = NULL;
	GVariantDict* options = NULL;
	GApplicationCommandLine* _tmp0_ = NULL;
	GVariantDict* _tmp1_ = NULL;
	GVariantDict* _tmp2_ = NULL;
	GVariant* argv = NULL;
	GVariantDict* _tmp3_ = NULL;
	const GVariantType* _tmp4_ = NULL;
	GVariant* _tmp5_ = NULL;
	GVariant* _tmp6_ = NULL;
	const gchar** filelist = NULL;
	GVariant* _tmp8_ = NULL;
	size_t _tmp9_;
	const gchar** _tmp10_ = NULL;
	gint filelist_length1 = 0;
	gint _filelist_size_ = 0;
	const gchar** _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	GFile** files = NULL;
	gint files_length1 = 0;
	gint _files_size_ = 0;
	const gchar** _tmp13_ = NULL;
	gint _tmp13__length1 = 0;
	GFile** _tmp18_ = NULL;
	gint _tmp18__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cl != NULL, NULL);
	_tmp0_ = cl;
	_tmp1_ = g_application_command_line_get_options_dict (_tmp0_);
	_tmp2_ = _g_variant_dict_ref0 (_tmp1_);
	options = _tmp2_;
	_tmp3_ = options;
	_tmp4_ = G_VARIANT_TYPE_BYTESTRING_ARRAY;
	_tmp5_ = g_variant_dict_lookup_value (_tmp3_, "", _tmp4_);
	argv = _tmp5_;
	_tmp6_ = argv;
	if (_tmp6_ == NULL) {
		GFile** _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		_tmp7_ = NULL;
		_tmp7__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp7__length1;
		}
		result = _tmp7_;
		_g_variant_unref0 (argv);
		_g_variant_dict_unref0 (options);
		return result;
	}
	_tmp8_ = argv;
	_tmp10_ = g_variant_get_bytestring_array (_tmp8_, &_tmp9_);
	filelist = _tmp10_;
	filelist_length1 = _tmp9_;
	_filelist_size_ = filelist_length1;
	_tmp11_ = filelist;
	_tmp11__length1 = filelist_length1;
	if (_tmp11__length1 == 0) {
		GFile** _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		_tmp12_ = NULL;
		_tmp12__length1 = 0;
		if (result_length1) {
			*result_length1 = _tmp12__length1;
		}
		result = _tmp12_;
		filelist = (g_free (filelist), NULL);
		_g_variant_unref0 (argv);
		_g_variant_dict_unref0 (options);
		return result;
	}
	files = NULL;
	files_length1 = 0;
	_files_size_ = files_length1;
	_tmp13_ = filelist;
	_tmp13__length1 = filelist_length1;
	{
		const gchar** file_collection = NULL;
		gint file_collection_length1 = 0;
		gint _file_collection_size_ = 0;
		gint file_it = 0;
		file_collection = _tmp13_;
		file_collection_length1 = _tmp13__length1;
		for (file_it = 0; file_it < _tmp13__length1; file_it = file_it + 1) {
			const gchar* file = NULL;
			file = file_collection[file_it];
			{
				GFile** _tmp14_ = NULL;
				gint _tmp14__length1 = 0;
				GApplicationCommandLine* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				GFile* _tmp17_ = NULL;
				_tmp14_ = files;
				_tmp14__length1 = files_length1;
				_tmp15_ = cl;
				_tmp16_ = file;
				_tmp17_ = g_application_command_line_create_file_for_arg (_tmp15_, _tmp16_);
				_vala_array_add1 (&files, &files_length1, &_files_size_, _tmp17_);
			}
		}
	}
	_tmp18_ = files;
	_tmp18__length1 = files_length1;
	if (result_length1) {
		*result_length1 = _tmp18__length1;
	}
	result = _tmp18_;
	filelist = (g_free (filelist), NULL);
	_g_variant_unref0 (argv);
	_g_variant_dict_unref0 (options);
	return result;
}


static gint font_manager_application_real_command_line (GApplication* base, GApplicationCommandLine* cl) {
	FontManagerApplication * self;
	gint result = 0;
	GVariantDict* options = NULL;
	GApplicationCommandLine* _tmp0_ = NULL;
	GVariantDict* _tmp1_ = NULL;
	GVariantDict* _tmp2_ = NULL;
	GFile** filelist = NULL;
	GApplicationCommandLine* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	GFile** _tmp5_ = NULL;
	gint filelist_length1 = 0;
	gint _filelist_size_ = 0;
	GFile** _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	GError * _inner_error_ = NULL;
	self = (FontManagerApplication*) base;
	g_return_val_if_fail (cl != NULL, 0);
	g_application_hold ((GApplication*) self);
	_tmp0_ = cl;
	_tmp1_ = g_application_command_line_get_options_dict (_tmp0_);
	_tmp2_ = _g_variant_dict_ref0 (_tmp1_);
	options = _tmp2_;
	_tmp3_ = cl;
	_tmp5_ = font_manager_application_get_command_line_files (self, _tmp3_, &_tmp4_);
	filelist = _tmp5_;
	filelist_length1 = _tmp4_;
	_filelist_size_ = filelist_length1;
	_tmp6_ = filelist;
	_tmp6__length1 = filelist_length1;
	if (_tmp6_ == NULL) {
		g_application_release ((GApplication*) self);
		g_application_activate ((GApplication*) self);
		result = 0;
		filelist = (_vala_array_free (filelist, filelist_length1, (GDestroyNotify) g_object_unref), NULL);
		_g_variant_dict_unref0 (options);
		return result;
	} else {
		GVariantDict* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = options;
		_tmp8_ = g_variant_dict_contains (_tmp7_, "install");
		if (_tmp8_) {
			GFile** _tmp9_ = NULL;
			gint _tmp9__length1 = 0;
			_tmp9_ = filelist;
			_tmp9__length1 = filelist_length1;
			font_manager_application_install (self, _tmp9_, _tmp9__length1);
		} else {
			GFile** _tmp12_ = NULL;
			gint _tmp12__length1 = 0;
			{
				g_application_register ((GApplication*) self, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch0_g_error;
				}
			}
			goto __finally0;
			__catch0_g_error:
			{
				GError* e = NULL;
				GError* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp10_ = e;
				_tmp11_ = _tmp10_->message;
				g_critical ("Application.vala:106: %s", _tmp11_);
				_g_error_free0 (e);
			}
			__finally0:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				filelist = (_vala_array_free (filelist, filelist_length1, (GDestroyNotify) g_object_unref), NULL);
				_g_variant_dict_unref0 (options);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
			_tmp12_ = filelist;
			_tmp12__length1 = filelist_length1;
			g_application_open ((GApplication*) self, _tmp12_, _tmp12__length1, "");
		}
	}
	g_application_release ((GApplication*) self);
	result = 0;
	filelist = (_vala_array_free (filelist, filelist_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_variant_dict_unref0 (options);
	return result;
}


static gint font_manager_application_real_handle_local_options (GApplication* base, GVariantDict* options) {
	FontManagerApplication * self;
	gint result = 0;
	gint exit_status = 0;
	GVariantDict* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GVariantDict* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GVariantDict* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GVariantDict* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	self = (FontManagerApplication*) base;
	g_return_val_if_fail (options != NULL, 0);
	exit_status = -1;
	_tmp0_ = options;
	_tmp1_ = g_variant_dict_contains (_tmp0_, "about");
	if (_tmp1_) {
		font_manager_show_about ();
		exit_status = 0;
	}
	_tmp2_ = options;
	_tmp3_ = g_variant_dict_contains (_tmp2_, "version");
	if (_tmp3_) {
		font_manager_show_version ();
		exit_status = 0;
	}
	_tmp4_ = options;
	_tmp5_ = g_variant_dict_contains (_tmp4_, "debug");
	if (_tmp5_) {
		LogLevel _tmp6_ = 0;
		LogLevel _tmp7_ = 0;
		_tmp6_ = logger_get_DisplayLevel ();
		_tmp7_ = _tmp6_;
		logger_set_DisplayLevel (LOG_LEVEL_DEBUG);
		g_log_set_always_fatal (G_LOG_LEVEL_CRITICAL);
	}
	_tmp8_ = options;
	_tmp9_ = g_variant_dict_contains (_tmp8_, "verbose");
	if (_tmp9_) {
		LogLevel _tmp10_ = 0;
		LogLevel _tmp11_ = 0;
		_tmp10_ = logger_get_DisplayLevel ();
		_tmp11_ = _tmp10_;
		logger_set_DisplayLevel (LOG_LEVEL_VERBOSE);
	}
	result = exit_status;
	return result;
}


static gboolean font_manager_application_real_dbus_register (GApplication* base, GDBusConnection* conn, const gchar* path, GError** error) {
	FontManagerApplication * self;
	gboolean result = FALSE;
	GDBusConnection* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	GDBusConnection* _tmp3_ = NULL;
	FontManagerViewer* _tmp4_ = NULL;
	FontManagerViewer* _tmp5_ = NULL;
	guint _tmp6_ = 0U;
	guint _tmp7_ = 0U;
	GError * _inner_error_ = NULL;
	self = (FontManagerApplication*) base;
	g_return_val_if_fail (conn != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	_tmp0_ = conn;
	_tmp1_ = path;
	G_APPLICATION_CLASS (font_manager_application_parent_class)->dbus_register ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication), _tmp0_, _tmp1_, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	}
	_tmp3_ = conn;
	_tmp4_ = font_manager_application_get_font_viewer (self);
	_tmp5_ = _tmp4_;
	_tmp6_ = font_manager_viewer_register_object (_tmp5_, _tmp3_, "/org/gnome/FontManager/FontViewer", &_inner_error_);
	_tmp2_ = _tmp6_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	}
	self->priv->fv_dbus_id = _tmp2_;
	_tmp7_ = self->priv->fv_dbus_id;
	if (_tmp7_ == ((guint) 0)) {
		g_critical ("Application.vala:143: Could not register Font Viewer service ");
	}
	result = TRUE;
	return result;
}


static void font_manager_application_real_dbus_unregister (GApplication* base, GDBusConnection* conn, const gchar* path) {
	FontManagerApplication * self;
	guint _tmp0_ = 0U;
	GDBusConnection* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	self = (FontManagerApplication*) base;
	g_return_if_fail (conn != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = self->priv->fv_dbus_id;
	if (_tmp0_ != ((guint) 0)) {
		GDBusConnection* _tmp1_ = NULL;
		guint _tmp2_ = 0U;
		_tmp1_ = conn;
		_tmp2_ = self->priv->fv_dbus_id;
		g_dbus_connection_unregister_object (_tmp1_, _tmp2_);
	}
	_tmp3_ = conn;
	_tmp4_ = path;
	G_APPLICATION_CLASS (font_manager_application_parent_class)->dbus_unregister ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication), _tmp3_, _tmp4_);
}


static void font_manager_application_real_activate (GApplication* base) {
	FontManagerApplication * self;
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	FontManagerMain* _tmp4_ = NULL;
	FontManagerMain* _tmp5_ = NULL;
	self = (FontManagerApplication*) base;
	_tmp0_ = gtk_builder_new ();
	_tmp1_ = _tmp0_;
	font_manager_application_set_builder (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = gtk_application_prefers_app_menu ((GtkApplication*) self);
	if (_tmp2_) {
		GtkBuilder* _tmp3_ = NULL;
		_tmp3_ = self->priv->_builder;
		font_manager_set_g_app_menu ((GtkApplication*) self, _tmp3_);
	}
	_tmp4_ = font_manager_main_get_instance ();
	_tmp5_ = _tmp4_;
	font_manager_main_on_activate (_tmp5_);
	return;
}


void font_manager_application_quit (FontManagerApplication* self) {
	FontManagerMain* _tmp0_ = NULL;
	FontManagerMain* _tmp1_ = NULL;
	GSettings* _tmp2_ = NULL;
	GSettings* _tmp3_ = NULL;
	FontManagerMainWindow* _tmp4_ = NULL;
	FontManagerMainWindow* _tmp5_ = NULL;
	GList* _tmp6_ = NULL;
	guint _tmp7_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = font_manager_main_get_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = font_manager_main_get_settings (_tmp1_);
	_tmp3_ = _tmp2_;
	g_settings_apply (_tmp3_);
	_tmp4_ = self->priv->_main_window;
	gtk_widget_hide ((GtkWidget*) _tmp4_);
	_tmp5_ = self->priv->_main_window;
	gtk_application_remove_window ((GtkApplication*) self, (GtkWindow*) _tmp5_);
	font_manager_application_set_main_window (self, NULL);
	_tmp6_ = gtk_application_get_windows ((GtkApplication*) self);
	_tmp7_ = g_list_length (_tmp6_);
	if (_tmp7_ == ((guint) 0)) {
		g_application_quit ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_get_type (), GtkApplication));
	}
}


void font_manager_application_about (FontManagerApplication* self) {
	FontManagerMainWindow* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_main_window;
	font_manager_show_about_dialog ((GtkWindow*) _tmp0_);
	return;
}


void font_manager_application_help (FontManagerApplication* self) {
	g_return_if_fail (self != NULL);
	font_manager_show_help_dialog ();
	return;
}


gint font_manager_application_main (gchar** args, int args_length1) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	FontManagerApplication* main = NULL;
	FontManagerApplication* _tmp1_ = NULL;
	gint res = 0;
	FontManagerApplication* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gint _tmp4_ = 0;
	g_set_application_name (FONT_MANAGER_ABOUT_NAME);
	g_setenv ("XDG_CONFIG_HOME", "", TRUE);
	font_config_enable_user_config (FALSE);
	logging_setup (LOG_LEVEL_WARN);
	intl_setup (FONT_MANAGER_NAME);
	gtk_init (&args_length1, &args);
	font_manager_set_application_style ();
	_tmp0_ = font_manager_update_declined ();
	if (_tmp0_) {
		result = 0;
		return result;
	}
	_tmp1_ = font_manager_application_new (FONT_MANAGER_BUS_ID, G_APPLICATION_HANDLES_OPEN | G_APPLICATION_HANDLES_COMMAND_LINE);
	main = _tmp1_;
	_tmp2_ = main;
	_tmp3_ = args;
	_tmp3__length1 = args_length1;
	_tmp4_ = g_application_run ((GApplication*) _tmp2_, _tmp3__length1, _tmp3_);
	res = _tmp4_;
	result = res;
	_g_object_unref0 (main);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return font_manager_application_main (argv, argc);
}


FontManagerMainWindow* font_manager_application_get_main_window (FontManagerApplication* self) {
	FontManagerMainWindow* result;
	FontManagerMainWindow* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_main_window;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void font_manager_application_set_main_window (FontManagerApplication* self, FontManagerMainWindow* value) {
	FontManagerMainWindow* _tmp0_ = NULL;
	FontManagerMainWindow* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_main_window);
	self->priv->_main_window = _tmp1_;
	g_object_notify ((GObject *) self, "main-window");
}


GtkBuilder* font_manager_application_get_builder (FontManagerApplication* self) {
	GtkBuilder* result;
	GtkBuilder* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_builder;
	result = _tmp0_;
	return result;
}


void font_manager_application_set_builder (FontManagerApplication* self, GtkBuilder* value) {
	GtkBuilder* _tmp0_ = NULL;
	GtkBuilder* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_builder);
	self->priv->_builder = _tmp1_;
	g_object_notify ((GObject *) self, "builder");
}


FontManagerViewer* font_manager_application_get_font_viewer (FontManagerApplication* self) {
	FontManagerViewer* result;
	FontManagerViewer* _tmp0_ = NULL;
	FontManagerViewer* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->fv;
	if (_tmp0_ == NULL) {
		FontManagerViewer* _tmp1_ = NULL;
		_tmp1_ = font_manager_viewer_new ();
		g_object_ref_sink (_tmp1_);
		_g_object_unref0 (self->priv->fv);
		self->priv->fv = _tmp1_;
	}
	_tmp2_ = self->priv->fv;
	result = _tmp2_;
	return result;
}


static void font_manager_application_class_init (FontManagerApplicationClass * klass) {
	font_manager_application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerApplicationPrivate));
	((GApplicationClass *) klass)->startup = font_manager_application_real_startup;
	((GApplicationClass *) klass)->open = font_manager_application_real_open;
	((GApplicationClass *) klass)->command_line = font_manager_application_real_command_line;
	((GApplicationClass *) klass)->handle_local_options = font_manager_application_real_handle_local_options;
	((GApplicationClass *) klass)->dbus_register = font_manager_application_real_dbus_register;
	((GApplicationClass *) klass)->dbus_unregister = font_manager_application_real_dbus_unregister;
	((GApplicationClass *) klass)->activate = font_manager_application_real_activate;
	G_OBJECT_CLASS (klass)->get_property = _vala_font_manager_application_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_manager_application_set_property;
	G_OBJECT_CLASS (klass)->finalize = font_manager_application_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_APPLICATION_MAIN_WINDOW, g_param_spec_object ("main-window", "main-window", "main-window", FONT_MANAGER_TYPE_MAIN_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_APPLICATION_BUILDER, g_param_spec_object ("builder", "builder", "builder", gtk_builder_get_type (), G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_APPLICATION_FONT_VIEWER, g_param_spec_object ("font-viewer", "font-viewer", "font-viewer", FONT_MANAGER_TYPE_VIEWER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void font_manager_application_instance_init (FontManagerApplication * self) {
	self->priv = FONT_MANAGER_APPLICATION_GET_PRIVATE (self);
	self->priv->_main_window = NULL;
	self->priv->_builder = NULL;
	self->priv->fv_dbus_id = (guint) 0;
	self->priv->fv = NULL;
}


static void font_manager_application_finalize (GObject* obj) {
	FontManagerApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_APPLICATION, FontManagerApplication);
	_g_object_unref0 (self->priv->_main_window);
	_g_object_unref0 (self->priv->_builder);
	_g_object_unref0 (self->priv->fv);
	G_OBJECT_CLASS (font_manager_application_parent_class)->finalize (obj);
}


GType font_manager_application_get_type (void) {
	static volatile gsize font_manager_application_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_application_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerApplication), 0, (GInstanceInitFunc) font_manager_application_instance_init, NULL };
		GType font_manager_application_type_id;
		font_manager_application_type_id = g_type_register_static (gtk_application_get_type (), "FontManagerApplication", &g_define_type_info, 0);
		g_type_set_qdata (font_manager_application_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) font_manager_application_register_object);
		g_once_init_leave (&font_manager_application_type_id__volatile, font_manager_application_type_id);
	}
	return font_manager_application_type_id__volatile;
}


static void _vala_font_manager_application_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontManagerApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_APPLICATION, FontManagerApplication);
	switch (property_id) {
		case FONT_MANAGER_APPLICATION_MAIN_WINDOW:
		g_value_set_object (value, font_manager_application_get_main_window (self));
		break;
		case FONT_MANAGER_APPLICATION_BUILDER:
		g_value_set_object (value, font_manager_application_get_builder (self));
		break;
		case FONT_MANAGER_APPLICATION_FONT_VIEWER:
		g_value_set_object (value, font_manager_application_get_font_viewer (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_manager_application_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontManagerApplication * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_APPLICATION, FontManagerApplication);
	switch (property_id) {
		case FONT_MANAGER_APPLICATION_MAIN_WINDOW:
		font_manager_application_set_main_window (self, g_value_get_object (value));
		break;
		case FONT_MANAGER_APPLICATION_BUILDER:
		font_manager_application_set_builder (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _dbus_font_manager_application_quit (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	font_manager_application_quit (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_font_manager_application_about (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	font_manager_application_about (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_font_manager_application_help (FontManagerApplication* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	font_manager_application_help (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void font_manager_application_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "Quit") == 0) {
		_dbus_font_manager_application_quit (object, parameters, invocation);
	} else if (strcmp (method_name, "About") == 0) {
		_dbus_font_manager_application_about (object, parameters, invocation);
	} else if (strcmp (method_name, "Help") == 0) {
		_dbus_font_manager_application_help (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* font_manager_application_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean font_manager_application_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint font_manager_application_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_font_manager_application_dbus_interface_info), &_font_manager_application_dbus_interface_vtable, data, _font_manager_application_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _font_manager_application_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



