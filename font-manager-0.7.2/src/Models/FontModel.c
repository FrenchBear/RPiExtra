/* FontModel.c generated by valac 0.26.1, the Vala compiler
 * generated from FontModel.vala, do not modify */

/* FontModel.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define FONT_MANAGER_TYPE_FONT_MODEL_COLUMN (font_manager_font_model_column_get_type ())

#define FONT_MANAGER_TYPE_FONT_MODEL (font_manager_font_model_get_type ())
#define FONT_MANAGER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel))
#define FONT_MANAGER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))
#define FONT_MANAGER_IS_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_IS_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))

typedef struct _FontManagerFontModel FontManagerFontModel;
typedef struct _FontManagerFontModelClass FontManagerFontModelClass;
typedef struct _FontManagerFontModelPrivate FontManagerFontModelPrivate;

#define FONT_CONFIG_TYPE_FAMILIES (font_config_families_get_type ())
#define FONT_CONFIG_FAMILIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamilies))
#define FONT_CONFIG_FAMILIES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamiliesClass))
#define FONT_CONFIG_IS_FAMILIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FAMILIES))
#define FONT_CONFIG_IS_FAMILIES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FAMILIES))
#define FONT_CONFIG_FAMILIES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamiliesClass))

typedef struct _FontConfigFamilies FontConfigFamilies;
typedef struct _FontConfigFamiliesClass FontConfigFamiliesClass;

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_MANAGER_TYPE_FILTER (font_manager_filter_get_type ())
#define FONT_MANAGER_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilter))
#define FONT_MANAGER_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))
#define FONT_MANAGER_IS_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_IS_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))

typedef struct _FontManagerFilter FontManagerFilter;
typedef struct _FontManagerFilterClass FontManagerFilterClass;

#define FONT_CONFIG_TYPE_FAMILY (font_config_family_get_type ())
#define FONT_CONFIG_FAMILY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FAMILY, FontConfigFamily))
#define FONT_CONFIG_FAMILY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FAMILY, FontConfigFamilyClass))
#define FONT_CONFIG_IS_FAMILY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FAMILY))
#define FONT_CONFIG_IS_FAMILY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FAMILY))
#define FONT_CONFIG_FAMILY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FAMILY, FontConfigFamilyClass))

typedef struct _FontConfigFamily FontConfigFamily;
typedef struct _FontConfigFamilyClass FontConfigFamilyClass;

#define FONT_MANAGER_TYPE_COLLECTION (font_manager_collection_get_type ())
#define FONT_MANAGER_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollection))
#define FONT_MANAGER_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollectionClass))
#define FONT_MANAGER_IS_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_COLLECTION))
#define FONT_MANAGER_IS_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_COLLECTION))
#define FONT_MANAGER_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_COLLECTION, FontManagerCollectionClass))

typedef struct _FontManagerCollection FontManagerCollection;
typedef struct _FontManagerCollectionClass FontManagerCollectionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FONT_CONFIG_TYPE_FONT (font_config_font_get_type ())
#define FONT_CONFIG_FONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFont))
#define FONT_CONFIG_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))
#define FONT_CONFIG_IS_FONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_FONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))

typedef struct _FontConfigFont FontConfigFont;
typedef struct _FontConfigFontClass FontConfigFontClass;

#define FONT_MANAGER_TYPE_CATEGORY (font_manager_category_get_type ())
#define FONT_MANAGER_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategory))
#define FONT_MANAGER_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))
#define FONT_MANAGER_IS_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_IS_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_CATEGORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))

typedef struct _FontManagerCategory FontManagerCategory;
typedef struct _FontManagerCategoryClass FontManagerCategoryClass;
#define _g_free0(var) (var = (g_free (var), NULL))

typedef enum  {
	FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT,
	FONT_MANAGER_FONT_MODEL_COLUMN_DESCRIPTION,
	FONT_MANAGER_FONT_MODEL_COLUMN_COUNT,
	FONT_MANAGER_FONT_MODEL_COLUMN_N_COLUMNS
} FontManagerFontModelColumn;

struct _FontManagerFontModel {
	GtkTreeStore parent_instance;
	FontManagerFontModelPrivate * priv;
};

struct _FontManagerFontModelClass {
	GtkTreeStoreClass parent_class;
};

struct _FontManagerFontModelPrivate {
	FontConfigFamilies* _families;
};


static gpointer font_manager_font_model_parent_class = NULL;

GType font_manager_font_model_column_get_type (void) G_GNUC_CONST;
GType font_manager_font_model_get_type (void) G_GNUC_CONST;
GType font_config_families_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_FONT_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelPrivate))
enum  {
	FONT_MANAGER_FONT_MODEL_DUMMY_PROPERTY,
	FONT_MANAGER_FONT_MODEL_FAMILIES
};
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_manager_filter_get_type (void) G_GNUC_CONST;
void font_manager_font_model_update (FontManagerFontModel* self, FontManagerFilter* filter);
FontConfigFamilies* font_manager_font_model_get_families (FontManagerFontModel* self);
GeeArrayList* font_config_families_list (FontConfigFamilies* self);
GType font_config_family_get_type (void) G_GNUC_CONST;
GType font_manager_collection_get_type (void) G_GNUC_CONST;
GeeHashSet* font_manager_collection_get_full_contents (FontManagerCollection* self);
GeeHashSet* font_manager_filter_get_families (FontManagerFilter* self);
const gchar* font_config_family_get_name (FontConfigFamily* self);
const gchar* font_config_family_get_description (FontConfigFamily* self);
GType font_config_font_get_type (void) G_GNUC_CONST;
GeeHashMap* font_config_family_get_faces (FontConfigFamily* self);
GeeArrayList* font_config_family_list_faces (FontConfigFamily* self);
GType font_manager_category_get_type (void) G_GNUC_CONST;
GeeHashSet* font_manager_category_get_descriptions (FontManagerCategory* self);
const gchar* font_config_font_get_description (FontConfigFont* self);
void font_manager_font_model_init (FontManagerFontModel* self);
FontManagerFontModel* font_manager_font_model_new (void);
FontManagerFontModel* font_manager_font_model_construct (GType object_type);
void font_manager_font_model_set_families (FontManagerFontModel* self, FontConfigFamilies* value);
static GObject * font_manager_font_model_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void font_manager_font_model_finalize (GObject* obj);
static void _vala_font_manager_font_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_manager_font_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


GType font_manager_font_model_column_get_type (void) {
	static volatile gsize font_manager_font_model_column_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_font_model_column_type_id__volatile)) {
		static const GEnumValue values[] = {{FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT, "FONT_MANAGER_FONT_MODEL_COLUMN_OBJECT", "object"}, {FONT_MANAGER_FONT_MODEL_COLUMN_DESCRIPTION, "FONT_MANAGER_FONT_MODEL_COLUMN_DESCRIPTION", "description"}, {FONT_MANAGER_FONT_MODEL_COLUMN_COUNT, "FONT_MANAGER_FONT_MODEL_COLUMN_COUNT", "count"}, {FONT_MANAGER_FONT_MODEL_COLUMN_N_COLUMNS, "FONT_MANAGER_FONT_MODEL_COLUMN_N_COLUMNS", "n-columns"}, {0, NULL, NULL}};
		GType font_manager_font_model_column_type_id;
		font_manager_font_model_column_type_id = g_enum_register_static ("FontManagerFontModelColumn", values);
		g_once_init_leave (&font_manager_font_model_column_type_id__volatile, font_manager_font_model_column_type_id);
	}
	return font_manager_font_model_column_type_id__volatile;
}


void font_manager_font_model_update (FontManagerFontModel* self, FontManagerFilter* filter) {
	FontConfigFamilies* _tmp0_ = NULL;
	FontConfigFamilies* _tmp1_ = NULL;
	gboolean visible = FALSE;
	GeeHashSet* contents = NULL;
	GeeHashSet* _tmp74_ = NULL;
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear ((GtkTreeStore*) self);
	_tmp0_ = font_manager_font_model_get_families (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == NULL) {
		return;
	}
	visible = TRUE;
	contents = NULL;
	{
		GeeArrayList* _entry_list = NULL;
		FontConfigFamilies* _tmp2_ = NULL;
		FontConfigFamilies* _tmp3_ = NULL;
		GeeArrayList* _tmp4_ = NULL;
		gint _entry_size = 0;
		GeeArrayList* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		gint _entry_index = 0;
		_tmp2_ = font_manager_font_model_get_families (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = font_config_families_list (_tmp3_);
		_entry_list = _tmp4_;
		_tmp5_ = _entry_list;
		_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_entry_size = _tmp7_;
		_entry_index = -1;
		while (TRUE) {
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gchar* entry = NULL;
			GeeArrayList* _tmp11_ = NULL;
			gint _tmp12_ = 0;
			gpointer _tmp13_ = NULL;
			FontConfigFamily* family = NULL;
			FontConfigFamilies* _tmp14_ = NULL;
			FontConfigFamilies* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gpointer _tmp17_ = NULL;
			FontManagerFilter* _tmp18_ = NULL;
			gboolean _tmp33_ = FALSE;
			_tmp8_ = _entry_index;
			_entry_index = _tmp8_ + 1;
			_tmp9_ = _entry_index;
			_tmp10_ = _entry_size;
			if (!(_tmp9_ < _tmp10_)) {
				break;
			}
			_tmp11_ = _entry_list;
			_tmp12_ = _entry_index;
			_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp11_, _tmp12_);
			entry = (gchar*) _tmp13_;
			_tmp14_ = font_manager_font_model_get_families (self);
			_tmp15_ = _tmp14_;
			_tmp16_ = entry;
			_tmp17_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp15_, _tmp16_);
			family = (FontConfigFamily*) _tmp17_;
			_tmp18_ = filter;
			if (_tmp18_ != NULL) {
				GeeHashSet* _tmp19_ = NULL;
				GeeHashSet* _tmp28_ = NULL;
				FontConfigFamily* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				gboolean _tmp32_ = FALSE;
				_tmp19_ = contents;
				if (_tmp19_ == NULL) {
					FontManagerFilter* _tmp20_ = NULL;
					_tmp20_ = filter;
					if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp20_, FONT_MANAGER_TYPE_COLLECTION)) {
						FontManagerFilter* _tmp21_ = NULL;
						GeeHashSet* _tmp22_ = NULL;
						_tmp21_ = filter;
						_tmp22_ = font_manager_collection_get_full_contents (G_TYPE_CHECK_INSTANCE_CAST (_tmp21_, FONT_MANAGER_TYPE_COLLECTION, FontManagerCollection));
						_g_object_unref0 (contents);
						contents = _tmp22_;
					} else {
						GeeHashSet* _tmp23_ = NULL;
						GeeHashSet* _tmp24_ = NULL;
						FontManagerFilter* _tmp25_ = NULL;
						GeeHashSet* _tmp26_ = NULL;
						GeeHashSet* _tmp27_ = NULL;
						_tmp23_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
						_g_object_unref0 (contents);
						contents = _tmp23_;
						_tmp24_ = contents;
						_tmp25_ = filter;
						_tmp26_ = font_manager_filter_get_families (_tmp25_);
						_tmp27_ = _tmp26_;
						gee_collection_add_all ((GeeCollection*) _tmp24_, (GeeCollection*) _tmp27_);
					}
				}
				_tmp28_ = contents;
				_tmp29_ = family;
				_tmp30_ = font_config_family_get_name (_tmp29_);
				_tmp31_ = _tmp30_;
				_tmp32_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp28_, _tmp31_);
				visible = _tmp32_;
			}
			_tmp33_ = visible;
			if (_tmp33_) {
				GtkTreeIter iter = {0};
				GtkTreeIter _tmp34_ = {0};
				GtkTreeIter _tmp35_ = {0};
				FontConfigFamily* _tmp36_ = NULL;
				FontConfigFamily* _tmp37_ = NULL;
				const gchar* _tmp38_ = NULL;
				const gchar* _tmp39_ = NULL;
				FontConfigFamily* _tmp40_ = NULL;
				GeeHashMap* _tmp41_ = NULL;
				GeeHashMap* _tmp42_ = NULL;
				gint _tmp43_ = 0;
				gint _tmp44_ = 0;
				gtk_tree_store_append ((GtkTreeStore*) self, &_tmp34_, NULL);
				iter = _tmp34_;
				_tmp35_ = iter;
				_tmp36_ = family;
				_tmp37_ = family;
				_tmp38_ = font_config_family_get_description (_tmp37_);
				_tmp39_ = _tmp38_;
				_tmp40_ = family;
				_tmp41_ = font_config_family_get_faces (_tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = gee_abstract_map_get_size ((GeeMap*) _tmp42_);
				_tmp44_ = _tmp43_;
				gtk_tree_store_set ((GtkTreeStore*) self, &_tmp35_, 0, _tmp36_, 1, _tmp39_, 2, _tmp44_, -1, -1);
				{
					GeeArrayList* _face_list = NULL;
					FontConfigFamily* _tmp45_ = NULL;
					GeeArrayList* _tmp46_ = NULL;
					gint _face_size = 0;
					GeeArrayList* _tmp47_ = NULL;
					gint _tmp48_ = 0;
					gint _tmp49_ = 0;
					gint _face_index = 0;
					_tmp45_ = family;
					_tmp46_ = font_config_family_list_faces (_tmp45_);
					_face_list = _tmp46_;
					_tmp47_ = _face_list;
					_tmp48_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp47_);
					_tmp49_ = _tmp48_;
					_face_size = _tmp49_;
					_face_index = -1;
					while (TRUE) {
						gint _tmp50_ = 0;
						gint _tmp51_ = 0;
						gint _tmp52_ = 0;
						FontConfigFont* face = NULL;
						GeeArrayList* _tmp53_ = NULL;
						gint _tmp54_ = 0;
						gpointer _tmp55_ = NULL;
						gboolean _tmp56_ = FALSE;
						FontManagerFilter* _tmp57_ = NULL;
						gboolean _tmp66_ = FALSE;
						_tmp50_ = _face_index;
						_face_index = _tmp50_ + 1;
						_tmp51_ = _face_index;
						_tmp52_ = _face_size;
						if (!(_tmp51_ < _tmp52_)) {
							break;
						}
						_tmp53_ = _face_list;
						_tmp54_ = _face_index;
						_tmp55_ = gee_abstract_list_get ((GeeAbstractList*) _tmp53_, _tmp54_);
						face = (FontConfigFont*) _tmp55_;
						visible = TRUE;
						_tmp57_ = filter;
						if (_tmp57_ != NULL) {
							FontManagerFilter* _tmp58_ = NULL;
							_tmp58_ = filter;
							_tmp56_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp58_, FONT_MANAGER_TYPE_CATEGORY);
						} else {
							_tmp56_ = FALSE;
						}
						if (_tmp56_) {
							FontManagerFilter* _tmp59_ = NULL;
							GeeHashSet* _tmp60_ = NULL;
							GeeHashSet* _tmp61_ = NULL;
							FontConfigFont* _tmp62_ = NULL;
							const gchar* _tmp63_ = NULL;
							const gchar* _tmp64_ = NULL;
							gboolean _tmp65_ = FALSE;
							_tmp59_ = filter;
							_tmp60_ = font_manager_category_get_descriptions (G_TYPE_CHECK_INSTANCE_CAST (_tmp59_, FONT_MANAGER_TYPE_CATEGORY, FontManagerCategory));
							_tmp61_ = _tmp60_;
							_tmp62_ = face;
							_tmp63_ = font_config_font_get_description (_tmp62_);
							_tmp64_ = _tmp63_;
							_tmp65_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp61_, _tmp64_);
							if (!_tmp65_) {
								visible = FALSE;
							}
						}
						_tmp66_ = visible;
						if (_tmp66_) {
							GtkTreeIter _iter = {0};
							GtkTreeIter _tmp67_ = {0};
							GtkTreeIter _tmp68_ = {0};
							GtkTreeIter _tmp69_ = {0};
							FontConfigFont* _tmp70_ = NULL;
							FontConfigFont* _tmp71_ = NULL;
							const gchar* _tmp72_ = NULL;
							const gchar* _tmp73_ = NULL;
							_tmp67_ = iter;
							gtk_tree_store_append ((GtkTreeStore*) self, &_tmp68_, &_tmp67_);
							_iter = _tmp68_;
							_tmp69_ = _iter;
							_tmp70_ = face;
							_tmp71_ = face;
							_tmp72_ = font_config_font_get_description (_tmp71_);
							_tmp73_ = _tmp72_;
							gtk_tree_store_set ((GtkTreeStore*) self, &_tmp69_, 0, _tmp70_, 1, _tmp73_, -1, -1);
						}
						_g_object_unref0 (face);
					}
					_g_object_unref0 (_face_list);
				}
			}
			_g_object_unref0 (family);
			_g_free0 (entry);
		}
		_g_object_unref0 (_entry_list);
	}
	_tmp74_ = contents;
	if (_tmp74_ != NULL) {
		GeeHashSet* _tmp75_ = NULL;
		_tmp75_ = contents;
		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp75_);
	}
	_g_object_unref0 (contents);
	contents = NULL;
	_g_object_unref0 (contents);
	return;
}


void font_manager_font_model_init (FontManagerFontModel* self) {
	g_return_if_fail (self != NULL);
	font_manager_font_model_update (self, NULL);
	return;
}


FontManagerFontModel* font_manager_font_model_construct (GType object_type) {
	FontManagerFontModel * self = NULL;
	self = (FontManagerFontModel*) g_object_new (object_type, NULL);
	return self;
}


FontManagerFontModel* font_manager_font_model_new (void) {
	return font_manager_font_model_construct (FONT_MANAGER_TYPE_FONT_MODEL);
}


FontConfigFamilies* font_manager_font_model_get_families (FontManagerFontModel* self) {
	FontConfigFamilies* result;
	FontConfigFamilies* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_families;
	result = _tmp0_;
	return result;
}


void font_manager_font_model_set_families (FontManagerFontModel* self, FontConfigFamilies* value) {
	FontConfigFamilies* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_families = _tmp0_;
	font_manager_font_model_init (self);
	g_object_notify ((GObject *) self, "families");
}


static GObject * font_manager_font_model_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FontManagerFontModel * self;
	GType* _tmp0_ = NULL;
	GType* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	parent_class = G_OBJECT_CLASS (font_manager_font_model_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel);
	_tmp0_ = g_new0 (GType, 3);
	_tmp0_[0] = G_TYPE_OBJECT;
	_tmp0_[1] = G_TYPE_STRING;
	_tmp0_[2] = G_TYPE_INT;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = 3;
	gtk_tree_store_set_column_types ((GtkTreeStore*) self, 3, _tmp1_);
	_tmp1_ = (g_free (_tmp1_), NULL);
	return obj;
}


static void font_manager_font_model_class_init (FontManagerFontModelClass * klass) {
	font_manager_font_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerFontModelPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_font_manager_font_model_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_manager_font_model_set_property;
	G_OBJECT_CLASS (klass)->constructor = font_manager_font_model_constructor;
	G_OBJECT_CLASS (klass)->finalize = font_manager_font_model_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_FONT_MODEL_FAMILIES, g_param_spec_object ("families", "families", "families", FONT_CONFIG_TYPE_FAMILIES, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void font_manager_font_model_instance_init (FontManagerFontModel * self) {
	self->priv = FONT_MANAGER_FONT_MODEL_GET_PRIVATE (self);
}


static void font_manager_font_model_finalize (GObject* obj) {
	FontManagerFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel);
	G_OBJECT_CLASS (font_manager_font_model_parent_class)->finalize (obj);
}


GType font_manager_font_model_get_type (void) {
	static volatile gsize font_manager_font_model_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_font_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerFontModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_font_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerFontModel), 0, (GInstanceInitFunc) font_manager_font_model_instance_init, NULL };
		GType font_manager_font_model_type_id;
		font_manager_font_model_type_id = g_type_register_static (gtk_tree_store_get_type (), "FontManagerFontModel", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_font_model_type_id__volatile, font_manager_font_model_type_id);
	}
	return font_manager_font_model_type_id__volatile;
}


static void _vala_font_manager_font_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontManagerFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel);
	switch (property_id) {
		case FONT_MANAGER_FONT_MODEL_FAMILIES:
		g_value_set_object (value, font_manager_font_model_get_families (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_manager_font_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontManagerFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel);
	switch (property_id) {
		case FONT_MANAGER_FONT_MODEL_FAMILIES:
		font_manager_font_model_set_families (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



