/* CategoryModel.c generated by valac 0.26.1, the Vala compiler
 * generated from CategoryModel.vala, do not modify */

/* CategoryModel.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <sqlite3.h>


#define FONT_MANAGER_TYPE_CATEGORY_MODEL (font_manager_category_model_get_type ())
#define FONT_MANAGER_CATEGORY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModel))
#define FONT_MANAGER_CATEGORY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModelClass))
#define FONT_MANAGER_IS_CATEGORY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_CATEGORY_MODEL))
#define FONT_MANAGER_IS_CATEGORY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_CATEGORY_MODEL))
#define FONT_MANAGER_CATEGORY_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModelClass))

typedef struct _FontManagerCategoryModel FontManagerCategoryModel;
typedef struct _FontManagerCategoryModelClass FontManagerCategoryModelClass;
typedef struct _FontManagerCategoryModelPrivate FontManagerCategoryModelPrivate;

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_MANAGER_TYPE_FILTER (font_manager_filter_get_type ())
#define FONT_MANAGER_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilter))
#define FONT_MANAGER_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))
#define FONT_MANAGER_IS_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_IS_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))

typedef struct _FontManagerFilter FontManagerFilter;
typedef struct _FontManagerFilterClass FontManagerFilterClass;

#define FONT_MANAGER_TYPE_CATEGORY (font_manager_category_get_type ())
#define FONT_MANAGER_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategory))
#define FONT_MANAGER_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))
#define FONT_MANAGER_IS_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_IS_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_CATEGORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))

typedef struct _FontManagerCategory FontManagerCategory;
typedef struct _FontManagerCategoryClass FontManagerCategoryClass;

#define FONT_MANAGER_TYPE_DATABASE (font_manager_database_get_type ())
#define FONT_MANAGER_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabase))
#define FONT_MANAGER_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))
#define FONT_MANAGER_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))

typedef struct _FontManagerDatabase FontManagerDatabase;
typedef struct _FontManagerDatabaseClass FontManagerDatabaseClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define FONT_MANAGER_TYPE_UNSORTED (font_manager_unsorted_get_type ())
#define FONT_MANAGER_UNSORTED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_UNSORTED, FontManagerUnsorted))
#define FONT_MANAGER_UNSORTED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_UNSORTED, FontManagerUnsortedClass))
#define FONT_MANAGER_IS_UNSORTED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_UNSORTED))
#define FONT_MANAGER_IS_UNSORTED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_UNSORTED))
#define FONT_MANAGER_UNSORTED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_UNSORTED, FontManagerUnsortedClass))

typedef struct _FontManagerUnsorted FontManagerUnsorted;
typedef struct _FontManagerUnsortedClass FontManagerUnsortedClass;

#define FONT_MANAGER_TYPE_DISABLED (font_manager_disabled_get_type ())
#define FONT_MANAGER_DISABLED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_DISABLED, FontManagerDisabled))
#define FONT_MANAGER_DISABLED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_DISABLED, FontManagerDisabledClass))
#define FONT_MANAGER_IS_DISABLED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_DISABLED))
#define FONT_MANAGER_IS_DISABLED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_DISABLED))
#define FONT_MANAGER_DISABLED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_DISABLED, FontManagerDisabledClass))

typedef struct _FontManagerDisabled FontManagerDisabled;
typedef struct _FontManagerDisabledClass FontManagerDisabledClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define FONT_MANAGER_DATABASE_TYPE_ITERATOR (font_manager_database_iterator_get_type ())
#define FONT_MANAGER_DATABASE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIterator))
#define FONT_MANAGER_DATABASE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIteratorClass))
#define FONT_MANAGER_DATABASE_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR))
#define FONT_MANAGER_DATABASE_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_DATABASE_TYPE_ITERATOR))
#define FONT_MANAGER_DATABASE_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIteratorClass))

typedef struct _FontManagerDatabaseIterator FontManagerDatabaseIterator;
typedef struct _FontManagerDatabaseIteratorClass FontManagerDatabaseIteratorClass;

#define FONT_CONFIG_TYPE_SLANT (font_config_slant_get_type ())

#define FONT_CONFIG_TYPE_WEIGHT (font_config_weight_get_type ())

#define FONT_CONFIG_TYPE_WIDTH (font_config_width_get_type ())

#define FONT_CONFIG_TYPE_SPACING (font_config_spacing_get_type ())
#define _font_manager_database_iterator_unref0(var) ((var == NULL) ? NULL : (var = (font_manager_database_iterator_unref (var), NULL)))

struct _FontManagerCategoryModel {
	GtkTreeStore parent_instance;
	FontManagerCategoryModelPrivate * priv;
};

struct _FontManagerCategoryModelClass {
	GtkTreeStoreClass parent_class;
};

struct _FontManagerCategoryModelPrivate {
	GeeArrayList* categories;
	FontManagerDatabase* db;
};

typedef enum  {
	FONT_MANAGER_DATABASE_ERROR_ERROR,
	FONT_MANAGER_DATABASE_ERROR_BACKING,
	FONT_MANAGER_DATABASE_ERROR_MEMORY,
	FONT_MANAGER_DATABASE_ERROR_ABORT,
	FONT_MANAGER_DATABASE_ERROR_LIMITS,
	FONT_MANAGER_DATABASE_ERROR_TYPESPEC
} FontManagerDatabaseError;
#define FONT_MANAGER_DATABASE_ERROR font_manager_database_error_quark ()
typedef enum  {
	FONT_CONFIG_SLANT_ROMAN = 0,
	FONT_CONFIG_SLANT_ITALIC = 100,
	FONT_CONFIG_SLANT_OBLIQUE = 110
} FontConfigSlant;

typedef enum  {
	FONT_CONFIG_WEIGHT_THIN = 0,
	FONT_CONFIG_WEIGHT_EXTRALIGHT = 40,
	FONT_CONFIG_WEIGHT_ULTRALIGHT = FONT_CONFIG_WEIGHT_EXTRALIGHT,
	FONT_CONFIG_WEIGHT_LIGHT = 50,
	FONT_CONFIG_WEIGHT_BOOK = 75,
	FONT_CONFIG_WEIGHT_REGULAR = 80,
	FONT_CONFIG_WEIGHT_NORMAL = FONT_CONFIG_WEIGHT_REGULAR,
	FONT_CONFIG_WEIGHT_MEDIUM = 100,
	FONT_CONFIG_WEIGHT_DEMIBOLD = 180,
	FONT_CONFIG_WEIGHT_SEMIBOLD = FONT_CONFIG_WEIGHT_DEMIBOLD,
	FONT_CONFIG_WEIGHT_BOLD = 200,
	FONT_CONFIG_WEIGHT_EXTRABOLD = 205,
	FONT_CONFIG_WEIGHT_BLACK = 210,
	FONT_CONFIG_WEIGHT_HEAVY = FONT_CONFIG_WEIGHT_BLACK,
	FONT_CONFIG_WEIGHT_EXTRABLACK = 215,
	FONT_CONFIG_WEIGHT_ULTRABLACK = FONT_CONFIG_WEIGHT_EXTRABLACK
} FontConfigWeight;

typedef enum  {
	FONT_CONFIG_WIDTH_ULTRACONDENSED = 50,
	FONT_CONFIG_WIDTH_EXTRACONDENSED = 63,
	FONT_CONFIG_WIDTH_CONDENSED = 75,
	FONT_CONFIG_WIDTH_SEMICONDENSED = 87,
	FONT_CONFIG_WIDTH_NORMAL = 100,
	FONT_CONFIG_WIDTH_SEMIEXPANDED = 113,
	FONT_CONFIG_WIDTH_EXPANDED = 125,
	FONT_CONFIG_WIDTH_EXTRAEXPANDED = 150,
	FONT_CONFIG_WIDTH_ULTRAEXPANDED = 200
} FontConfigWidth;

typedef enum  {
	FONT_CONFIG_SPACING_PROPORTIONAL = 0,
	FONT_CONFIG_SPACING_DUAL = 90,
	FONT_CONFIG_SPACING_MONO = 100,
	FONT_CONFIG_SPACING_CHARCELL = 110
} FontConfigSpacing;


static gpointer font_manager_category_model_parent_class = NULL;

GType font_manager_category_model_get_type (void) G_GNUC_CONST;
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_manager_filter_get_type (void) G_GNUC_CONST;
GType font_manager_category_get_type (void) G_GNUC_CONST;
GType font_manager_database_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_CATEGORY_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModelPrivate))
enum  {
	FONT_MANAGER_CATEGORY_MODEL_DUMMY_PROPERTY,
	FONT_MANAGER_CATEGORY_MODEL_DATABASE
};
void font_manager_category_model_update (FontManagerCategoryModel* self);
void font_manager_category_update (FontManagerCategory* self, FontManagerDatabase* db);
const gchar* font_manager_filter_get_comment (FontManagerFilter* self);
gint font_manager_filter_get_index (FontManagerFilter* self);
const gchar* font_manager_filter_get_icon (FontManagerFilter* self);
const gchar* font_manager_filter_get_name (FontManagerFilter* self);
GeeHashSet* font_manager_filter_get_families (FontManagerFilter* self);
GeeArrayList* font_manager_category_get_children (FontManagerCategory* self);
FontManagerCategoryModel* font_manager_category_model_new (void);
FontManagerCategoryModel* font_manager_category_model_construct (GType object_type);
FontManagerDatabase* font_manager_category_model_get_database (FontManagerCategoryModel* self);
void font_manager_category_model_set_database (FontManagerCategoryModel* self, FontManagerDatabase* value);
GeeArrayList* font_manager_get_default_categories (FontManagerDatabase* db);
static GObject * font_manager_category_model_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void font_manager_category_model_finalize (GObject* obj);
static void _vala_font_manager_category_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_manager_category_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
FontManagerCategory* font_manager_category_new (const gchar* name, const gchar* comment, const gchar* icon, const gchar* condition);
FontManagerCategory* font_manager_category_construct (GType object_type, const gchar* name, const gchar* comment, const gchar* icon, const gchar* condition);
void font_manager_filter_set_index (FontManagerFilter* self, gint value);
gchar* get_user_font_dir (void);
FontManagerCategory* font_manager_construct_panose_filter (void);
FontManagerCategory* font_manager_construct_filter (FontManagerDatabase* db, const gchar* name, const gchar* comment, const gchar* keyword);
FontManagerUnsorted* font_manager_unsorted_new (void);
FontManagerUnsorted* font_manager_unsorted_construct (GType object_type);
GType font_manager_unsorted_get_type (void) G_GNUC_CONST;
FontManagerDisabled* font_manager_disabled_new (void);
FontManagerDisabled* font_manager_disabled_construct (GType object_type);
GType font_manager_disabled_get_type (void) G_GNUC_CONST;
gint font_manager_sort_on_index (FontManagerFilter* a, FontManagerFilter* b);
GQuark font_manager_database_error_quark (void);
void font_manager_add_children_from_db_results (FontManagerDatabase* db, GeeArrayList* filters, const gchar* keyword, GError** error);
void font_manager_show_error_message (const gchar* message, GError* e, GtkWindow* parent);
void font_manager_database_execute_query (FontManagerDatabase* self, const gchar* query, GError** error);
gpointer font_manager_database_iterator_ref (gpointer instance);
void font_manager_database_iterator_unref (gpointer instance);
GParamSpec* font_manager_database_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void font_manager_database_value_set_iterator (GValue* value, gpointer v_object);
void font_manager_database_value_take_iterator (GValue* value, gpointer v_object);
gpointer font_manager_database_value_get_iterator (const GValue* value);
GType font_manager_database_iterator_get_type (void) G_GNUC_CONST;
FontManagerDatabaseIterator* font_manager_database_iterator (FontManagerDatabase* self);
sqlite3_stmt* font_manager_database_iterator_next_value (FontManagerDatabaseIterator* self);
GType font_config_slant_get_type (void) G_GNUC_CONST;
gchar* font_config_slant_to_string (FontConfigSlant self);
GType font_config_weight_get_type (void) G_GNUC_CONST;
gchar* font_config_weight_to_string (FontConfigWeight self);
GType font_config_width_get_type (void) G_GNUC_CONST;
gchar* font_config_width_to_string (FontConfigWidth self);
GType font_config_spacing_get_type (void) G_GNUC_CONST;
gchar* font_config_spacing_to_string (FontConfigSpacing self);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void font_manager_category_model_update (FontManagerCategoryModel* self) {
	g_return_if_fail (self != NULL);
	gtk_tree_store_clear ((GtkTreeStore*) self);
	{
		GeeArrayList* _filter_list = NULL;
		GeeArrayList* _tmp0_ = NULL;
		GeeArrayList* _tmp1_ = NULL;
		gint _filter_size = 0;
		GeeArrayList* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _filter_index = 0;
		_tmp0_ = self->priv->categories;
		_tmp1_ = _g_object_ref0 (_tmp0_);
		_filter_list = _tmp1_;
		_tmp2_ = _filter_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_filter_size = _tmp4_;
		_filter_index = -1;
		while (TRUE) {
			gint _tmp5_ = 0;
			gint _tmp6_ = 0;
			gint _tmp7_ = 0;
			FontManagerCategory* filter = NULL;
			GeeArrayList* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			gpointer _tmp10_ = NULL;
			FontManagerCategory* _tmp11_ = NULL;
			FontManagerDatabase* _tmp12_ = NULL;
			GtkTreeIter iter = {0};
			GtkTreeIter _tmp13_ = {0};
			gchar* comment = NULL;
			FontManagerCategory* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			FontManagerCategory* _tmp18_ = NULL;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			_tmp5_ = _filter_index;
			_filter_index = _tmp5_ + 1;
			_tmp6_ = _filter_index;
			_tmp7_ = _filter_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _filter_list;
			_tmp9_ = _filter_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			filter = (FontManagerCategory*) _tmp10_;
			_tmp11_ = filter;
			_tmp12_ = self->priv->db;
			font_manager_category_update (_tmp11_, _tmp12_);
			gtk_tree_store_append ((GtkTreeStore*) self, &_tmp13_, NULL);
			iter = _tmp13_;
			_tmp14_ = filter;
			_tmp15_ = font_manager_filter_get_comment ((FontManagerFilter*) _tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = g_markup_escape_text (_tmp16_, (gssize) (-1));
			comment = _tmp17_;
			_tmp18_ = filter;
			_tmp19_ = font_manager_filter_get_index ((FontManagerFilter*) _tmp18_);
			_tmp20_ = _tmp19_;
			if (_tmp20_ < 3) {
				GtkTreeIter _tmp21_ = {0};
				FontManagerCategory* _tmp22_ = NULL;
				FontManagerCategory* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				FontManagerCategory* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				const gchar* _tmp29_ = NULL;
				FontManagerCategory* _tmp30_ = NULL;
				GeeHashSet* _tmp31_ = NULL;
				GeeHashSet* _tmp32_ = NULL;
				gint _tmp33_ = 0;
				gint _tmp34_ = 0;
				_tmp21_ = iter;
				_tmp22_ = filter;
				_tmp23_ = filter;
				_tmp24_ = font_manager_filter_get_icon ((FontManagerFilter*) _tmp23_);
				_tmp25_ = _tmp24_;
				_tmp26_ = filter;
				_tmp27_ = font_manager_filter_get_name ((FontManagerFilter*) _tmp26_);
				_tmp28_ = _tmp27_;
				_tmp29_ = comment;
				_tmp30_ = filter;
				_tmp31_ = font_manager_filter_get_families ((FontManagerFilter*) _tmp30_);
				_tmp32_ = _tmp31_;
				_tmp33_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp32_);
				_tmp34_ = _tmp33_;
				gtk_tree_store_set ((GtkTreeStore*) self, &_tmp21_, 0, _tmp22_, 1, _tmp25_, 2, _tmp28_, 3, _tmp29_, 4, _tmp34_, -1, -1);
			} else {
				GtkTreeIter _tmp35_ = {0};
				FontManagerCategory* _tmp36_ = NULL;
				FontManagerCategory* _tmp37_ = NULL;
				const gchar* _tmp38_ = NULL;
				const gchar* _tmp39_ = NULL;
				FontManagerCategory* _tmp40_ = NULL;
				const gchar* _tmp41_ = NULL;
				const gchar* _tmp42_ = NULL;
				const gchar* _tmp43_ = NULL;
				FontManagerCategory* _tmp44_ = NULL;
				GeeHashSet* _tmp45_ = NULL;
				GeeHashSet* _tmp46_ = NULL;
				gint _tmp47_ = 0;
				gint _tmp48_ = 0;
				_tmp35_ = iter;
				_tmp36_ = filter;
				_tmp37_ = filter;
				_tmp38_ = font_manager_filter_get_icon ((FontManagerFilter*) _tmp37_);
				_tmp39_ = _tmp38_;
				_tmp40_ = filter;
				_tmp41_ = font_manager_filter_get_name ((FontManagerFilter*) _tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = comment;
				_tmp44_ = filter;
				_tmp45_ = font_manager_filter_get_families ((FontManagerFilter*) _tmp44_);
				_tmp46_ = _tmp45_;
				_tmp47_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp46_);
				_tmp48_ = _tmp47_;
				gtk_tree_store_set ((GtkTreeStore*) self, &_tmp35_, 0, _tmp36_, 1, _tmp39_, 2, _tmp42_, 3, _tmp43_, 4, _tmp48_, 5, TRUE, -1, -1);
			}
			_g_free0 (comment);
			comment = NULL;
			{
				GeeArrayList* _child_list = NULL;
				FontManagerCategory* _tmp49_ = NULL;
				GeeArrayList* _tmp50_ = NULL;
				GeeArrayList* _tmp51_ = NULL;
				GeeArrayList* _tmp52_ = NULL;
				gint _child_size = 0;
				GeeArrayList* _tmp53_ = NULL;
				gint _tmp54_ = 0;
				gint _tmp55_ = 0;
				gint _child_index = 0;
				_tmp49_ = filter;
				_tmp50_ = font_manager_category_get_children (_tmp49_);
				_tmp51_ = _tmp50_;
				_tmp52_ = _g_object_ref0 (_tmp51_);
				_child_list = _tmp52_;
				_tmp53_ = _child_list;
				_tmp54_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp53_);
				_tmp55_ = _tmp54_;
				_child_size = _tmp55_;
				_child_index = -1;
				while (TRUE) {
					gint _tmp56_ = 0;
					gint _tmp57_ = 0;
					gint _tmp58_ = 0;
					FontManagerCategory* child = NULL;
					GeeArrayList* _tmp59_ = NULL;
					gint _tmp60_ = 0;
					gpointer _tmp61_ = NULL;
					gchar* child_comment = NULL;
					FontManagerCategory* _tmp62_ = NULL;
					const gchar* _tmp63_ = NULL;
					const gchar* _tmp64_ = NULL;
					gchar* _tmp65_ = NULL;
					GtkTreeIter _iter = {0};
					GtkTreeIter _tmp66_ = {0};
					GtkTreeIter _tmp67_ = {0};
					GtkTreeIter _tmp68_ = {0};
					FontManagerCategory* _tmp69_ = NULL;
					FontManagerCategory* _tmp70_ = NULL;
					const gchar* _tmp71_ = NULL;
					const gchar* _tmp72_ = NULL;
					FontManagerCategory* _tmp73_ = NULL;
					const gchar* _tmp74_ = NULL;
					const gchar* _tmp75_ = NULL;
					const gchar* _tmp76_ = NULL;
					FontManagerCategory* _tmp77_ = NULL;
					GeeHashSet* _tmp78_ = NULL;
					GeeHashSet* _tmp79_ = NULL;
					gint _tmp80_ = 0;
					gint _tmp81_ = 0;
					_tmp56_ = _child_index;
					_child_index = _tmp56_ + 1;
					_tmp57_ = _child_index;
					_tmp58_ = _child_size;
					if (!(_tmp57_ < _tmp58_)) {
						break;
					}
					_tmp59_ = _child_list;
					_tmp60_ = _child_index;
					_tmp61_ = gee_abstract_list_get ((GeeAbstractList*) _tmp59_, _tmp60_);
					child = (FontManagerCategory*) _tmp61_;
					_tmp62_ = child;
					_tmp63_ = font_manager_filter_get_comment ((FontManagerFilter*) _tmp62_);
					_tmp64_ = _tmp63_;
					_tmp65_ = g_markup_escape_text (_tmp64_, (gssize) (-1));
					child_comment = _tmp65_;
					_tmp66_ = iter;
					gtk_tree_store_append ((GtkTreeStore*) self, &_tmp67_, &_tmp66_);
					_iter = _tmp67_;
					_tmp68_ = _iter;
					_tmp69_ = child;
					_tmp70_ = child;
					_tmp71_ = font_manager_filter_get_icon ((FontManagerFilter*) _tmp70_);
					_tmp72_ = _tmp71_;
					_tmp73_ = child;
					_tmp74_ = font_manager_filter_get_name ((FontManagerFilter*) _tmp73_);
					_tmp75_ = _tmp74_;
					_tmp76_ = child_comment;
					_tmp77_ = child;
					_tmp78_ = font_manager_filter_get_families ((FontManagerFilter*) _tmp77_);
					_tmp79_ = _tmp78_;
					_tmp80_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp79_);
					_tmp81_ = _tmp80_;
					gtk_tree_store_set ((GtkTreeStore*) self, &_tmp68_, 0, _tmp69_, 1, _tmp72_, 2, _tmp75_, 3, _tmp76_, 4, _tmp81_, -1, -1);
					_g_free0 (child_comment);
					child_comment = NULL;
					_g_free0 (child_comment);
					_g_object_unref0 (child);
				}
				_g_object_unref0 (_child_list);
			}
			_g_free0 (comment);
			_g_object_unref0 (filter);
		}
		_g_object_unref0 (_filter_list);
	}
	return;
}


FontManagerCategoryModel* font_manager_category_model_construct (GType object_type) {
	FontManagerCategoryModel * self = NULL;
	self = (FontManagerCategoryModel*) g_object_new (object_type, NULL);
	return self;
}


FontManagerCategoryModel* font_manager_category_model_new (void) {
	return font_manager_category_model_construct (FONT_MANAGER_TYPE_CATEGORY_MODEL);
}


FontManagerDatabase* font_manager_category_model_get_database (FontManagerCategoryModel* self) {
	FontManagerDatabase* result;
	FontManagerDatabase* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->db;
	result = _tmp0_;
	return result;
}


void font_manager_category_model_set_database (FontManagerCategoryModel* self, FontManagerDatabase* value) {
	FontManagerDatabase* _tmp0_ = NULL;
	FontManagerDatabase* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->db = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = font_manager_get_default_categories (_tmp1_);
	_g_object_unref0 (self->priv->categories);
	self->priv->categories = _tmp2_;
	font_manager_category_model_update (self);
	g_object_notify ((GObject *) self, "database");
}


static GObject * font_manager_category_model_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FontManagerCategoryModel * self;
	GType* _tmp0_ = NULL;
	GType* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	parent_class = G_OBJECT_CLASS (font_manager_category_model_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModel);
	_tmp0_ = g_new0 (GType, 6);
	_tmp0_[0] = G_TYPE_OBJECT;
	_tmp0_[1] = G_TYPE_STRING;
	_tmp0_[2] = G_TYPE_STRING;
	_tmp0_[3] = G_TYPE_STRING;
	_tmp0_[4] = G_TYPE_INT;
	_tmp0_[5] = G_TYPE_BOOLEAN;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = 6;
	gtk_tree_store_set_column_types ((GtkTreeStore*) self, 6, _tmp1_);
	_tmp1_ = (g_free (_tmp1_), NULL);
	return obj;
}


static void font_manager_category_model_class_init (FontManagerCategoryModelClass * klass) {
	font_manager_category_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerCategoryModelPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_font_manager_category_model_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_manager_category_model_set_property;
	G_OBJECT_CLASS (klass)->constructor = font_manager_category_model_constructor;
	G_OBJECT_CLASS (klass)->finalize = font_manager_category_model_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_CATEGORY_MODEL_DATABASE, g_param_spec_object ("database", "database", "database", FONT_MANAGER_TYPE_DATABASE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void font_manager_category_model_instance_init (FontManagerCategoryModel * self) {
	self->priv = FONT_MANAGER_CATEGORY_MODEL_GET_PRIVATE (self);
}


static void font_manager_category_model_finalize (GObject* obj) {
	FontManagerCategoryModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModel);
	_g_object_unref0 (self->priv->categories);
	G_OBJECT_CLASS (font_manager_category_model_parent_class)->finalize (obj);
}


GType font_manager_category_model_get_type (void) {
	static volatile gsize font_manager_category_model_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_category_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerCategoryModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_category_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerCategoryModel), 0, (GInstanceInitFunc) font_manager_category_model_instance_init, NULL };
		GType font_manager_category_model_type_id;
		font_manager_category_model_type_id = g_type_register_static (gtk_tree_store_get_type (), "FontManagerCategoryModel", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_category_model_type_id__volatile, font_manager_category_model_type_id);
	}
	return font_manager_category_model_type_id__volatile;
}


static void _vala_font_manager_category_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontManagerCategoryModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModel);
	switch (property_id) {
		case FONT_MANAGER_CATEGORY_MODEL_DATABASE:
		g_value_set_object (value, font_manager_category_model_get_database (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_manager_category_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontManagerCategoryModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_CATEGORY_MODEL, FontManagerCategoryModel);
	switch (property_id) {
		case FONT_MANAGER_CATEGORY_MODEL_DATABASE:
		font_manager_category_model_set_database (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GeeArrayList* font_manager_get_default_categories (FontManagerDatabase* db) {
	GeeArrayList* result = NULL;
	GeeHashMap* filters = NULL;
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	FontManagerCategory* _tmp3_ = NULL;
	FontManagerCategory* _tmp4_ = NULL;
	gpointer _tmp5_ = NULL;
	FontManagerCategory* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	FontManagerCategory* _tmp9_ = NULL;
	FontManagerCategory* _tmp10_ = NULL;
	gpointer _tmp11_ = NULL;
	FontManagerCategory* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	FontManagerCategory* _tmp19_ = NULL;
	FontManagerCategory* _tmp20_ = NULL;
	gpointer _tmp21_ = NULL;
	FontManagerCategory* _tmp22_ = NULL;
	FontManagerCategory* _tmp23_ = NULL;
	FontManagerCategory* _tmp24_ = NULL;
	gpointer _tmp25_ = NULL;
	FontManagerCategory* _tmp26_ = NULL;
	FontManagerDatabase* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	FontManagerCategory* _tmp30_ = NULL;
	FontManagerCategory* _tmp31_ = NULL;
	gpointer _tmp32_ = NULL;
	FontManagerCategory* _tmp33_ = NULL;
	FontManagerDatabase* _tmp34_ = NULL;
	const gchar* _tmp35_ = NULL;
	const gchar* _tmp36_ = NULL;
	FontManagerCategory* _tmp37_ = NULL;
	FontManagerCategory* _tmp38_ = NULL;
	gpointer _tmp39_ = NULL;
	FontManagerCategory* _tmp40_ = NULL;
	FontManagerDatabase* _tmp41_ = NULL;
	const gchar* _tmp42_ = NULL;
	const gchar* _tmp43_ = NULL;
	FontManagerCategory* _tmp44_ = NULL;
	FontManagerCategory* _tmp45_ = NULL;
	gpointer _tmp46_ = NULL;
	FontManagerCategory* _tmp47_ = NULL;
	FontManagerDatabase* _tmp48_ = NULL;
	const gchar* _tmp49_ = NULL;
	const gchar* _tmp50_ = NULL;
	FontManagerCategory* _tmp51_ = NULL;
	FontManagerCategory* _tmp52_ = NULL;
	gpointer _tmp53_ = NULL;
	FontManagerCategory* _tmp54_ = NULL;
	FontManagerDatabase* _tmp55_ = NULL;
	const gchar* _tmp56_ = NULL;
	const gchar* _tmp57_ = NULL;
	FontManagerCategory* _tmp58_ = NULL;
	FontManagerCategory* _tmp59_ = NULL;
	gpointer _tmp60_ = NULL;
	FontManagerCategory* _tmp61_ = NULL;
	FontManagerDatabase* _tmp62_ = NULL;
	const gchar* _tmp63_ = NULL;
	const gchar* _tmp64_ = NULL;
	FontManagerCategory* _tmp65_ = NULL;
	FontManagerCategory* _tmp66_ = NULL;
	gpointer _tmp67_ = NULL;
	FontManagerCategory* _tmp68_ = NULL;
	FontManagerDatabase* _tmp69_ = NULL;
	const gchar* _tmp70_ = NULL;
	const gchar* _tmp71_ = NULL;
	FontManagerCategory* _tmp72_ = NULL;
	FontManagerCategory* _tmp73_ = NULL;
	gpointer _tmp74_ = NULL;
	FontManagerCategory* _tmp75_ = NULL;
	FontManagerUnsorted* _tmp76_ = NULL;
	FontManagerUnsorted* _tmp77_ = NULL;
	gpointer _tmp78_ = NULL;
	FontManagerCategory* _tmp79_ = NULL;
	FontManagerDisabled* _tmp80_ = NULL;
	FontManagerDisabled* _tmp81_ = NULL;
	gpointer _tmp82_ = NULL;
	FontManagerCategory* _tmp83_ = NULL;
	GeeArrayList* sorted_filters = NULL;
	GeeArrayList* _tmp84_ = NULL;
	GeeCollection* _tmp85_ = NULL;
	GeeCollection* _tmp86_ = NULL;
	GeeCollection* _tmp87_ = NULL;
	g_return_val_if_fail (db != NULL, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, FONT_MANAGER_TYPE_CATEGORY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	filters = _tmp0_;
	_tmp1_ = _ ("All");
	_tmp2_ = _ ("All Fonts");
	_tmp3_ = font_manager_category_new (_tmp1_, _tmp2_, "format-text-bold", NULL);
	_tmp4_ = _tmp3_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "All", _tmp4_);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "All");
	_tmp6_ = (FontManagerCategory*) _tmp5_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp6_, 0);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = _ ("System");
	_tmp8_ = _ ("Fonts available to all users");
	_tmp9_ = font_manager_category_new (_tmp7_, _tmp8_, "computer", "owner!=0");
	_tmp10_ = _tmp9_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "System", _tmp10_);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "System");
	_tmp12_ = (FontManagerCategory*) _tmp11_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp12_, 1);
	_g_object_unref0 (_tmp12_);
	_tmp13_ = _ ("User");
	_tmp14_ = _ ("Fonts avalable only to you");
	_tmp15_ = get_user_font_dir ();
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strdup_printf ("owner=0 AND filepath LIKE \"%s%\"", _tmp16_);
	_tmp18_ = _tmp17_;
	_tmp19_ = font_manager_category_new (_tmp13_, _tmp14_, "avatar-default", _tmp18_);
	_tmp20_ = _tmp19_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "User", _tmp20_);
	_g_object_unref0 (_tmp20_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp16_);
	_tmp21_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "User");
	_tmp22_ = (FontManagerCategory*) _tmp21_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp22_, 2);
	_g_object_unref0 (_tmp22_);
	_tmp23_ = font_manager_construct_panose_filter ();
	_tmp24_ = _tmp23_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Panose", _tmp24_);
	_g_object_unref0 (_tmp24_);
	_tmp25_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Panose");
	_tmp26_ = (FontManagerCategory*) _tmp25_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp26_, 3);
	_g_object_unref0 (_tmp26_);
	_tmp27_ = db;
	_tmp28_ = _ ("Spacing");
	_tmp29_ = _ ("Grouped by font spacing");
	_tmp30_ = font_manager_construct_filter (_tmp27_, _tmp28_, _tmp29_, "spacing");
	_tmp31_ = _tmp30_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Spacing", _tmp31_);
	_g_object_unref0 (_tmp31_);
	_tmp32_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Spacing");
	_tmp33_ = (FontManagerCategory*) _tmp32_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp33_, 4);
	_g_object_unref0 (_tmp33_);
	_tmp34_ = db;
	_tmp35_ = _ ("Slant");
	_tmp36_ = _ ("Grouped by font angle");
	_tmp37_ = font_manager_construct_filter (_tmp34_, _tmp35_, _tmp36_, "slant");
	_tmp38_ = _tmp37_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Slant", _tmp38_);
	_g_object_unref0 (_tmp38_);
	_tmp39_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Slant");
	_tmp40_ = (FontManagerCategory*) _tmp39_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp40_, 5);
	_g_object_unref0 (_tmp40_);
	_tmp41_ = db;
	_tmp42_ = _ ("Weight");
	_tmp43_ = _ ("Grouped by font weight");
	_tmp44_ = font_manager_construct_filter (_tmp41_, _tmp42_, _tmp43_, "weight");
	_tmp45_ = _tmp44_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Weight", _tmp45_);
	_g_object_unref0 (_tmp45_);
	_tmp46_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Weight");
	_tmp47_ = (FontManagerCategory*) _tmp46_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp47_, 6);
	_g_object_unref0 (_tmp47_);
	_tmp48_ = db;
	_tmp49_ = _ ("Width");
	_tmp50_ = _ ("Grouped by font width");
	_tmp51_ = font_manager_construct_filter (_tmp48_, _tmp49_, _tmp50_, "width");
	_tmp52_ = _tmp51_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Width", _tmp52_);
	_g_object_unref0 (_tmp52_);
	_tmp53_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Width");
	_tmp54_ = (FontManagerCategory*) _tmp53_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp54_, 7);
	_g_object_unref0 (_tmp54_);
	_tmp55_ = db;
	_tmp56_ = _ ("Filetype");
	_tmp57_ = _ ("Grouped by filetype");
	_tmp58_ = font_manager_construct_filter (_tmp55_, _tmp56_, _tmp57_, "filetype");
	_tmp59_ = _tmp58_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Filetype", _tmp59_);
	_g_object_unref0 (_tmp59_);
	_tmp60_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Filetype");
	_tmp61_ = (FontManagerCategory*) _tmp60_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp61_, 8);
	_g_object_unref0 (_tmp61_);
	_tmp62_ = db;
	_tmp63_ = _ ("License");
	_tmp64_ = _ ("Grouped by license type");
	_tmp65_ = font_manager_construct_filter (_tmp62_, _tmp63_, _tmp64_, "license_type");
	_tmp66_ = _tmp65_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "License", _tmp66_);
	_g_object_unref0 (_tmp66_);
	_tmp67_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "License");
	_tmp68_ = (FontManagerCategory*) _tmp67_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp68_, 9);
	_g_object_unref0 (_tmp68_);
	_tmp69_ = db;
	_tmp70_ = _ ("Vendor");
	_tmp71_ = _ ("Grouped by vendor");
	_tmp72_ = font_manager_construct_filter (_tmp69_, _tmp70_, _tmp71_, "vendor");
	_tmp73_ = _tmp72_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Vendor", _tmp73_);
	_g_object_unref0 (_tmp73_);
	_tmp74_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Vendor");
	_tmp75_ = (FontManagerCategory*) _tmp74_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp75_, 10);
	_g_object_unref0 (_tmp75_);
	_tmp76_ = font_manager_unsorted_new ();
	_tmp77_ = _tmp76_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Unsorted", (FontManagerCategory*) _tmp77_);
	_g_object_unref0 (_tmp77_);
	_tmp78_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Unsorted");
	_tmp79_ = (FontManagerCategory*) _tmp78_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp79_, 11);
	_g_object_unref0 (_tmp79_);
	_tmp80_ = font_manager_disabled_new ();
	_tmp81_ = _tmp80_;
	gee_abstract_map_set ((GeeAbstractMap*) filters, "Disabled", (FontManagerCategory*) _tmp81_);
	_g_object_unref0 (_tmp81_);
	_tmp82_ = gee_abstract_map_get ((GeeAbstractMap*) filters, "Disabled");
	_tmp83_ = (FontManagerCategory*) _tmp82_;
	font_manager_filter_set_index ((FontManagerFilter*) _tmp83_, 12);
	_g_object_unref0 (_tmp83_);
	_tmp84_ = gee_array_list_new (FONT_MANAGER_TYPE_CATEGORY, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	sorted_filters = _tmp84_;
	_tmp85_ = gee_abstract_map_get_values ((GeeMap*) filters);
	_tmp86_ = _tmp85_;
	_tmp87_ = _tmp86_;
	gee_array_list_add_all (sorted_filters, _tmp87_);
	_g_object_unref0 (_tmp87_);
	gee_list_sort ((GeeList*) sorted_filters, (GCompareDataFunc) font_manager_sort_on_index, NULL, NULL);
	result = sorted_filters;
	_g_object_unref0 (filters);
	return result;
}


FontManagerCategory* font_manager_construct_panose_filter (void) {
	FontManagerCategory* result = NULL;
	FontManagerCategory* panose = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	FontManagerCategory* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	GeeArrayList* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	FontManagerCategory* _tmp7_ = NULL;
	FontManagerCategory* _tmp8_ = NULL;
	GeeArrayList* _tmp9_ = NULL;
	GeeArrayList* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	FontManagerCategory* _tmp13_ = NULL;
	FontManagerCategory* _tmp14_ = NULL;
	GeeArrayList* _tmp15_ = NULL;
	GeeArrayList* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	const gchar* _tmp18_ = NULL;
	FontManagerCategory* _tmp19_ = NULL;
	FontManagerCategory* _tmp20_ = NULL;
	GeeArrayList* _tmp21_ = NULL;
	GeeArrayList* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	FontManagerCategory* _tmp25_ = NULL;
	FontManagerCategory* _tmp26_ = NULL;
	GeeArrayList* _tmp27_ = NULL;
	GeeArrayList* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	FontManagerCategory* _tmp31_ = NULL;
	FontManagerCategory* _tmp32_ = NULL;
	GeeArrayList* _tmp33_ = NULL;
	GeeArrayList* _tmp34_ = NULL;
	const gchar* _tmp35_ = NULL;
	const gchar* _tmp36_ = NULL;
	FontManagerCategory* _tmp37_ = NULL;
	FontManagerCategory* _tmp38_ = NULL;
	_tmp0_ = _ ("Family Kind");
	_tmp1_ = _ ("Only fonts which include Panose information will be grouped here.");
	_tmp2_ = font_manager_category_new (_tmp0_, _tmp1_, "folder", "panose IS NOT NULL");
	panose = _tmp2_;
	_tmp3_ = font_manager_category_get_children (panose);
	_tmp4_ = _tmp3_;
	_tmp5_ = _ ("Any");
	_tmp6_ = _ ("Any");
	_tmp7_ = font_manager_category_new (_tmp5_, _tmp6_, "emblem-documents", "panose LIKE \"0:%\"");
	_tmp8_ = _tmp7_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = font_manager_category_get_children (panose);
	_tmp10_ = _tmp9_;
	_tmp11_ = _ ("No Fit");
	_tmp12_ = _ ("No Fit");
	_tmp13_ = font_manager_category_new (_tmp11_, _tmp12_, "emblem-documents", "panose LIKE \"1:%\"");
	_tmp14_ = _tmp13_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, _tmp14_);
	_g_object_unref0 (_tmp14_);
	_tmp15_ = font_manager_category_get_children (panose);
	_tmp16_ = _tmp15_;
	_tmp17_ = _ ("Text and Display");
	_tmp18_ = _ ("Text and Display");
	_tmp19_ = font_manager_category_new (_tmp17_, _tmp18_, "emblem-documents", "panose LIKE \"2:%\"");
	_tmp20_ = _tmp19_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp20_);
	_g_object_unref0 (_tmp20_);
	_tmp21_ = font_manager_category_get_children (panose);
	_tmp22_ = _tmp21_;
	_tmp23_ = _ ("Script");
	_tmp24_ = _ ("Script");
	_tmp25_ = font_manager_category_new (_tmp23_, _tmp24_, "emblem-documents", "panose LIKE \"3:%\"");
	_tmp26_ = _tmp25_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp22_, _tmp26_);
	_g_object_unref0 (_tmp26_);
	_tmp27_ = font_manager_category_get_children (panose);
	_tmp28_ = _tmp27_;
	_tmp29_ = _ ("Decorative");
	_tmp30_ = _ ("Decorative");
	_tmp31_ = font_manager_category_new (_tmp29_, _tmp30_, "emblem-documents", "panose LIKE \"4:%\"");
	_tmp32_ = _tmp31_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp28_, _tmp32_);
	_g_object_unref0 (_tmp32_);
	_tmp33_ = font_manager_category_get_children (panose);
	_tmp34_ = _tmp33_;
	_tmp35_ = _ ("Pictorial");
	_tmp36_ = _ ("Pictorial");
	_tmp37_ = font_manager_category_new (_tmp35_, _tmp36_, "emblem-documents", "panose LIKE \"5:%\"");
	_tmp38_ = _tmp37_;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp34_, _tmp38_);
	_g_object_unref0 (_tmp38_);
	result = panose;
	return result;
}


FontManagerCategory* font_manager_construct_filter (FontManagerDatabase* db, const gchar* name, const gchar* comment, const gchar* keyword) {
	FontManagerCategory* result = NULL;
	FontManagerCategory* filter = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	FontManagerCategory* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (db != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (comment != NULL, NULL);
	g_return_val_if_fail (keyword != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = comment;
	_tmp2_ = font_manager_category_new (_tmp0_, _tmp1_, "folder", NULL);
	filter = _tmp2_;
	{
		FontManagerDatabase* _tmp3_ = NULL;
		GeeArrayList* _tmp4_ = NULL;
		GeeArrayList* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp3_ = db;
		_tmp4_ = font_manager_category_get_children (filter);
		_tmp5_ = _tmp4_;
		_tmp6_ = keyword;
		font_manager_add_children_from_db_results (_tmp3_, _tmp5_, _tmp6_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch42_font_manager_database_error;
			}
			_g_object_unref0 (filter);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	goto __finally42;
	__catch42_font_manager_database_error:
	{
		GError* e = NULL;
		const gchar* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		GError* _tmp11_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = name;
		g_warning ("CategoryModel.vala:122: Failed to create child categories for %s", _tmp7_);
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		g_critical ("CategoryModel.vala:123: Database error : %s", _tmp9_);
		_tmp10_ = _ ("There was an error accessing the database");
		_tmp11_ = e;
		font_manager_show_error_message (_tmp10_, _tmp11_, NULL);
		_g_error_free0 (e);
	}
	__finally42:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (filter);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = filter;
	return result;
}


void font_manager_add_children_from_db_results (FontManagerDatabase* db, GeeArrayList* filters, const gchar* keyword, GError** error) {
	FontManagerDatabase* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (db != NULL);
	g_return_if_fail (filters != NULL);
	g_return_if_fail (keyword != NULL);
	_tmp0_ = db;
	_tmp1_ = keyword;
	_tmp2_ = keyword;
	_tmp3_ = g_strdup_printf ("SELECT DISTINCT %s FROM Fonts ORDER BY %s;", _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	font_manager_database_execute_query (_tmp0_, _tmp4_, &_inner_error_);
	_g_free0 (_tmp4_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		FontManagerDatabaseIterator* _row_it = NULL;
		FontManagerDatabase* _tmp5_ = NULL;
		FontManagerDatabaseIterator* _tmp6_ = NULL;
		sqlite3_stmt* row = NULL;
		_tmp5_ = db;
		_tmp6_ = font_manager_database_iterator (_tmp5_);
		_row_it = _tmp6_;
		while (TRUE) {
			FontManagerDatabaseIterator* _tmp7_ = NULL;
			sqlite3_stmt* _tmp8_ = NULL;
			sqlite3_stmt* _tmp9_ = NULL;
			sqlite3_stmt* _tmp10_ = NULL;
			gint _tmp11_ = 0;
			_tmp7_ = _row_it;
			_tmp8_ = font_manager_database_iterator_next_value (_tmp7_);
			row = _tmp8_;
			_tmp9_ = row;
			if (!(_tmp9_ != NULL)) {
				break;
			}
			_tmp10_ = row;
			_tmp11_ = sqlite3_column_type (_tmp10_, 0);
			if (_tmp11_ == SQLITE3_TEXT) {
				gchar* type = NULL;
				sqlite3_stmt* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				GeeArrayList* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_ = NULL;
				FontManagerCategory* _tmp22_ = NULL;
				FontManagerCategory* _tmp23_ = NULL;
				_tmp12_ = row;
				_tmp13_ = sqlite3_column_text (_tmp12_, 0);
				_tmp14_ = g_strdup (_tmp13_);
				type = _tmp14_;
				_tmp15_ = filters;
				_tmp16_ = type;
				_tmp17_ = type;
				_tmp18_ = keyword;
				_tmp19_ = type;
				_tmp20_ = g_strdup_printf ("%s='%s'", _tmp18_, _tmp19_);
				_tmp21_ = _tmp20_;
				_tmp22_ = font_manager_category_new (_tmp16_, _tmp17_, "emblem-documents", _tmp21_);
				_tmp23_ = _tmp22_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, _tmp23_);
				_g_object_unref0 (_tmp23_);
				_g_free0 (_tmp21_);
				_g_free0 (type);
			} else {
				gchar* type = NULL;
				gint val = 0;
				sqlite3_stmt* _tmp24_ = NULL;
				gint _tmp25_ = 0;
				const gchar* _tmp26_ = NULL;
				const gchar* _tmp37_ = NULL;
				GeeArrayList* _tmp45_ = NULL;
				const gchar* _tmp46_ = NULL;
				const gchar* _tmp47_ = NULL;
				const gchar* _tmp48_ = NULL;
				gint _tmp49_ = 0;
				gchar* _tmp50_ = NULL;
				gchar* _tmp51_ = NULL;
				FontManagerCategory* _tmp52_ = NULL;
				FontManagerCategory* _tmp53_ = NULL;
				_tmp24_ = row;
				_tmp25_ = sqlite3_column_int (_tmp24_, 0);
				val = _tmp25_;
				_tmp26_ = keyword;
				if (g_strcmp0 (_tmp26_, "slant") == 0) {
					gint _tmp27_ = 0;
					gchar* _tmp28_ = NULL;
					_tmp27_ = val;
					_tmp28_ = font_config_slant_to_string ((FontConfigSlant) _tmp27_);
					_g_free0 (type);
					type = _tmp28_;
				} else {
					const gchar* _tmp29_ = NULL;
					_tmp29_ = keyword;
					if (g_strcmp0 (_tmp29_, "weight") == 0) {
						gint _tmp30_ = 0;
						gchar* _tmp31_ = NULL;
						_tmp30_ = val;
						_tmp31_ = font_config_weight_to_string ((FontConfigWeight) _tmp30_);
						_g_free0 (type);
						type = _tmp31_;
					} else {
						const gchar* _tmp32_ = NULL;
						_tmp32_ = keyword;
						if (g_strcmp0 (_tmp32_, "width") == 0) {
							gint _tmp33_ = 0;
							gchar* _tmp34_ = NULL;
							_tmp33_ = val;
							_tmp34_ = font_config_width_to_string ((FontConfigWidth) _tmp33_);
							_g_free0 (type);
							type = _tmp34_;
						} else {
							gint _tmp35_ = 0;
							gchar* _tmp36_ = NULL;
							_tmp35_ = val;
							_tmp36_ = font_config_spacing_to_string ((FontConfigSpacing) _tmp35_);
							_g_free0 (type);
							type = _tmp36_;
						}
					}
				}
				_tmp37_ = type;
				if (_tmp37_ == NULL) {
					gboolean _tmp38_ = FALSE;
					const gchar* _tmp39_ = NULL;
					_tmp39_ = keyword;
					if (g_strcmp0 (_tmp39_, "slant") == 0) {
						_tmp38_ = TRUE;
					} else {
						const gchar* _tmp40_ = NULL;
						_tmp40_ = keyword;
						_tmp38_ = g_strcmp0 (_tmp40_, "width") == 0;
					}
					if (_tmp38_) {
						const gchar* _tmp41_ = NULL;
						gchar* _tmp42_ = NULL;
						_tmp41_ = _ ("Normal");
						_tmp42_ = g_strdup (_tmp41_);
						_g_free0 (type);
						type = _tmp42_;
					} else {
						const gchar* _tmp43_ = NULL;
						gchar* _tmp44_ = NULL;
						_tmp43_ = _ ("Regular");
						_tmp44_ = g_strdup (_tmp43_);
						_g_free0 (type);
						type = _tmp44_;
					}
				}
				_tmp45_ = filters;
				_tmp46_ = type;
				_tmp47_ = type;
				_tmp48_ = keyword;
				_tmp49_ = val;
				_tmp50_ = g_strdup_printf ("%s='%i'", _tmp48_, _tmp49_);
				_tmp51_ = _tmp50_;
				_tmp52_ = font_manager_category_new (_tmp46_, _tmp47_, "emblem-documents", _tmp51_);
				_tmp53_ = _tmp52_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp45_, _tmp53_);
				_g_object_unref0 (_tmp53_);
				_g_free0 (_tmp51_);
				_g_free0 (type);
			}
		}
		_font_manager_database_iterator_unref0 (_row_it);
	}
}



