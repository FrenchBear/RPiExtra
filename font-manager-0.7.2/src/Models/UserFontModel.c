/* UserFontModel.c generated by valac 0.26.1, the Vala compiler
 * generated from UserFontModel.vala, do not modify */

/* UserFontModel.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define FONT_MANAGER_TYPE_FONT_MODEL (font_manager_font_model_get_type ())
#define FONT_MANAGER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModel))
#define FONT_MANAGER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))
#define FONT_MANAGER_IS_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_IS_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_MODEL))
#define FONT_MANAGER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_MODEL, FontManagerFontModelClass))

typedef struct _FontManagerFontModel FontManagerFontModel;
typedef struct _FontManagerFontModelClass FontManagerFontModelClass;
typedef struct _FontManagerFontModelPrivate FontManagerFontModelPrivate;

#define FONT_MANAGER_TYPE_USER_FONT_MODEL (font_manager_user_font_model_get_type ())
#define FONT_MANAGER_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel))
#define FONT_MANAGER_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))
#define FONT_MANAGER_IS_USER_FONT_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_IS_USER_FONT_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_USER_FONT_MODEL))
#define FONT_MANAGER_USER_FONT_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelClass))

typedef struct _FontManagerUserFontModel FontManagerUserFontModel;
typedef struct _FontManagerUserFontModelClass FontManagerUserFontModelClass;
typedef struct _FontManagerUserFontModelPrivate FontManagerUserFontModelPrivate;

#define FONT_MANAGER_TYPE_DATABASE (font_manager_database_get_type ())
#define FONT_MANAGER_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabase))
#define FONT_MANAGER_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))
#define FONT_MANAGER_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))

typedef struct _FontManagerDatabase FontManagerDatabase;
typedef struct _FontManagerDatabaseClass FontManagerDatabaseClass;

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_MANAGER_TYPE_FILTER (font_manager_filter_get_type ())
#define FONT_MANAGER_FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilter))
#define FONT_MANAGER_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))
#define FONT_MANAGER_IS_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_IS_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FILTER))
#define FONT_MANAGER_FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FILTER, FontManagerFilterClass))

typedef struct _FontManagerFilter FontManagerFilter;
typedef struct _FontManagerFilterClass FontManagerFilterClass;

#define FONT_MANAGER_TYPE_CATEGORY (font_manager_category_get_type ())
#define FONT_MANAGER_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategory))
#define FONT_MANAGER_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))
#define FONT_MANAGER_IS_CATEGORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_IS_CATEGORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_CATEGORY))
#define FONT_MANAGER_CATEGORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_CATEGORY, FontManagerCategoryClass))

typedef struct _FontManagerCategory FontManagerCategory;
typedef struct _FontManagerCategoryClass FontManagerCategoryClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FONT_CONFIG_TYPE_FAMILIES (font_config_families_get_type ())
#define FONT_CONFIG_FAMILIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamilies))
#define FONT_CONFIG_FAMILIES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamiliesClass))
#define FONT_CONFIG_IS_FAMILIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FAMILIES))
#define FONT_CONFIG_IS_FAMILIES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FAMILIES))
#define FONT_CONFIG_FAMILIES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FAMILIES, FontConfigFamiliesClass))

typedef struct _FontConfigFamilies FontConfigFamilies;
typedef struct _FontConfigFamiliesClass FontConfigFamiliesClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _FontManagerFontModel {
	GtkTreeStore parent_instance;
	FontManagerFontModelPrivate * priv;
};

struct _FontManagerFontModelClass {
	GtkTreeStoreClass parent_class;
};

struct _FontManagerUserFontModel {
	FontManagerFontModel parent_instance;
	FontManagerUserFontModelPrivate * priv;
};

struct _FontManagerUserFontModelClass {
	FontManagerFontModelClass parent_class;
};

struct _FontManagerUserFontModelPrivate {
	FontManagerDatabase* _db;
	FontManagerCategory* user_fonts;
};


static gpointer font_manager_user_font_model_parent_class = NULL;

GType font_manager_font_model_get_type (void) G_GNUC_CONST;
GType font_manager_user_font_model_get_type (void) G_GNUC_CONST;
GType font_manager_database_get_type (void) G_GNUC_CONST;
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_manager_filter_get_type (void) G_GNUC_CONST;
GType font_manager_category_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_USER_FONT_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModelPrivate))
enum  {
	FONT_MANAGER_USER_FONT_MODEL_DUMMY_PROPERTY,
	FONT_MANAGER_USER_FONT_MODEL_DB
};
GType font_config_families_get_type (void) G_GNUC_CONST;
FontManagerUserFontModel* font_manager_user_font_model_new (FontConfigFamilies* families, FontManagerDatabase* db);
FontManagerUserFontModel* font_manager_user_font_model_construct (GType object_type, FontConfigFamilies* families, FontManagerDatabase* db);
FontManagerFontModel* font_manager_font_model_new (void);
FontManagerFontModel* font_manager_font_model_construct (GType object_type);
void font_manager_user_font_model_set_db (FontManagerUserFontModel* self, FontManagerDatabase* value);
gchar* get_user_font_dir (void);
FontManagerCategory* font_manager_category_new (const gchar* name, const gchar* comment, const gchar* icon, const gchar* condition);
FontManagerCategory* font_manager_category_construct (GType object_type, const gchar* name, const gchar* comment, const gchar* icon, const gchar* condition);
void font_manager_category_update (FontManagerCategory* self, FontManagerDatabase* db);
void font_manager_font_model_set_families (FontManagerFontModel* self, FontConfigFamilies* value);
void font_manager_font_model_update (FontManagerFontModel* self, FontManagerFilter* filter);
FontManagerDatabase* font_manager_user_font_model_get_db (FontManagerUserFontModel* self);
static void font_manager_user_font_model_finalize (GObject* obj);
static void _vala_font_manager_user_font_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_manager_user_font_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


FontManagerUserFontModel* font_manager_user_font_model_construct (GType object_type, FontConfigFamilies* families, FontManagerDatabase* db) {
	FontManagerUserFontModel * self = NULL;
	FontManagerDatabase* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	FontManagerCategory* _tmp5_ = NULL;
	FontManagerCategory* _tmp6_ = NULL;
	FontManagerDatabase* _tmp7_ = NULL;
	FontConfigFamilies* _tmp8_ = NULL;
	FontManagerCategory* _tmp9_ = NULL;
	g_return_val_if_fail (families != NULL, NULL);
	g_return_val_if_fail (db != NULL, NULL);
	self = (FontManagerUserFontModel*) font_manager_font_model_construct (object_type);
	_tmp0_ = db;
	font_manager_user_font_model_set_db (self, _tmp0_);
	_tmp1_ = get_user_font_dir ();
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("owner=0 AND filepath LIKE \"%s%\"", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = font_manager_category_new ("", "", "", _tmp4_);
	_g_object_unref0 (self->priv->user_fonts);
	self->priv->user_fonts = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	_tmp6_ = self->priv->user_fonts;
	_tmp7_ = db;
	font_manager_category_update (_tmp6_, _tmp7_);
	_tmp8_ = families;
	font_manager_font_model_set_families ((FontManagerFontModel*) self, _tmp8_);
	_tmp9_ = self->priv->user_fonts;
	font_manager_font_model_update ((FontManagerFontModel*) self, (FontManagerFilter*) _tmp9_);
	return self;
}


FontManagerUserFontModel* font_manager_user_font_model_new (FontConfigFamilies* families, FontManagerDatabase* db) {
	return font_manager_user_font_model_construct (FONT_MANAGER_TYPE_USER_FONT_MODEL, families, db);
}


FontManagerDatabase* font_manager_user_font_model_get_db (FontManagerUserFontModel* self) {
	FontManagerDatabase* result;
	FontManagerDatabase* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_db;
	result = _tmp0_;
	return result;
}


void font_manager_user_font_model_set_db (FontManagerUserFontModel* self, FontManagerDatabase* value) {
	FontManagerDatabase* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_db = _tmp0_;
	g_object_notify ((GObject *) self, "db");
}


static void font_manager_user_font_model_class_init (FontManagerUserFontModelClass * klass) {
	font_manager_user_font_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerUserFontModelPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_font_manager_user_font_model_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_manager_user_font_model_set_property;
	G_OBJECT_CLASS (klass)->finalize = font_manager_user_font_model_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_USER_FONT_MODEL_DB, g_param_spec_object ("db", "db", "db", FONT_MANAGER_TYPE_DATABASE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void font_manager_user_font_model_instance_init (FontManagerUserFontModel * self) {
	self->priv = FONT_MANAGER_USER_FONT_MODEL_GET_PRIVATE (self);
}


static void font_manager_user_font_model_finalize (GObject* obj) {
	FontManagerUserFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel);
	_g_object_unref0 (self->priv->user_fonts);
	G_OBJECT_CLASS (font_manager_user_font_model_parent_class)->finalize (obj);
}


GType font_manager_user_font_model_get_type (void) {
	static volatile gsize font_manager_user_font_model_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_user_font_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerUserFontModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_user_font_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerUserFontModel), 0, (GInstanceInitFunc) font_manager_user_font_model_instance_init, NULL };
		GType font_manager_user_font_model_type_id;
		font_manager_user_font_model_type_id = g_type_register_static (FONT_MANAGER_TYPE_FONT_MODEL, "FontManagerUserFontModel", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_user_font_model_type_id__volatile, font_manager_user_font_model_type_id);
	}
	return font_manager_user_font_model_type_id__volatile;
}


static void _vala_font_manager_user_font_model_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontManagerUserFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel);
	switch (property_id) {
		case FONT_MANAGER_USER_FONT_MODEL_DB:
		g_value_set_object (value, font_manager_user_font_model_get_db (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_manager_user_font_model_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontManagerUserFontModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_TYPE_USER_FONT_MODEL, FontManagerUserFontModel);
	switch (property_id) {
		case FONT_MANAGER_USER_FONT_MODEL_DB:
		font_manager_user_font_model_set_db (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



