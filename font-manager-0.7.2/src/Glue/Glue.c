/* Glue.c generated by valac 0.26.1, the Vala compiler
 * generated from Glue.vala, do not modify */

/* Glue.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gee.h>


#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_MANAGER_TYPE_FONT_INFO (font_manager_font_info_get_type ())
#define FONT_MANAGER_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfo))
#define FONT_MANAGER_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))
#define FONT_MANAGER_IS_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_IS_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_FONT_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))

typedef struct _FontManagerFontInfo FontManagerFontInfo;
typedef struct _FontManagerFontInfoClass FontManagerFontInfoClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define FONT_CONFIG_TYPE_FONT (font_config_font_get_type ())
#define FONT_CONFIG_FONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFont))
#define FONT_CONFIG_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))
#define FONT_CONFIG_IS_FONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_FONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))

typedef struct _FontConfigFont FontConfigFont;
typedef struct _FontConfigFontClass FontConfigFontClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))



gint free_type_num_faces (const gchar* filepath);
glong get_face_count (const gchar* filepath);
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_manager_font_info_get_type (void) G_GNUC_CONST;
gint free_type_query_file_info (FontManagerFontInfo* fileinfo, const gchar* filepath, gint index);
gint get_file_info (FontManagerFontInfo* fileinfo, const gchar* filepath, gint index);
gchar* font_config_get_version_string (void);
gint FcGetVersion (void);
gboolean font_config_update_cache (void);
gboolean FcCacheUpdate (void);
GType font_config_font_get_type (void) G_GNUC_CONST;
FontConfigFont* font_config_get_font_from_file (const gchar* filepath, gint index);
FontConfigFont* FcGetFontFromFile (const gchar* filepath, gint index);
GeeArrayList* font_config_list_fonts (const gchar* family_name);
GeeArrayList* FcListFonts (const gchar* family_name);
GeeArrayList* font_config_list_families (void);
GeeArrayList* FcListFamilies (void);
GeeArrayList* font_config_list_files (void);
GeeArrayList* FcListFiles (void);
GeeArrayList* font_config_list_dirs (gboolean recursive);
GeeArrayList* FcListDirs (gboolean recursive);
GeeArrayList* font_config_list_user_dirs (void);
GeeArrayList* FcListUserDirs (void);
gboolean font_config_enable_user_config (gboolean enable);
gboolean FcEnableUserConfig (gboolean enable);
gboolean font_config_add_app_font (const gchar* filepath);
gboolean FcAddAppFont (const gchar* filepath);
gboolean font_config_add_app_font_dir (const gchar* dir);
gboolean FcAddAppFontDir (const gchar* dir);
void font_config_clear_app_fonts (void);
void FcClearAppFonts (void);
gboolean font_config_load_config (const gchar* filepath);
gboolean FcLoadConfig (const gchar* filepath);


gint free_type_num_faces (const gchar* filepath) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	g_return_val_if_fail (filepath != NULL, 0);
	_tmp0_ = filepath;
	_tmp1_ = get_face_count (_tmp0_);
	result = (gint) _tmp1_;
	return result;
}


gint free_type_query_file_info (FontManagerFontInfo* fileinfo, const gchar* filepath, gint index) {
	gint result = 0;
	FontManagerFontInfo* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	g_return_val_if_fail (fileinfo != NULL, 0);
	g_return_val_if_fail (filepath != NULL, 0);
	_tmp0_ = fileinfo;
	_tmp1_ = filepath;
	_tmp2_ = index;
	_tmp3_ = get_file_info (_tmp0_, _tmp1_, _tmp2_);
	result = (gint) _tmp3_;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


gchar* font_config_get_version_string (void) {
	gchar* result = NULL;
	gchar* raw = NULL;
	gint _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	gchar _tmp2_ = '\0';
	gchar _tmp3_ = '\0';
	gchar _tmp4_ = '\0';
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	_tmp0_ = FcGetVersion ();
	_tmp1_ = g_strdup_printf ("%i", _tmp0_);
	raw = _tmp1_;
	_tmp2_ = string_get (raw, (glong) 0);
	_tmp3_ = string_get (raw, (glong) 1);
	_tmp4_ = string_get (raw, (glong) 2);
	_tmp5_ = string_substring (raw, (glong) 3, (glong) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strdup_printf ("%c.%c%c.%s", (gint) _tmp2_, (gint) _tmp3_, (gint) _tmp4_, _tmp6_);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	result = _tmp8_;
	_g_free0 (raw);
	return result;
}


gboolean font_config_update_cache (void) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = FcCacheUpdate ();
	result = _tmp0_;
	return result;
}


FontConfigFont* font_config_get_font_from_file (const gchar* filepath, gint index) {
	FontConfigFont* result = NULL;
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	FontConfigFont* _tmp6_ = NULL;
	FontConfigFont* _tmp7_ = NULL;
	g_return_val_if_fail (filepath != NULL, NULL);
	_tmp0_ = filepath;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_get_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = index;
	_tmp6_ = FcGetFontFromFile (_tmp4_, _tmp5_);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp4_);
	_g_object_unref0 (_tmp2_);
	result = _tmp7_;
	return result;
}


GeeArrayList* font_config_list_fonts (const gchar* family_name) {
	GeeArrayList* result = NULL;
	const gchar* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	_tmp0_ = family_name;
	_tmp1_ = FcListFonts (_tmp0_);
	result = _tmp1_;
	return result;
}


GeeArrayList* font_config_list_families (void) {
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = FcListFamilies ();
	result = _tmp0_;
	return result;
}


GeeArrayList* font_config_list_files (void) {
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = FcListFiles ();
	result = _tmp0_;
	return result;
}


GeeArrayList* font_config_list_dirs (gboolean recursive) {
	GeeArrayList* result = NULL;
	gboolean _tmp0_ = FALSE;
	GeeArrayList* _tmp1_ = NULL;
	_tmp0_ = recursive;
	_tmp1_ = FcListDirs (_tmp0_);
	result = _tmp1_;
	return result;
}


GeeArrayList* font_config_list_user_dirs (void) {
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	_tmp0_ = FcListUserDirs ();
	result = _tmp0_;
	return result;
}


gboolean font_config_enable_user_config (gboolean enable) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	_tmp0_ = enable;
	_tmp1_ = FcEnableUserConfig (_tmp0_);
	result = _tmp1_;
	return result;
}


gboolean font_config_add_app_font (const gchar* filepath) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (filepath != NULL, FALSE);
	_tmp0_ = filepath;
	_tmp1_ = FcAddAppFont (_tmp0_);
	result = _tmp1_;
	return result;
}


gboolean font_config_add_app_font_dir (const gchar* dir) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (dir != NULL, FALSE);
	_tmp0_ = dir;
	_tmp1_ = FcAddAppFontDir (_tmp0_);
	result = _tmp1_;
	return result;
}


void font_config_clear_app_fonts (void) {
	FcClearAppFonts ();
	return;
}


gboolean font_config_load_config (const gchar* filepath) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (filepath != NULL, FALSE);
	_tmp0_ = filepath;
	_tmp1_ = FcLoadConfig (_tmp0_);
	result = _tmp1_;
	return result;
}



