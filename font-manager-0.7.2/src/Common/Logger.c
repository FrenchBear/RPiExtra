/* Logger.c generated by valac 0.26.1, the Vala compiler
 * generated from Logger.vala, do not modify */

/* Logger.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <json-glib/json-glib.h>
#include <sqlite3.h>
#include <pango/pango.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <stdarg.h>
#include <stdio.h>


#define TYPE_LOG_LEVEL (log_level_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CONSOLE_COLOR (console_color_get_type ())

#define TYPE_LOGGER (logger_get_type ())
#define LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGGER, Logger))
#define LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGGER, LoggerClass))
#define IS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGGER))
#define IS_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGGER))
#define LOGGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGGER, LoggerClass))

typedef struct _Logger Logger;
typedef struct _LoggerClass LoggerClass;
typedef struct _LoggerPrivate LoggerPrivate;

#define LOGGER_TYPE_LOG_MESSAGE (logger_log_message_get_type ())
#define LOGGER_LOG_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessage))
#define LOGGER_LOG_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessageClass))
#define LOGGER_IS_LOG_MESSAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LOGGER_TYPE_LOG_MESSAGE))
#define LOGGER_IS_LOG_MESSAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LOGGER_TYPE_LOG_MESSAGE))
#define LOGGER_LOG_MESSAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessageClass))

typedef struct _LoggerLogMessage LoggerLogMessage;
typedef struct _LoggerLogMessageClass LoggerLogMessageClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _LoggerLogMessagePrivate LoggerLogMessagePrivate;

typedef enum  {
	LOG_LEVEL_VERBOSE,
	LOG_LEVEL_DEBUG,
	LOG_LEVEL_INFO,
	LOG_LEVEL_NOTIFY,
	LOG_LEVEL_WARN,
	LOG_LEVEL_ERROR,
	LOG_LEVEL_FATAL
} LogLevel;

typedef enum  {
	CONSOLE_COLOR_BLACK,
	CONSOLE_COLOR_RED,
	CONSOLE_COLOR_GREEN,
	CONSOLE_COLOR_YELLOW,
	CONSOLE_COLOR_BLUE,
	CONSOLE_COLOR_MAGENTA,
	CONSOLE_COLOR_CYAN,
	CONSOLE_COLOR_WHITE
} ConsoleColor;

struct _Logger {
	GObject parent_instance;
	LoggerPrivate * priv;
};

struct _LoggerClass {
	GObjectClass parent_class;
};

struct _LoggerLogMessage {
	GObject parent_instance;
	LoggerLogMessagePrivate * priv;
};

struct _LoggerLogMessageClass {
	GObjectClass parent_class;
};

struct _LoggerLogMessagePrivate {
	LogLevel _level;
	gchar* _message;
};


static gpointer logger_parent_class = NULL;
static LogLevel logger__DisplayLevel;
static LogLevel logger__DisplayLevel = LOG_LEVEL_WARN;
static gchar* logger__name;
static gchar* logger__name = NULL;
static GObject* logger_queue_lock;
static GRecMutex __lock_logger_queue_lock = {0};
static GObject* logger_queue_lock = NULL;
static GeeArrayList* logger_log_queue;
static GeeArrayList* logger_log_queue = NULL;
static gboolean logger_is_writing;
static gboolean logger_is_writing = FALSE;
static GRegex* logger_re;
static GRegex* logger_re = NULL;
static gpointer logger_log_message_parent_class = NULL;

GType log_level_get_type (void) G_GNUC_CONST;
void logging_setup (LogLevel level);
void logger_initialize (const gchar* app_name);
#define FONT_MANAGER_ABOUT_NAME _ ("Font Manager")
LogLevel logger_get_DisplayLevel (void);
void logger_set_DisplayLevel (LogLevel value);
void logging_show_version_information (void);
#define FONT_MANAGER_ABOUT_VERSION "0.7.2"
gchar* font_config_get_version_string (void);
gboolean Gnome3 (void);
gchar* get_command_line_output (const gchar* cmd);
gchar* log_level_to_string (LogLevel self);
GType console_color_get_type (void) G_GNUC_CONST;
GType logger_get_type (void) G_GNUC_CONST;
enum  {
	LOGGER_DUMMY_PROPERTY
};
static GType logger_log_message_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static const gchar* logger_get_name (void);
static void logger_set_name (const gchar* value);
static void logger_glib_log_func (const gchar* d, GLogLevelFlags flags, const gchar* msg);
static void _logger_glib_log_func_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
static gchar* logger_format_message (const gchar* msg);
void logger_notification (const gchar* msg, const gchar* icon);
static void logger_write (LogLevel level, const gchar* msg);
void logger_verbose (const gchar* msg, ...);
static gchar* logger_get_time (void);
static LoggerLogMessage* logger_log_message_new (LogLevel level, const gchar* message);
static LoggerLogMessage* logger_log_message_construct (GType object_type, LogLevel level, const gchar* message);
static void logger_print_log (LoggerLogMessage* log);
static void logger_set_color_for_level (LogLevel level);
static LogLevel logger_log_message_get_level (LoggerLogMessage* self);
void logger_reset_color (void);
static const gchar* logger_log_message_get_message (LoggerLogMessage* self);
void logger_set_foreground (ConsoleColor color);
void logger_set_background (ConsoleColor color);
static void logger_set_color (ConsoleColor color, gboolean isForeground);
Logger* logger_new (void);
Logger* logger_construct (GType object_type);
#define LOGGER_LOG_MESSAGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessagePrivate))
enum  {
	LOGGER_LOG_MESSAGE_DUMMY_PROPERTY,
	LOGGER_LOG_MESSAGE_LEVEL,
	LOGGER_LOG_MESSAGE_MESSAGE
};
static void logger_log_message_set_level (LoggerLogMessage* self, LogLevel value);
static void logger_log_message_set_message (LoggerLogMessage* self, const gchar* value);
static void logger_log_message_finalize (GObject* obj);
static void _vala_logger_log_message_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_logger_log_message_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void logger_finalize (GObject* obj);
static void _vala_logger_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_logger_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


void logging_setup (LogLevel level) {
	LogLevel _tmp0_ = 0;
	LogLevel _tmp1_ = 0;
	LogLevel _tmp2_ = 0;
	logger_initialize (FONT_MANAGER_ABOUT_NAME);
	_tmp0_ = logger_get_DisplayLevel ();
	_tmp1_ = _tmp0_;
	_tmp2_ = level;
	logger_set_DisplayLevel (_tmp2_);
	return;
}


void logging_show_version_information (void) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_message ("Logger.vala:33: %s %s", FONT_MANAGER_ABOUT_NAME, FONT_MANAGER_ABOUT_VERSION);
	g_message ("Logger.vala:34: Using GLib %u.%u.%u", glib_major_version, glib_minor_version, glib_micro_version);
	g_message ("Logger.vala:35: Using JSON-GLib %s", JSON_VERSION_S);
	g_message ("Logger.vala:36: Using SQLite %s", SQLITE_VERSION);
	_tmp0_ = font_config_get_version_string ();
	_tmp1_ = _tmp0_;
	g_message ("Logger.vala:37: Using FontConfig %s", _tmp1_);
	_g_free0 (_tmp1_);
	_tmp2_ = pango_version_string ();
	g_message ("Logger.vala:38: Using Pango %s", _tmp2_);
	g_message ("Logger.vala:39: Using GTK+ %i.%i.%i", GTK_MAJOR_VERSION, GTK_MINOR_VERSION, GTK_MICRO_VERSION);
	_tmp3_ = Gnome3 ();
	if (_tmp3_) {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = get_command_line_output ("gnome-shell --version");
		_tmp5_ = _tmp4_;
		g_message ("Logger.vala:41: Running on %s", _tmp5_);
		_g_free0 (_tmp5_);
	} else {
		const gchar* _tmp6_ = NULL;
		_tmp6_ = g_getenv ("XDG_CURRENT_DESKTOP");
		g_message ("Logger.vala:43: Running on %s", _tmp6_);
	}
	return;
}


gchar* log_level_to_string (LogLevel self) {
	gchar* result = NULL;
	switch (self) {
		case LOG_LEVEL_DEBUG:
		case LOG_LEVEL_VERBOSE:
		{
			gchar* _tmp0_ = NULL;
			_tmp0_ = g_strdup ("DEBUG");
			result = _tmp0_;
			return result;
		}
		case LOG_LEVEL_WARN:
		{
			gchar* _tmp1_ = NULL;
			_tmp1_ = g_strdup ("WARNING");
			result = _tmp1_;
			return result;
		}
		case LOG_LEVEL_ERROR:
		{
			gchar* _tmp2_ = NULL;
			_tmp2_ = g_strdup ("ERROR");
			result = _tmp2_;
			return result;
		}
		case LOG_LEVEL_FATAL:
		{
			gchar* _tmp3_ = NULL;
			_tmp3_ = g_strdup ("FATAL");
			result = _tmp3_;
			return result;
		}
		default:
		{
			gchar* _tmp4_ = NULL;
			_tmp4_ = g_strdup ("INFO");
			result = _tmp4_;
			return result;
		}
	}
}


/**
 * Controls what messages show in the console log.
 */
GType log_level_get_type (void) {
	static volatile gsize log_level_type_id__volatile = 0;
	if (g_once_init_enter (&log_level_type_id__volatile)) {
		static const GEnumValue values[] = {{LOG_LEVEL_VERBOSE, "LOG_LEVEL_VERBOSE", "verbose"}, {LOG_LEVEL_DEBUG, "LOG_LEVEL_DEBUG", "debug"}, {LOG_LEVEL_INFO, "LOG_LEVEL_INFO", "info"}, {LOG_LEVEL_NOTIFY, "LOG_LEVEL_NOTIFY", "notify"}, {LOG_LEVEL_WARN, "LOG_LEVEL_WARN", "warn"}, {LOG_LEVEL_ERROR, "LOG_LEVEL_ERROR", "error"}, {LOG_LEVEL_FATAL, "LOG_LEVEL_FATAL", "fatal"}, {0, NULL, NULL}};
		GType log_level_type_id;
		log_level_type_id = g_enum_register_static ("LogLevel", values);
		g_once_init_leave (&log_level_type_id__volatile, log_level_type_id);
	}
	return log_level_type_id__volatile;
}


GType console_color_get_type (void) {
	static volatile gsize console_color_type_id__volatile = 0;
	if (g_once_init_enter (&console_color_type_id__volatile)) {
		static const GEnumValue values[] = {{CONSOLE_COLOR_BLACK, "CONSOLE_COLOR_BLACK", "black"}, {CONSOLE_COLOR_RED, "CONSOLE_COLOR_RED", "red"}, {CONSOLE_COLOR_GREEN, "CONSOLE_COLOR_GREEN", "green"}, {CONSOLE_COLOR_YELLOW, "CONSOLE_COLOR_YELLOW", "yellow"}, {CONSOLE_COLOR_BLUE, "CONSOLE_COLOR_BLUE", "blue"}, {CONSOLE_COLOR_MAGENTA, "CONSOLE_COLOR_MAGENTA", "magenta"}, {CONSOLE_COLOR_CYAN, "CONSOLE_COLOR_CYAN", "cyan"}, {CONSOLE_COLOR_WHITE, "CONSOLE_COLOR_WHITE", "white"}, {0, NULL, NULL}};
		GType console_color_type_id;
		console_color_type_id = g_enum_register_static ("ConsoleColor", values);
		g_once_init_leave (&console_color_type_id__volatile, console_color_type_id);
	}
	return console_color_type_id__volatile;
}


/**
     * Initializes the logger for the application.
     *
     * @param app_name the name of the application
     */
static void _logger_glib_log_func_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	logger_glib_log_func (log_domain, log_levels, message);
}


void logger_initialize (const gchar* app_name) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (app_name != NULL);
	_tmp0_ = logger_get_name ();
	_tmp1_ = _tmp0_;
	_tmp2_ = app_name;
	logger_set_name (_tmp2_);
	logger_is_writing = FALSE;
	_tmp3_ = gee_array_list_new (LOGGER_TYPE_LOG_MESSAGE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (logger_log_queue);
	logger_log_queue = _tmp3_;
	{
		GRegex* _tmp4_ = NULL;
		GRegex* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		_tmp5_ = g_regex_new ("[(]?.*?([^/]*?)(\\.2)?\\.vala(:\\d+)[)]?:\\s*(.*)", 0, 0, &_inner_error_);
		_tmp4_ = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch20_g_error;
		}
		_tmp6_ = _tmp4_;
		_tmp4_ = NULL;
		_g_regex_unref0 (logger_re);
		logger_re = _tmp6_;
		_g_regex_unref0 (_tmp4_);
	}
	goto __finally20;
	__catch20_g_error:
	{
		g_clear_error (&_inner_error_);
		_inner_error_ = NULL;
	}
	__finally20:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_log_set_default_handler (_logger_glib_log_func_glog_func, NULL);
}


static gchar* logger_format_message (const gchar* msg) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	GRegex* _tmp1_ = NULL;
	const gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (msg != NULL, NULL);
	_tmp1_ = logger_re;
	if (_tmp1_ != NULL) {
		GRegex* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp2_ = logger_re;
		_tmp3_ = msg;
		_tmp4_ = g_regex_match (_tmp2_, _tmp3_, 0, NULL);
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar** parts = NULL;
		GRegex* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar** _tmp7_ = NULL;
		gchar** _tmp8_ = NULL;
		gint parts_length1 = 0;
		gint _parts_size_ = 0;
		LogLevel _tmp9_ = 0;
		LogLevel _tmp10_ = 0;
		_tmp5_ = logger_re;
		_tmp6_ = msg;
		_tmp8_ = _tmp7_ = g_regex_split (_tmp5_, _tmp6_, 0);
		parts = _tmp8_;
		parts_length1 = _vala_array_length (_tmp7_);
		_parts_size_ = parts_length1;
		_tmp9_ = logger_get_DisplayLevel ();
		_tmp10_ = _tmp9_;
		if (_tmp10_ <= LOG_LEVEL_DEBUG) {
			gchar** _tmp11_ = NULL;
			gint _tmp11__length1 = 0;
			const gchar* _tmp12_ = NULL;
			gchar** _tmp13_ = NULL;
			gint _tmp13__length1 = 0;
			const gchar* _tmp14_ = NULL;
			gchar** _tmp15_ = NULL;
			gint _tmp15__length1 = 0;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			_tmp11_ = parts;
			_tmp11__length1 = parts_length1;
			_tmp12_ = _tmp11_[1];
			_tmp13_ = parts;
			_tmp13__length1 = parts_length1;
			_tmp14_ = _tmp13_[3];
			_tmp15_ = parts;
			_tmp15__length1 = parts_length1;
			_tmp16_ = _tmp15_[4];
			_tmp17_ = g_strdup_printf ("[%s%s] %s", _tmp12_, _tmp14_, _tmp16_);
			result = _tmp17_;
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return result;
		} else {
			gchar** _tmp18_ = NULL;
			gint _tmp18__length1 = 0;
			const gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			_tmp18_ = parts;
			_tmp18__length1 = parts_length1;
			_tmp19_ = _tmp18_[4];
			_tmp20_ = g_strdup_printf ("%s", _tmp19_);
			result = _tmp20_;
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp21_ = msg;
	_tmp22_ = g_strdup (_tmp21_);
	result = _tmp22_;
	return result;
}


/**
     * Displays a log message using libnotify.  Also displays on the console.
     *
     * @param msg the log message to display
     * @param icon the icon to display in the notification
     */
void logger_notification (const gchar* msg, const gchar* icon) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	g_return_if_fail (msg != NULL);
	g_return_if_fail (icon != NULL);
	_tmp0_ = msg;
	_tmp1_ = logger_format_message (_tmp0_);
	_tmp2_ = _tmp1_;
	logger_write (LOG_LEVEL_NOTIFY, _tmp2_);
	_g_free0 (_tmp2_);
}


/**
     * Displays a verbose log message to the console.
     *
     * @param msg the log message to display
     */
void logger_verbose (const gchar* msg, ...) {
	va_list vargs = {0};
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_if_fail (msg != NULL);
	va_start (vargs, msg);
	_tmp0_ = msg;
	_tmp1_ = g_strdup_vprintf (_tmp0_, vargs);
	_tmp2_ = _tmp1_;
	_tmp3_ = logger_format_message (_tmp2_);
	_tmp4_ = _tmp3_;
	logger_write (LOG_LEVEL_VERBOSE, _tmp4_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	va_end (vargs);
}


static gchar* logger_get_time (void) {
	gchar* result = NULL;
	GDateTime* now = NULL;
	GDateTime* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	_tmp0_ = g_date_time_new_now_local ();
	now = _tmp0_;
	_tmp1_ = g_date_time_get_hour (now);
	_tmp2_ = g_date_time_get_minute (now);
	_tmp3_ = g_date_time_get_second (now);
	_tmp4_ = g_strdup_printf ("%.2d:%.2d:%.2d", _tmp1_, _tmp2_, _tmp3_);
	result = _tmp4_;
	_g_date_time_unref0 (now);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void logger_write (LogLevel level, const gchar* msg) {
	LogLevel _tmp0_ = 0;
	LogLevel _tmp1_ = 0;
	LogLevel _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (msg != NULL);
	_tmp0_ = level;
	_tmp1_ = logger_get_DisplayLevel ();
	_tmp2_ = _tmp1_;
	if (_tmp0_ < _tmp2_) {
		return;
	}
	_tmp3_ = logger_is_writing;
	if (_tmp3_) {
		{
			GObject* _tmp4_ = NULL;
			_tmp4_ = logger_queue_lock;
			g_rec_mutex_lock (&__lock_logger_queue_lock);
			{
				GeeArrayList* _tmp5_ = NULL;
				LogLevel _tmp6_ = 0;
				const gchar* _tmp7_ = NULL;
				LoggerLogMessage* _tmp8_ = NULL;
				LoggerLogMessage* _tmp9_ = NULL;
				_tmp5_ = logger_log_queue;
				_tmp6_ = level;
				_tmp7_ = msg;
				_tmp8_ = logger_log_message_new (_tmp6_, _tmp7_);
				_tmp9_ = _tmp8_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp5_, _tmp9_);
				_g_object_unref0 (_tmp9_);
			}
			__finally21:
			{
				GObject* _tmp10_ = NULL;
				_tmp10_ = logger_queue_lock;
				g_rec_mutex_unlock (&__lock_logger_queue_lock);
			}
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	} else {
		GeeArrayList* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		LogLevel _tmp31_ = 0;
		const gchar* _tmp32_ = NULL;
		LoggerLogMessage* _tmp33_ = NULL;
		LoggerLogMessage* _tmp34_ = NULL;
		logger_is_writing = TRUE;
		_tmp11_ = logger_log_queue;
		_tmp12_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp11_);
		_tmp13_ = _tmp12_;
		if (_tmp13_ > 0) {
			GeeArrayList* logs = NULL;
			GeeArrayList* _tmp14_ = NULL;
			GeeArrayList* _tmp15_ = NULL;
			_tmp14_ = logger_log_queue;
			_tmp15_ = _g_object_ref0 (_tmp14_);
			logs = _tmp15_;
			{
				GObject* _tmp16_ = NULL;
				_tmp16_ = logger_queue_lock;
				g_rec_mutex_lock (&__lock_logger_queue_lock);
				{
					GeeArrayList* _tmp17_ = NULL;
					_tmp17_ = gee_array_list_new (LOGGER_TYPE_LOG_MESSAGE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
					_g_object_unref0 (logger_log_queue);
					logger_log_queue = _tmp17_;
				}
				__finally22:
				{
					GObject* _tmp18_ = NULL;
					_tmp18_ = logger_queue_lock;
					g_rec_mutex_unlock (&__lock_logger_queue_lock);
				}
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (logs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			{
				GeeArrayList* _log_list = NULL;
				GeeArrayList* _tmp19_ = NULL;
				GeeArrayList* _tmp20_ = NULL;
				gint _log_size = 0;
				GeeArrayList* _tmp21_ = NULL;
				gint _tmp22_ = 0;
				gint _tmp23_ = 0;
				gint _log_index = 0;
				_tmp19_ = logs;
				_tmp20_ = _g_object_ref0 (_tmp19_);
				_log_list = _tmp20_;
				_tmp21_ = _log_list;
				_tmp22_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp21_);
				_tmp23_ = _tmp22_;
				_log_size = _tmp23_;
				_log_index = -1;
				while (TRUE) {
					gint _tmp24_ = 0;
					gint _tmp25_ = 0;
					gint _tmp26_ = 0;
					LoggerLogMessage* log = NULL;
					GeeArrayList* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gpointer _tmp29_ = NULL;
					LoggerLogMessage* _tmp30_ = NULL;
					_tmp24_ = _log_index;
					_log_index = _tmp24_ + 1;
					_tmp25_ = _log_index;
					_tmp26_ = _log_size;
					if (!(_tmp25_ < _tmp26_)) {
						break;
					}
					_tmp27_ = _log_list;
					_tmp28_ = _log_index;
					_tmp29_ = gee_abstract_list_get ((GeeAbstractList*) _tmp27_, _tmp28_);
					log = (LoggerLogMessage*) _tmp29_;
					_tmp30_ = log;
					logger_print_log (_tmp30_);
					_g_object_unref0 (log);
				}
				_g_object_unref0 (_log_list);
			}
			_g_object_unref0 (logs);
		}
		_tmp31_ = level;
		_tmp32_ = msg;
		_tmp33_ = logger_log_message_new (_tmp31_, _tmp32_);
		_tmp34_ = _tmp33_;
		logger_print_log (_tmp34_);
		_g_object_unref0 (_tmp34_);
		logger_is_writing = FALSE;
	}
}


static void logger_print_log (LoggerLogMessage* log) {
	LoggerLogMessage* _tmp0_ = NULL;
	LogLevel _tmp1_ = 0;
	LogLevel _tmp2_ = 0;
	FILE* _tmp3_ = NULL;
	LoggerLogMessage* _tmp4_ = NULL;
	LogLevel _tmp5_ = 0;
	LogLevel _tmp6_ = 0;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	FILE* _tmp11_ = NULL;
	LoggerLogMessage* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	g_return_if_fail (log != NULL);
	_tmp0_ = log;
	_tmp1_ = logger_log_message_get_level (_tmp0_);
	_tmp2_ = _tmp1_;
	logger_set_color_for_level (_tmp2_);
	_tmp3_ = stdout;
	_tmp4_ = log;
	_tmp5_ = logger_log_message_get_level (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = log_level_to_string (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = logger_get_time ();
	_tmp10_ = _tmp9_;
	fprintf (_tmp3_, "[%s %s]", _tmp8_, _tmp10_);
	_g_free0 (_tmp10_);
	_g_free0 (_tmp8_);
	logger_reset_color ();
	_tmp11_ = stdout;
	_tmp12_ = log;
	_tmp13_ = logger_log_message_get_message (_tmp12_);
	_tmp14_ = _tmp13_;
	fprintf (_tmp11_, " %s\n", _tmp14_);
}


static void logger_set_color_for_level (LogLevel level) {
	LogLevel _tmp0_ = 0;
	_tmp0_ = level;
	switch (_tmp0_) {
		case LOG_LEVEL_VERBOSE:
		{
			logger_set_foreground (CONSOLE_COLOR_CYAN);
			break;
		}
		case LOG_LEVEL_DEBUG:
		{
			logger_set_foreground (CONSOLE_COLOR_GREEN);
			break;
		}
		case LOG_LEVEL_INFO:
		{
			logger_set_foreground (CONSOLE_COLOR_BLUE);
			break;
		}
		case LOG_LEVEL_NOTIFY:
		{
			logger_set_foreground (CONSOLE_COLOR_MAGENTA);
			break;
		}
		default:
		case LOG_LEVEL_WARN:
		{
			logger_set_foreground (CONSOLE_COLOR_YELLOW);
			break;
		}
		case LOG_LEVEL_ERROR:
		{
			logger_set_foreground (CONSOLE_COLOR_RED);
			break;
		}
		case LOG_LEVEL_FATAL:
		{
			logger_set_background (CONSOLE_COLOR_RED);
			logger_set_foreground (CONSOLE_COLOR_WHITE);
			break;
		}
	}
}


void logger_reset_color (void) {
	FILE* _tmp0_ = NULL;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "\x001b[0m");
}


void logger_set_foreground (ConsoleColor color) {
	ConsoleColor _tmp0_ = 0;
	_tmp0_ = color;
	logger_set_color (_tmp0_, TRUE);
}


void logger_set_background (ConsoleColor color) {
	ConsoleColor _tmp0_ = 0;
	_tmp0_ = color;
	logger_set_color (_tmp0_, FALSE);
}


static void logger_set_color (ConsoleColor color, gboolean isForeground) {
	ConsoleColor color_code = 0;
	ConsoleColor _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	FILE* _tmp3_ = NULL;
	ConsoleColor _tmp4_ = 0;
	_tmp0_ = color;
	color_code = (_tmp0_ + 30) + 60;
	_tmp1_ = isForeground;
	if (!_tmp1_) {
		ConsoleColor _tmp2_ = 0;
		_tmp2_ = color_code;
		color_code = _tmp2_ + 10;
	}
	_tmp3_ = stdout;
	_tmp4_ = color_code;
	fprintf (_tmp3_, "\x001b[%dm", (gint) _tmp4_);
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch23_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch23_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally23;
	__catch23_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally23:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static void logger_glib_log_func (const gchar* d, GLogLevelFlags flags, const gchar* msg) {
	gchar* domain = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* message = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	GLogLevelFlags _tmp13_ = 0;
	g_return_if_fail (msg != NULL);
	_tmp0_ = g_strdup ("");
	domain = _tmp0_;
	_tmp1_ = d;
	if (_tmp1_ != NULL) {
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp3_ = d;
		_tmp2_ = _tmp3_;
		if (_tmp2_ == NULL) {
			_tmp2_ = "";
		}
		_tmp4_ = g_strdup_printf ("[%s] ", _tmp2_);
		_g_free0 (domain);
		domain = _tmp4_;
	}
	_tmp5_ = msg;
	_tmp6_ = string_replace (_tmp5_, "\n", "");
	_tmp7_ = _tmp6_;
	_tmp8_ = string_replace (_tmp7_, "\r", "");
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	message = _tmp9_;
	_tmp10_ = domain;
	_tmp11_ = message;
	_tmp12_ = g_strdup_printf ("%s%s", _tmp10_, _tmp11_);
	_g_free0 (message);
	message = _tmp12_;
	_tmp13_ = flags;
	switch (_tmp13_) {
		case G_LOG_LEVEL_CRITICAL:
		{
			const gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			_tmp14_ = message;
			_tmp15_ = logger_format_message (_tmp14_);
			_tmp16_ = _tmp15_;
			logger_write (LOG_LEVEL_FATAL, _tmp16_);
			_g_free0 (_tmp16_);
			_tmp17_ = logger_get_name ();
			_tmp18_ = _tmp17_;
			_tmp19_ = g_strdup_printf ("%s will not function properly.", _tmp18_);
			_tmp20_ = _tmp19_;
			_tmp21_ = logger_format_message (_tmp20_);
			_tmp22_ = _tmp21_;
			logger_write (LOG_LEVEL_FATAL, _tmp22_);
			_g_free0 (_tmp22_);
			_g_free0 (_tmp20_);
			break;
		}
		case G_LOG_LEVEL_ERROR:
		{
			const gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			_tmp23_ = message;
			_tmp24_ = logger_format_message (_tmp23_);
			_tmp25_ = _tmp24_;
			logger_write (LOG_LEVEL_ERROR, _tmp25_);
			_g_free0 (_tmp25_);
			break;
		}
		case G_LOG_LEVEL_INFO:
		case G_LOG_LEVEL_MESSAGE:
		{
			const gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			_tmp26_ = message;
			_tmp27_ = logger_format_message (_tmp26_);
			_tmp28_ = _tmp27_;
			logger_write (LOG_LEVEL_INFO, _tmp28_);
			_g_free0 (_tmp28_);
			break;
		}
		case G_LOG_LEVEL_DEBUG:
		{
			const gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			_tmp29_ = message;
			_tmp30_ = logger_format_message (_tmp29_);
			_tmp31_ = _tmp30_;
			logger_write (LOG_LEVEL_DEBUG, _tmp31_);
			_g_free0 (_tmp31_);
			break;
		}
		default:
		case G_LOG_LEVEL_WARNING:
		{
			const gchar* _tmp32_ = NULL;
			gchar* _tmp33_ = NULL;
			gchar* _tmp34_ = NULL;
			_tmp32_ = message;
			_tmp33_ = logger_format_message (_tmp32_);
			_tmp34_ = _tmp33_;
			logger_write (LOG_LEVEL_WARN, _tmp34_);
			_g_free0 (_tmp34_);
			break;
		}
	}
	_g_free0 (message);
	_g_free0 (domain);
}


Logger* logger_construct (GType object_type) {
	Logger * self = NULL;
	self = (Logger*) g_object_new (object_type, NULL);
	return self;
}


Logger* logger_new (void) {
	return logger_construct (TYPE_LOGGER);
}


LogLevel logger_get_DisplayLevel (void) {
	LogLevel result;
	LogLevel _tmp0_ = 0;
	_tmp0_ = logger__DisplayLevel;
	result = _tmp0_;
	return result;
}


void logger_set_DisplayLevel (LogLevel value) {
	LogLevel _tmp0_ = 0;
	_tmp0_ = value;
	logger__DisplayLevel = _tmp0_;
}


static const gchar* logger_get_name (void) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	_tmp0_ = logger__name;
	result = _tmp0_;
	return result;
}


static void logger_set_name (const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (logger__name);
	logger__name = _tmp1_;
}


static LoggerLogMessage* logger_log_message_construct (GType object_type, LogLevel level, const gchar* message) {
	LoggerLogMessage * self = NULL;
	LogLevel _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (message != NULL, NULL);
	_tmp0_ = level;
	_tmp1_ = message;
	self = (LoggerLogMessage*) g_object_new (object_type, "level", _tmp0_, "message", _tmp1_, NULL);
	return self;
}


static LoggerLogMessage* logger_log_message_new (LogLevel level, const gchar* message) {
	return logger_log_message_construct (LOGGER_TYPE_LOG_MESSAGE, level, message);
}


static LogLevel logger_log_message_get_level (LoggerLogMessage* self) {
	LogLevel result;
	LogLevel _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_level;
	result = _tmp0_;
	return result;
}


static void logger_log_message_set_level (LoggerLogMessage* self, LogLevel value) {
	LogLevel _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_level = _tmp0_;
	g_object_notify ((GObject *) self, "level");
}


static const gchar* logger_log_message_get_message (LoggerLogMessage* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_message;
	result = _tmp0_;
	return result;
}


static void logger_log_message_set_message (LoggerLogMessage* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_message);
	self->priv->_message = _tmp1_;
	g_object_notify ((GObject *) self, "message");
}


static void logger_log_message_class_init (LoggerLogMessageClass * klass) {
	logger_log_message_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LoggerLogMessagePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_logger_log_message_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_logger_log_message_set_property;
	G_OBJECT_CLASS (klass)->finalize = logger_log_message_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGGER_LOG_MESSAGE_LEVEL, g_param_spec_enum ("level", "level", "level", TYPE_LOG_LEVEL, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGGER_LOG_MESSAGE_MESSAGE, g_param_spec_string ("message", "message", "message", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void logger_log_message_instance_init (LoggerLogMessage * self) {
	self->priv = LOGGER_LOG_MESSAGE_GET_PRIVATE (self);
}


static void logger_log_message_finalize (GObject* obj) {
	LoggerLogMessage * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessage);
	_g_free0 (self->priv->_message);
	G_OBJECT_CLASS (logger_log_message_parent_class)->finalize (obj);
}


static GType logger_log_message_get_type (void) {
	static volatile gsize logger_log_message_type_id__volatile = 0;
	if (g_once_init_enter (&logger_log_message_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LoggerLogMessageClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) logger_log_message_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LoggerLogMessage), 0, (GInstanceInitFunc) logger_log_message_instance_init, NULL };
		GType logger_log_message_type_id;
		logger_log_message_type_id = g_type_register_static (G_TYPE_OBJECT, "LoggerLogMessage", &g_define_type_info, 0);
		g_once_init_leave (&logger_log_message_type_id__volatile, logger_log_message_type_id);
	}
	return logger_log_message_type_id__volatile;
}


static void _vala_logger_log_message_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	LoggerLogMessage * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessage);
	switch (property_id) {
		case LOGGER_LOG_MESSAGE_LEVEL:
		g_value_set_enum (value, logger_log_message_get_level (self));
		break;
		case LOGGER_LOG_MESSAGE_MESSAGE:
		g_value_set_string (value, logger_log_message_get_message (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_logger_log_message_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	LoggerLogMessage * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, LOGGER_TYPE_LOG_MESSAGE, LoggerLogMessage);
	switch (property_id) {
		case LOGGER_LOG_MESSAGE_LEVEL:
		logger_log_message_set_level (self, g_value_get_enum (value));
		break;
		case LOGGER_LOG_MESSAGE_MESSAGE:
		logger_log_message_set_message (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void logger_class_init (LoggerClass * klass) {
	logger_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_logger_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_logger_set_property;
	G_OBJECT_CLASS (klass)->finalize = logger_finalize;
	g_rec_mutex_init (&__lock_logger_queue_lock);
}


static void logger_instance_init (Logger * self) {
}


static void logger_finalize (GObject* obj) {
	Logger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOGGER, Logger);
	G_OBJECT_CLASS (logger_parent_class)->finalize (obj);
}


/**
 * A logging class to display all console messages in a nice colored format.
 */
GType logger_get_type (void) {
	static volatile gsize logger_type_id__volatile = 0;
	if (g_once_init_enter (&logger_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LoggerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) logger_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Logger), 0, (GInstanceInitFunc) logger_instance_init, NULL };
		GType logger_type_id;
		logger_type_id = g_type_register_static (G_TYPE_OBJECT, "Logger", &g_define_type_info, 0);
		g_once_init_leave (&logger_type_id__volatile, logger_type_id);
	}
	return logger_type_id__volatile;
}


static void _vala_logger_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Logger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_LOGGER, Logger);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_logger_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Logger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_LOGGER, Logger);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



