/* Library.c generated by valac 0.26.1, the Vala compiler
 * generated from Library.vala, do not modify */

/* Library.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <sqlite3.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <glib/gstdio.h>


#define FONT_MANAGER_TYPE_FONT_DATA (font_manager_font_data_get_type ())

#define TYPE_CACHEABLE (cacheable_get_type ())
#define CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CACHEABLE, Cacheable))
#define CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CACHEABLE, CacheableClass))
#define IS_CACHEABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CACHEABLE))
#define IS_CACHEABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CACHEABLE))
#define CACHEABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CACHEABLE, CacheableClass))

typedef struct _Cacheable Cacheable;
typedef struct _CacheableClass CacheableClass;

#define FONT_CONFIG_TYPE_FONT (font_config_font_get_type ())
#define FONT_CONFIG_FONT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFont))
#define FONT_CONFIG_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))
#define FONT_CONFIG_IS_FONT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_IS_FONT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_CONFIG_TYPE_FONT))
#define FONT_CONFIG_FONT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_CONFIG_TYPE_FONT, FontConfigFontClass))

typedef struct _FontConfigFont FontConfigFont;
typedef struct _FontConfigFontClass FontConfigFontClass;

#define FONT_MANAGER_TYPE_FONT_INFO (font_manager_font_info_get_type ())
#define FONT_MANAGER_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfo))
#define FONT_MANAGER_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))
#define FONT_MANAGER_IS_FONT_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_IS_FONT_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_FONT_INFO))
#define FONT_MANAGER_FONT_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_FONT_INFO, FontManagerFontInfoClass))

typedef struct _FontManagerFontInfo FontManagerFontInfo;
typedef struct _FontManagerFontInfoClass FontManagerFontInfoClass;
typedef struct _FontManagerFontData FontManagerFontData;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_ARCHIVE_MANAGER (archive_manager_get_type ())
#define ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManager))
#define ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))
#define IS_ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ARCHIVE_MANAGER))
#define IS_ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ARCHIVE_MANAGER))
#define ARCHIVE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))

typedef struct _ArchiveManager ArchiveManager;
typedef struct _ArchiveManagerClass ArchiveManagerClass;

#define FONT_MANAGER_TYPE_DATABASE (font_manager_database_get_type ())
#define FONT_MANAGER_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabase))
#define FONT_MANAGER_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))
#define FONT_MANAGER_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_TYPE_DATABASE))
#define FONT_MANAGER_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_TYPE_DATABASE, FontManagerDatabaseClass))

typedef struct _FontManagerDatabase FontManagerDatabase;
typedef struct _FontManagerDatabaseClass FontManagerDatabaseClass;

#define FONT_MANAGER_DATABASE_TYPE_ITERATOR (font_manager_database_iterator_get_type ())
#define FONT_MANAGER_DATABASE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIterator))
#define FONT_MANAGER_DATABASE_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIteratorClass))
#define FONT_MANAGER_DATABASE_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR))
#define FONT_MANAGER_DATABASE_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_DATABASE_TYPE_ITERATOR))
#define FONT_MANAGER_DATABASE_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_DATABASE_TYPE_ITERATOR, FontManagerDatabaseIteratorClass))

typedef struct _FontManagerDatabaseIterator FontManagerDatabaseIterator;
typedef struct _FontManagerDatabaseIteratorClass FontManagerDatabaseIteratorClass;
#define _font_manager_database_iterator_unref0(var) ((var == NULL) ? NULL : (var = (font_manager_database_iterator_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define FONT_MANAGER_LIBRARY_TYPE_SORTER (font_manager_library_sorter_get_type ())
#define FONT_MANAGER_LIBRARY_SORTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorter))
#define FONT_MANAGER_LIBRARY_SORTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorterClass))
#define FONT_MANAGER_LIBRARY_IS_SORTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FONT_MANAGER_LIBRARY_TYPE_SORTER))
#define FONT_MANAGER_LIBRARY_IS_SORTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FONT_MANAGER_LIBRARY_TYPE_SORTER))
#define FONT_MANAGER_LIBRARY_SORTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorterClass))

typedef struct _FontManagerLibrarySorter FontManagerLibrarySorter;
typedef struct _FontManagerLibrarySorterClass FontManagerLibrarySorterClass;
typedef struct _FontManagerLibrarySorterPrivate FontManagerLibrarySorterPrivate;
typedef struct _FontManagerLibraryInstall FontManagerLibraryInstall;
typedef struct _FontManagerLibraryRemove FontManagerLibraryRemove;

struct _FontManagerFontData {
	GFile* file;
	FontConfigFont* font;
	FontManagerFontInfo* fontinfo;
};

typedef void (*ProgressCallback) (const gchar* message, gint processed, gint total, void* user_data);
typedef enum  {
	FONT_MANAGER_DATABASE_ERROR_ERROR,
	FONT_MANAGER_DATABASE_ERROR_BACKING,
	FONT_MANAGER_DATABASE_ERROR_MEMORY,
	FONT_MANAGER_DATABASE_ERROR_ABORT,
	FONT_MANAGER_DATABASE_ERROR_LIMITS,
	FONT_MANAGER_DATABASE_ERROR_TYPESPEC
} FontManagerDatabaseError;
#define FONT_MANAGER_DATABASE_ERROR font_manager_database_error_quark ()
struct _FontManagerLibrarySorter {
	GObject parent_instance;
	FontManagerLibrarySorterPrivate * priv;
};

struct _FontManagerLibrarySorterClass {
	GObjectClass parent_class;
};

struct _FontManagerLibrarySorterPrivate {
	GeeArrayList* _files;
	GeeArrayList* _archives;
};

struct _FontManagerLibraryInstall {
};

struct _FontManagerLibraryRemove {
};


extern ProgressCallback font_manager_library_progress;
extern gpointer font_manager_library_progress_target;
extern GDestroyNotify font_manager_library_progress_target_destroy_notify;
ProgressCallback font_manager_library_progress = NULL;
gpointer font_manager_library_progress_target = NULL;
GDestroyNotify font_manager_library_progress_target_destroy_notify = NULL;
extern ArchiveManager* font_manager_library_archive_manager;
ArchiveManager* font_manager_library_archive_manager = NULL;
extern GeeArrayList* font_manager_library_supported_archives;
GeeArrayList* font_manager_library_supported_archives = NULL;
static gpointer font_manager_library_sorter_parent_class = NULL;
extern GeeArrayList* font_manager_library_install_installed;
GeeArrayList* font_manager_library_install_installed = NULL;
extern GeeHashMap* font_manager_library_install_install_failed;
GeeHashMap* font_manager_library_install_install_failed = NULL;
static GFile* font_manager_library_install_tmpdir;
static GFile* font_manager_library_install_tmpdir = NULL;
extern GeeArrayList* font_manager_library_remove_removed;
GeeArrayList* font_manager_library_remove_removed = NULL;
extern GeeHashMap* font_manager_library_remove_remove_failed;
GeeHashMap* font_manager_library_remove_remove_failed = NULL;

GType font_manager_font_data_get_type (void) G_GNUC_CONST;
GType cacheable_get_type (void) G_GNUC_CONST;
GType font_config_font_get_type (void) G_GNUC_CONST;
GType font_manager_font_info_get_type (void) G_GNUC_CONST;
FontManagerFontData* font_manager_font_data_dup (const FontManagerFontData* self);
void font_manager_font_data_free (FontManagerFontData* self);
void font_manager_font_data_copy (const FontManagerFontData* self, FontManagerFontData* dest);
void font_manager_font_data_destroy (FontManagerFontData* self);
void font_manager_font_data_init (FontManagerFontData *self, GFile* file, const gchar* rmdir);
FontConfigFont* font_config_get_font_from_file (const gchar* filepath, gint index);
FontManagerFontInfo* font_manager_font_info_new_from_filepath (const gchar* filepath, gint index);
FontManagerFontInfo* font_manager_font_info_construct_from_filepath (GType object_type, const gchar* filepath, gint index);
GType archive_manager_get_type (void) G_GNUC_CONST;
gboolean font_manager_library_is_installed (FontManagerFontData* fontdata);
GeeArrayList* font_config_list_files (void);
const gchar* font_config_font_get_filepath (FontConfigFont* self);
GeeArrayList* font_manager_library_db_match_checksum (const gchar* checksum);
const gchar* font_manager_font_info_get_checksum (FontManagerFontInfo* self);
gint font_manager_library_conflicts (FontManagerFontData* fontdata);
GeeHashMap* font_manager_library_db_match_unique_names (FontManagerFontData* fontdata);
gint natural_cmp (const gchar* a, const gchar* b);
const gchar* font_manager_font_info_get_version (FontManagerFontInfo* self);
gboolean font_manager_library_is_metrics_file (const gchar* name);
GType font_manager_database_get_type (void) G_GNUC_CONST;
GQuark font_manager_database_error_quark (void);
FontManagerDatabase* font_manager_get_database (GError** error);
void font_manager_database_reset (FontManagerDatabase* self);
void font_manager_database_set_table (FontManagerDatabase* self, const gchar* value);
void font_manager_database_set_select (FontManagerDatabase* self, const gchar* value);
void font_manager_database_set_search (FontManagerDatabase* self, const gchar* value);
void font_manager_database_execute_query (FontManagerDatabase* self, const gchar* query, GError** error);
gpointer font_manager_database_iterator_ref (gpointer instance);
void font_manager_database_iterator_unref (gpointer instance);
GParamSpec* font_manager_database_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void font_manager_database_value_set_iterator (GValue* value, gpointer v_object);
void font_manager_database_value_take_iterator (GValue* value, gpointer v_object);
gpointer font_manager_database_value_get_iterator (const GValue* value);
GType font_manager_database_iterator_get_type (void) G_GNUC_CONST;
FontManagerDatabaseIterator* font_manager_database_iterator (FontManagerDatabase* self);
sqlite3_stmt* font_manager_database_iterator_next_value (FontManagerDatabaseIterator* self);
void font_manager_show_error_message (const gchar* message, GError* e, GtkWindow* parent);
void font_manager_database_close (FontManagerDatabase* self);
const gchar* font_manager_font_info_get_psname (FontManagerFontInfo* self);
const gchar* font_config_font_get_description (FontConfigFont* self);
GType font_manager_library_sorter_get_type (void) G_GNUC_CONST;
#define FONT_MANAGER_LIBRARY_SORTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorterPrivate))
enum  {
	FONT_MANAGER_LIBRARY_SORTER_DUMMY_PROPERTY,
	FONT_MANAGER_LIBRARY_SORTER_FILES,
	FONT_MANAGER_LIBRARY_SORTER_ARCHIVES
};
void font_manager_library_sorter_sort (FontManagerLibrarySorter* self, GeeArrayList* filelist);
GeeArrayList* font_manager_library_sorter_get_files (FontManagerLibrarySorter* self);
GeeArrayList* font_manager_library_sorter_get_archives (FontManagerLibrarySorter* self);
static void font_manager_library_sorter_process_files (FontManagerLibrarySorter* self, GeeArrayList* filelist);
static void font_manager_library_sorter_process_directory (FontManagerLibrarySorter* self, GFile* dir);
static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle);
FontManagerLibrarySorter* font_manager_library_sorter_new (void);
FontManagerLibrarySorter* font_manager_library_sorter_construct (GType object_type);
static void font_manager_library_sorter_set_files (FontManagerLibrarySorter* self, GeeArrayList* value);
static void font_manager_library_sorter_set_archives (FontManagerLibrarySorter* self, GeeArrayList* value);
static GObject * font_manager_library_sorter_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
ArchiveManager* archive_manager_new (void);
ArchiveManager* archive_manager_construct (GType object_type);
GeeArrayList* archive_manager_get_supported_types (ArchiveManager* self, const gchar* action);
static void font_manager_library_sorter_finalize (GObject* obj);
static void _vala_font_manager_library_sorter_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_font_manager_library_sorter_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
void font_manager_library_install_free (FontManagerLibraryInstall* self);
static void font_manager_library_install_instance_init (FontManagerLibraryInstall * self);
void font_manager_library_install_from_file_array (GFile** files, int files_length1);
static void font_manager_library_install_init (void);
static void font_manager_library_install_process_files (GeeArrayList* filelist);
static void font_manager_library_install_fini (void);
void font_manager_library_install_from_path_array (gchar** paths, int paths_length1);
void font_manager_library_install_from_uri_array (gchar** uris, int uris_length1);
gboolean remove_directory (GFile* dir, gboolean recursive);
static void font_manager_library_install_try_copy (GFile* original, GFile* copy);
gboolean font_manager_library_install_install_font (FontManagerFontData* data);
gchar* get_user_font_dir (void);
const gchar* font_manager_font_info_get_vendor (FontManagerFontInfo* self);
const gchar* font_manager_font_info_get_filetype (FontManagerFontInfo* self);
const gchar* font_config_font_get_family (FontConfigFont* self);
gchar* font_config_font_to_filename (FontConfigFont* self);
gchar* get_file_extension (const gchar* path);
static GFile* font_manager_library_install_get_temp_dir (void);
#define FONT_MANAGER_TMPL "font-manager_XXXXXX"
gboolean archive_manager_extract (ArchiveManager* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog);
FontManagerLibraryInstall* font_manager_library_install_new (void);
FontManagerLibraryInstall* font_manager_library_install_new (void);
void font_manager_library_remove_free (FontManagerLibraryRemove* self);
static void font_manager_library_remove_instance_init (FontManagerLibraryRemove * self);
void font_manager_library_remove_from_file_array (GFile** files, int files_length1);
void font_manager_database_remove (FontManagerDatabase* self, const gchar* condition, GError** error);
gboolean remove_directory_tree_if_empty (GFile* dir);
void font_manager_database_vacuum (FontManagerDatabase* self, GError** error);
FontManagerLibraryRemove* font_manager_library_remove_new (void);
FontManagerLibraryRemove* font_manager_library_remove_new (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

extern const gchar* FONT_MANAGER_FONT_METRICS[3];
extern const gchar* FONT_MANAGER_ARCHIVE_IGNORE_LIST[1];

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void font_manager_font_data_init (FontManagerFontData *self, GFile* file, const gchar* rmdir) {
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	FontConfigFont* _tmp5_ = NULL;
	GFile* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	FontManagerFontInfo* _tmp9_ = NULL;
	g_return_if_fail (file != NULL);
	memset (self, 0, sizeof (FontManagerFontData));
	_tmp0_ = file;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 ((*self).file);
	(*self).file = _tmp1_;
	_tmp2_ = file;
	_tmp3_ = g_file_get_path (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = font_config_get_font_from_file (_tmp4_, 0);
	_g_object_unref0 ((*self).font);
	(*self).font = _tmp5_;
	_g_free0 (_tmp4_);
	_tmp6_ = file;
	_tmp7_ = g_file_get_path (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = font_manager_font_info_new_from_filepath (_tmp8_, 0);
	_g_object_unref0 ((*self).fontinfo);
	(*self).fontinfo = _tmp9_;
	_g_free0 (_tmp8_);
}


void font_manager_font_data_copy (const FontManagerFontData* self, FontManagerFontData* dest) {
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	FontConfigFont* _tmp2_ = NULL;
	FontConfigFont* _tmp3_ = NULL;
	FontManagerFontInfo* _tmp4_ = NULL;
	FontManagerFontInfo* _tmp5_ = NULL;
	_tmp0_ = (*self).file;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 ((*dest).file);
	(*dest).file = _tmp1_;
	_tmp2_ = (*self).font;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 ((*dest).font);
	(*dest).font = _tmp3_;
	_tmp4_ = (*self).fontinfo;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_g_object_unref0 ((*dest).fontinfo);
	(*dest).fontinfo = _tmp5_;
}


void font_manager_font_data_destroy (FontManagerFontData* self) {
	_g_object_unref0 ((*self).file);
	_g_object_unref0 ((*self).font);
	_g_object_unref0 ((*self).fontinfo);
}


FontManagerFontData* font_manager_font_data_dup (const FontManagerFontData* self) {
	FontManagerFontData* dup;
	dup = g_new0 (FontManagerFontData, 1);
	font_manager_font_data_copy (self, dup);
	return dup;
}


void font_manager_font_data_free (FontManagerFontData* self) {
	font_manager_font_data_destroy (self);
	g_free (self);
}


GType font_manager_font_data_get_type (void) {
	static volatile gsize font_manager_font_data_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_font_data_type_id__volatile)) {
		GType font_manager_font_data_type_id;
		font_manager_font_data_type_id = g_boxed_type_register_static ("FontManagerFontData", (GBoxedCopyFunc) font_manager_font_data_dup, (GBoxedFreeFunc) font_manager_font_data_free);
		g_once_init_leave (&font_manager_font_data_type_id__volatile, font_manager_font_data_type_id);
	}
	return font_manager_font_data_type_id__volatile;
}


gboolean font_manager_library_is_installed (FontManagerFontData* fontdata) {
	gboolean result = FALSE;
	GeeArrayList* filelist = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	FontManagerFontData _tmp2_ = {0};
	FontConfigFont* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	GeeArrayList* _filelist = NULL;
	FontManagerFontData _tmp7_ = {0};
	FontManagerFontInfo* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	GeeArrayList* _tmp11_ = NULL;
	g_return_val_if_fail (fontdata != NULL, FALSE);
	_tmp0_ = font_config_list_files ();
	filelist = _tmp0_;
	_tmp1_ = filelist;
	_tmp2_ = *fontdata;
	_tmp3_ = _tmp2_.font;
	_tmp4_ = font_config_font_get_filepath (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp1_, _tmp5_);
	if (_tmp6_) {
		g_debug ("Library.vala:47: Font already installed : Filepath match");
		result = TRUE;
		_g_object_unref0 (filelist);
		return result;
	}
	_tmp7_ = *fontdata;
	_tmp8_ = _tmp7_.fontinfo;
	_tmp9_ = font_manager_font_info_get_checksum (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = font_manager_library_db_match_checksum (_tmp10_);
	_filelist = _tmp11_;
	{
		GeeArrayList* _f_list = NULL;
		GeeArrayList* _tmp12_ = NULL;
		GeeArrayList* _tmp13_ = NULL;
		gint _f_size = 0;
		GeeArrayList* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		gint _f_index = 0;
		_tmp12_ = _filelist;
		_tmp13_ = _g_object_ref0 (_tmp12_);
		_f_list = _tmp13_;
		_tmp14_ = _f_list;
		_tmp15_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp14_);
		_tmp16_ = _tmp15_;
		_f_size = _tmp16_;
		_f_index = -1;
		while (TRUE) {
			gint _tmp17_ = 0;
			gint _tmp18_ = 0;
			gint _tmp19_ = 0;
			gchar* f = NULL;
			GeeArrayList* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			gpointer _tmp22_ = NULL;
			GeeArrayList* _tmp23_ = NULL;
			const gchar* _tmp24_ = NULL;
			gboolean _tmp25_ = FALSE;
			_tmp17_ = _f_index;
			_f_index = _tmp17_ + 1;
			_tmp18_ = _f_index;
			_tmp19_ = _f_size;
			if (!(_tmp18_ < _tmp19_)) {
				break;
			}
			_tmp20_ = _f_list;
			_tmp21_ = _f_index;
			_tmp22_ = gee_abstract_list_get ((GeeAbstractList*) _tmp20_, _tmp21_);
			f = (gchar*) _tmp22_;
			_tmp23_ = filelist;
			_tmp24_ = f;
			_tmp25_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp23_, _tmp24_);
			if (_tmp25_) {
				g_debug ("Library.vala:53: Font already installed : Checksum match");
				result = TRUE;
				_g_free0 (f);
				_g_object_unref0 (_f_list);
				_g_object_unref0 (_filelist);
				_g_object_unref0 (filelist);
				return result;
			}
			_g_free0 (f);
		}
		_g_object_unref0 (_f_list);
	}
	result = FALSE;
	_g_object_unref0 (_filelist);
	_g_object_unref0 (filelist);
	return result;
}


gint font_manager_library_conflicts (FontManagerFontData* fontdata) {
	gint result = 0;
	GeeHashMap* unique = NULL;
	FontManagerFontData _tmp0_ = {0};
	GeeHashMap* _tmp1_ = NULL;
	GeeArrayList* filelist = NULL;
	GeeArrayList* _tmp2_ = NULL;
	g_return_val_if_fail (fontdata != NULL, 0);
	_tmp0_ = *fontdata;
	_tmp1_ = font_manager_library_db_match_unique_names (&_tmp0_);
	unique = _tmp1_;
	_tmp2_ = font_config_list_files ();
	filelist = _tmp2_;
	{
		GeeIterator* _f_it = NULL;
		GeeHashMap* _tmp3_ = NULL;
		GeeSet* _tmp4_ = NULL;
		GeeSet* _tmp5_ = NULL;
		GeeSet* _tmp6_ = NULL;
		GeeIterator* _tmp7_ = NULL;
		GeeIterator* _tmp8_ = NULL;
		_tmp3_ = unique;
		_tmp4_ = gee_abstract_map_get_keys ((GeeMap*) _tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = _tmp5_;
		_tmp7_ = gee_iterable_iterator ((GeeIterable*) _tmp6_);
		_tmp8_ = _tmp7_;
		_g_object_unref0 (_tmp6_);
		_f_it = _tmp8_;
		while (TRUE) {
			GeeIterator* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			gchar* f = NULL;
			GeeIterator* _tmp11_ = NULL;
			gpointer _tmp12_ = NULL;
			GeeArrayList* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			gboolean _tmp15_ = FALSE;
			_tmp9_ = _f_it;
			_tmp10_ = gee_iterator_next (_tmp9_);
			if (!_tmp10_) {
				break;
			}
			_tmp11_ = _f_it;
			_tmp12_ = gee_iterator_get (_tmp11_);
			f = (gchar*) _tmp12_;
			_tmp13_ = filelist;
			_tmp14_ = f;
			_tmp15_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp13_, _tmp14_);
			if (_tmp15_) {
				FontManagerFontData _tmp16_ = {0};
				FontConfigFont* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				GeeHashMap* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				gpointer _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				FontManagerFontData _tmp25_ = {0};
				FontManagerFontInfo* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				gint _tmp29_ = 0;
				gint _tmp30_ = 0;
				_tmp16_ = *fontdata;
				_tmp17_ = _tmp16_.font;
				_tmp18_ = font_config_font_get_filepath (_tmp17_);
				_tmp19_ = _tmp18_;
				_tmp20_ = f;
				g_debug ("Library.vala:73: %s conflicts with %s", _tmp19_, _tmp20_);
				_tmp21_ = unique;
				_tmp22_ = f;
				_tmp23_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp21_, _tmp22_);
				_tmp24_ = (gchar*) _tmp23_;
				_tmp25_ = *fontdata;
				_tmp26_ = _tmp25_.fontinfo;
				_tmp27_ = font_manager_font_info_get_version (_tmp26_);
				_tmp28_ = _tmp27_;
				_tmp29_ = natural_cmp (_tmp24_, _tmp28_);
				_tmp30_ = _tmp29_;
				_g_free0 (_tmp24_);
				result = _tmp30_;
				_g_free0 (f);
				_g_object_unref0 (_f_it);
				_g_object_unref0 (filelist);
				_g_object_unref0 (unique);
				return result;
			}
			_g_free0 (f);
		}
		_g_object_unref0 (_f_it);
	}
	result = -1;
	_g_object_unref0 (filelist);
	_g_object_unref0 (unique);
	return result;
}


gboolean font_manager_library_is_metrics_file (const gchar* name) {
	gboolean result = FALSE;
	g_return_val_if_fail (name != NULL, FALSE);
	{
		const gchar** ext_collection = NULL;
		gint ext_collection_length1 = 0;
		gint _ext_collection_size_ = 0;
		gint ext_it = 0;
		ext_collection = FONT_MANAGER_FONT_METRICS;
		ext_collection_length1 = G_N_ELEMENTS (FONT_MANAGER_FONT_METRICS);
		for (ext_it = 0; ext_it < G_N_ELEMENTS (FONT_MANAGER_FONT_METRICS); ext_it = ext_it + 1) {
			const gchar* ext = NULL;
			ext = ext_collection[ext_it];
			{
				const gchar* _tmp0_ = NULL;
				const gchar* _tmp1_ = NULL;
				gboolean _tmp2_ = FALSE;
				_tmp0_ = name;
				_tmp1_ = ext;
				_tmp2_ = g_str_has_suffix (_tmp0_, _tmp1_);
				if (_tmp2_) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


GeeArrayList* font_manager_library_db_match_checksum (const gchar* checksum) {
	GeeArrayList* result = NULL;
	GeeArrayList* results = NULL;
	GeeArrayList* _tmp0_ = NULL;
	FontManagerDatabase* db = NULL;
	FontManagerDatabase* _tmp24_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (checksum != NULL, NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	results = _tmp0_;
	db = NULL;
	{
		FontManagerDatabase* _tmp1_ = NULL;
		FontManagerDatabase* _tmp2_ = NULL;
		FontManagerDatabase* _tmp3_ = NULL;
		FontManagerDatabase* _tmp4_ = NULL;
		FontManagerDatabase* _tmp5_ = NULL;
		FontManagerDatabase* _tmp6_ = NULL;
		FontManagerDatabase* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		FontManagerDatabase* _tmp11_ = NULL;
		_tmp2_ = font_manager_get_database (&_inner_error_);
		_tmp1_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch9_font_manager_database_error;
			}
			_g_object_unref0 (db);
			_g_object_unref0 (results);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp3_ = _tmp1_;
		_tmp1_ = NULL;
		_g_object_unref0 (db);
		db = _tmp3_;
		_tmp4_ = db;
		font_manager_database_reset (_tmp4_);
		_tmp5_ = db;
		font_manager_database_set_table (_tmp5_, "Fonts");
		_tmp6_ = db;
		font_manager_database_set_select (_tmp6_, "filepath");
		_tmp7_ = db;
		_tmp8_ = checksum;
		_tmp9_ = g_strdup_printf ("checksum=\"%s\"", _tmp8_);
		_tmp10_ = _tmp9_;
		font_manager_database_set_search (_tmp7_, _tmp10_);
		_g_free0 (_tmp10_);
		_tmp11_ = db;
		font_manager_database_execute_query (_tmp11_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (_tmp1_);
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch9_font_manager_database_error;
			}
			_g_object_unref0 (_tmp1_);
			_g_object_unref0 (db);
			_g_object_unref0 (results);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		{
			FontManagerDatabaseIterator* _row_it = NULL;
			FontManagerDatabase* _tmp12_ = NULL;
			FontManagerDatabaseIterator* _tmp13_ = NULL;
			sqlite3_stmt* row = NULL;
			_tmp12_ = db;
			_tmp13_ = font_manager_database_iterator (_tmp12_);
			_row_it = _tmp13_;
			while (TRUE) {
				FontManagerDatabaseIterator* _tmp14_ = NULL;
				sqlite3_stmt* _tmp15_ = NULL;
				sqlite3_stmt* _tmp16_ = NULL;
				GeeArrayList* _tmp17_ = NULL;
				sqlite3_stmt* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				_tmp14_ = _row_it;
				_tmp15_ = font_manager_database_iterator_next_value (_tmp14_);
				row = _tmp15_;
				_tmp16_ = row;
				if (!(_tmp16_ != NULL)) {
					break;
				}
				_tmp17_ = results;
				_tmp18_ = row;
				_tmp19_ = sqlite3_column_text (_tmp18_, 0);
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp19_);
			}
			_font_manager_database_iterator_unref0 (_row_it);
		}
		_g_object_unref0 (_tmp1_);
	}
	goto __finally9;
	__catch9_font_manager_database_error:
	{
		GError* e = NULL;
		GError* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		GError* _tmp23_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = e;
		_tmp21_ = _tmp20_->message;
		g_critical ("Library.vala:99: Database Error : %s", _tmp21_);
		_tmp22_ = _ ("There was an error accessing the database");
		_tmp23_ = e;
		font_manager_show_error_message (_tmp22_, _tmp23_, NULL);
		_g_error_free0 (e);
	}
	__finally9:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (db);
		_g_object_unref0 (results);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp24_ = db;
	if (_tmp24_ != NULL) {
		FontManagerDatabase* _tmp25_ = NULL;
		_tmp25_ = db;
		font_manager_database_close (_tmp25_);
	}
	result = results;
	_g_object_unref0 (db);
	return result;
}


GeeHashMap* font_manager_library_db_match_unique_names (FontManagerFontData* fontdata) {
	GeeHashMap* result = NULL;
	GeeHashMap* results = NULL;
	GeeHashMap* _tmp0_ = NULL;
	FontManagerDatabase* db = NULL;
	FontManagerDatabase* _tmp33_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (fontdata != NULL, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	results = _tmp0_;
	db = NULL;
	{
		FontManagerDatabase* _tmp1_ = NULL;
		FontManagerDatabase* _tmp2_ = NULL;
		FontManagerDatabase* _tmp3_ = NULL;
		FontManagerDatabase* _tmp4_ = NULL;
		FontManagerDatabase* _tmp5_ = NULL;
		FontManagerDatabase* _tmp6_ = NULL;
		FontManagerDatabase* _tmp7_ = NULL;
		FontManagerFontData _tmp8_ = {0};
		FontManagerFontInfo* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		FontManagerFontData _tmp12_ = {0};
		FontConfigFont* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		FontManagerDatabase* _tmp18_ = NULL;
		_tmp2_ = font_manager_get_database (&_inner_error_);
		_tmp1_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch10_font_manager_database_error;
			}
			_g_object_unref0 (db);
			_g_object_unref0 (results);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp3_ = _tmp1_;
		_tmp1_ = NULL;
		_g_object_unref0 (db);
		db = _tmp3_;
		_tmp4_ = db;
		font_manager_database_reset (_tmp4_);
		_tmp5_ = db;
		font_manager_database_set_table (_tmp5_, "Fonts");
		_tmp6_ = db;
		font_manager_database_set_select (_tmp6_, "filepath, version");
		_tmp7_ = db;
		_tmp8_ = *fontdata;
		_tmp9_ = _tmp8_.fontinfo;
		_tmp10_ = font_manager_font_info_get_psname (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = *fontdata;
		_tmp13_ = _tmp12_.font;
		_tmp14_ = font_config_font_get_description (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = g_strdup_printf ("psname=\"%s\" OR font_description=\"%s\"", _tmp11_, _tmp15_);
		_tmp17_ = _tmp16_;
		font_manager_database_set_search (_tmp7_, _tmp17_);
		_g_free0 (_tmp17_);
		_tmp18_ = db;
		font_manager_database_execute_query (_tmp18_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (_tmp1_);
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch10_font_manager_database_error;
			}
			_g_object_unref0 (_tmp1_);
			_g_object_unref0 (db);
			_g_object_unref0 (results);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		{
			FontManagerDatabaseIterator* _row_it = NULL;
			FontManagerDatabase* _tmp19_ = NULL;
			FontManagerDatabaseIterator* _tmp20_ = NULL;
			sqlite3_stmt* row = NULL;
			_tmp19_ = db;
			_tmp20_ = font_manager_database_iterator (_tmp19_);
			_row_it = _tmp20_;
			while (TRUE) {
				FontManagerDatabaseIterator* _tmp21_ = NULL;
				sqlite3_stmt* _tmp22_ = NULL;
				sqlite3_stmt* _tmp23_ = NULL;
				GeeHashMap* _tmp24_ = NULL;
				sqlite3_stmt* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				sqlite3_stmt* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				_tmp21_ = _row_it;
				_tmp22_ = font_manager_database_iterator_next_value (_tmp21_);
				row = _tmp22_;
				_tmp23_ = row;
				if (!(_tmp23_ != NULL)) {
					break;
				}
				_tmp24_ = results;
				_tmp25_ = row;
				_tmp26_ = sqlite3_column_text (_tmp25_, 0);
				_tmp27_ = row;
				_tmp28_ = sqlite3_column_text (_tmp27_, 1);
				gee_abstract_map_set ((GeeAbstractMap*) _tmp24_, _tmp26_, _tmp28_);
			}
			_font_manager_database_iterator_unref0 (_row_it);
		}
		_g_object_unref0 (_tmp1_);
	}
	goto __finally10;
	__catch10_font_manager_database_error:
	{
		GError* e = NULL;
		GError* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		GError* _tmp32_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp29_ = e;
		_tmp30_ = _tmp29_->message;
		g_critical ("Library.vala:120: Database Error : %s", _tmp30_);
		_tmp31_ = _ ("There was an error accessing the database");
		_tmp32_ = e;
		font_manager_show_error_message (_tmp31_, _tmp32_, NULL);
		_g_error_free0 (e);
	}
	__finally10:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (db);
		_g_object_unref0 (results);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp33_ = db;
	if (_tmp33_ != NULL) {
		FontManagerDatabase* _tmp34_ = NULL;
		_tmp34_ = db;
		font_manager_database_close (_tmp34_);
	}
	result = results;
	_g_object_unref0 (db);
	return result;
}


void font_manager_library_sorter_sort (FontManagerLibrarySorter* self, GeeArrayList* filelist) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (filelist != NULL);
	_tmp0_ = self->priv->_files;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
	_tmp1_ = self->priv->_archives;
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp1_);
	_tmp2_ = filelist;
	font_manager_library_sorter_process_files (self, _tmp2_);
	return;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = needle;
	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
	result = _tmp1_ != NULL;
	return result;
}


static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static void font_manager_library_sorter_process_directory (FontManagerLibrarySorter* self, GFile* dir) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	{
		GFileInfo* fileinfo = NULL;
		gchar* attrs = NULL;
		gchar* _tmp0_ = NULL;
		GFileEnumerator* enumerator = NULL;
		GFile* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		GFileEnumerator* _tmp3_ = NULL;
		gint processed = 0;
		gint total = 0;
		GFileEnumerator* _tmp10_ = NULL;
		GFile* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		GFileEnumerator* _tmp13_ = NULL;
		GFileEnumerator* _tmp14_ = NULL;
		_tmp0_ = g_strdup_printf ("%s,%s,%s", G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_ATTRIBUTE_STANDARD_TYPE);
		attrs = _tmp0_;
		_tmp1_ = dir;
		_tmp2_ = attrs;
		_tmp3_ = g_file_enumerate_children (_tmp1_, _tmp2_, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
		enumerator = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (attrs);
			_g_object_unref0 (fileinfo);
			goto __catch11_g_error;
		}
		processed = 0;
		total = 0;
		while (TRUE) {
			GFileInfo* _tmp4_ = NULL;
			GFileEnumerator* _tmp5_ = NULL;
			GFileInfo* _tmp6_ = NULL;
			GFileInfo* _tmp7_ = NULL;
			GFileInfo* _tmp8_ = NULL;
			gint _tmp9_ = 0;
			_tmp5_ = enumerator;
			_tmp6_ = g_file_enumerator_next_file (_tmp5_, NULL, &_inner_error_);
			_tmp4_ = _tmp6_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (enumerator);
				_g_free0 (attrs);
				_g_object_unref0 (fileinfo);
				goto __catch11_g_error;
			}
			_tmp7_ = _tmp4_;
			_tmp4_ = NULL;
			_g_object_unref0 (fileinfo);
			fileinfo = _tmp7_;
			_tmp8_ = fileinfo;
			if (!(_tmp8_ != NULL)) {
				_g_object_unref0 (_tmp4_);
				break;
			}
			_tmp9_ = total;
			total = _tmp9_ + 1;
			_g_object_unref0 (_tmp4_);
		}
		_tmp11_ = dir;
		_tmp12_ = attrs;
		_tmp13_ = g_file_enumerate_children (_tmp11_, _tmp12_, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
		_tmp10_ = _tmp13_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (enumerator);
			_g_free0 (attrs);
			_g_object_unref0 (fileinfo);
			goto __catch11_g_error;
		}
		_tmp14_ = _tmp10_;
		_tmp10_ = NULL;
		_g_object_unref0 (enumerator);
		enumerator = _tmp14_;
		while (TRUE) {
			GFileInfo* _tmp15_ = NULL;
			GFileEnumerator* _tmp16_ = NULL;
			GFileInfo* _tmp17_ = NULL;
			GFileInfo* _tmp18_ = NULL;
			GFileInfo* _tmp19_ = NULL;
			gchar* content_type = NULL;
			GFileInfo* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* name = NULL;
			GFileInfo* _tmp23_ = NULL;
			const gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			GFileInfo* _tmp26_ = NULL;
			GFileType _tmp27_ = 0;
			gint _tmp52_ = 0;
			ProgressCallback _tmp53_ = NULL;
			void* _tmp53__target = NULL;
			_tmp16_ = enumerator;
			_tmp17_ = g_file_enumerator_next_file (_tmp16_, NULL, &_inner_error_);
			_tmp15_ = _tmp17_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (_tmp10_);
				_g_object_unref0 (enumerator);
				_g_free0 (attrs);
				_g_object_unref0 (fileinfo);
				goto __catch11_g_error;
			}
			_tmp18_ = _tmp15_;
			_tmp15_ = NULL;
			_g_object_unref0 (fileinfo);
			fileinfo = _tmp18_;
			_tmp19_ = fileinfo;
			if (!(_tmp19_ != NULL)) {
				_g_object_unref0 (_tmp15_);
				break;
			}
			_tmp20_ = fileinfo;
			_tmp21_ = g_file_info_get_content_type (_tmp20_);
			_tmp22_ = g_strdup (_tmp21_);
			content_type = _tmp22_;
			_tmp23_ = fileinfo;
			_tmp24_ = g_file_info_get_name (_tmp23_);
			_tmp25_ = g_strdup (_tmp24_);
			name = _tmp25_;
			_tmp26_ = fileinfo;
			_tmp27_ = g_file_info_get_file_type (_tmp26_);
			if (_tmp27_ == G_FILE_TYPE_DIRECTORY) {
				GFile* _tmp28_ = NULL;
				const gchar* _tmp29_ = NULL;
				GFile* _tmp30_ = NULL;
				GFile* _tmp31_ = NULL;
				_tmp28_ = dir;
				_tmp29_ = name;
				_tmp30_ = g_file_get_child (_tmp28_, _tmp29_);
				_tmp31_ = _tmp30_;
				font_manager_library_sorter_process_directory (self, _tmp31_);
				_g_object_unref0 (_tmp31_);
			} else {
				gboolean _tmp32_ = FALSE;
				const gchar* _tmp33_ = NULL;
				gboolean _tmp34_ = FALSE;
				_tmp33_ = content_type;
				_tmp34_ = string_contains (_tmp33_, "font");
				if (_tmp34_) {
					const gchar* _tmp35_ = NULL;
					gboolean _tmp36_ = FALSE;
					_tmp35_ = name;
					_tmp36_ = font_manager_library_is_metrics_file (_tmp35_);
					_tmp32_ = !_tmp36_;
				} else {
					_tmp32_ = FALSE;
				}
				if (_tmp32_) {
					GeeArrayList* _tmp37_ = NULL;
					GFile* _tmp38_ = NULL;
					const gchar* _tmp39_ = NULL;
					GFile* _tmp40_ = NULL;
					GFile* _tmp41_ = NULL;
					_tmp37_ = self->priv->_files;
					_tmp38_ = dir;
					_tmp39_ = name;
					_tmp40_ = g_file_get_child (_tmp38_, _tmp39_);
					_tmp41_ = _tmp40_;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp37_, _tmp41_);
					_g_object_unref0 (_tmp41_);
				} else {
					gboolean _tmp42_ = FALSE;
					GeeArrayList* _tmp43_ = NULL;
					const gchar* _tmp44_ = NULL;
					gboolean _tmp45_ = FALSE;
					_tmp43_ = font_manager_library_supported_archives;
					_tmp44_ = content_type;
					_tmp45_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp43_, _tmp44_);
					if (_tmp45_) {
						const gchar* _tmp46_ = NULL;
						_tmp46_ = content_type;
						_tmp42_ = !_vala_string_array_contains (FONT_MANAGER_ARCHIVE_IGNORE_LIST, G_N_ELEMENTS (FONT_MANAGER_ARCHIVE_IGNORE_LIST), _tmp46_);
					} else {
						_tmp42_ = FALSE;
					}
					if (_tmp42_) {
						GeeArrayList* _tmp47_ = NULL;
						GFile* _tmp48_ = NULL;
						const gchar* _tmp49_ = NULL;
						GFile* _tmp50_ = NULL;
						GFile* _tmp51_ = NULL;
						_tmp47_ = self->priv->_archives;
						_tmp48_ = dir;
						_tmp49_ = name;
						_tmp50_ = g_file_get_child (_tmp48_, _tmp49_);
						_tmp51_ = _tmp50_;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp47_, _tmp51_);
						_g_object_unref0 (_tmp51_);
					}
				}
			}
			_tmp52_ = processed;
			processed = _tmp52_ + 1;
			_tmp53_ = font_manager_library_progress;
			_tmp53__target = font_manager_library_progress_target;
			if (_tmp53_ != NULL) {
				ProgressCallback _tmp54_ = NULL;
				void* _tmp54__target = NULL;
				const gchar* _tmp55_ = NULL;
				gint _tmp56_ = 0;
				gint _tmp57_ = 0;
				_tmp54_ = font_manager_library_progress;
				_tmp54__target = font_manager_library_progress_target;
				_tmp55_ = _ ("Processing directories");
				_tmp56_ = processed;
				_tmp57_ = total;
				_tmp54_ (_tmp55_, _tmp56_, _tmp57_, _tmp54__target);
			}
			_g_free0 (name);
			_g_free0 (content_type);
			_g_object_unref0 (_tmp15_);
		}
		_g_object_unref0 (_tmp10_);
		_g_object_unref0 (enumerator);
		_g_free0 (attrs);
		_g_object_unref0 (fileinfo);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* e = NULL;
		GError* _tmp58_ = NULL;
		const gchar* _tmp59_ = NULL;
		GFile* _tmp60_ = NULL;
		gchar* _tmp61_ = NULL;
		gchar* _tmp62_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp58_ = e;
		_tmp59_ = _tmp58_->message;
		_tmp60_ = dir;
		_tmp61_ = g_file_get_path (_tmp60_);
		_tmp62_ = _tmp61_;
		g_warning ("Library.vala:174: %s :: %s", _tmp59_, _tmp62_);
		_g_free0 (_tmp62_);
		_g_error_free0 (e);
	}
	__finally11:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	return;
}


static void font_manager_library_sorter_process_files (FontManagerLibrarySorter* self, GeeArrayList* filelist) {
	gint total = 0;
	GeeArrayList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint processed = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (filelist != NULL);
	_tmp0_ = filelist;
	_tmp1_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	total = _tmp2_;
	processed = 0;
	{
		GeeArrayList* _file_list = NULL;
		GeeArrayList* _tmp3_ = NULL;
		GeeArrayList* _tmp4_ = NULL;
		gint _file_size = 0;
		GeeArrayList* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		gint _file_index = 0;
		_tmp3_ = filelist;
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_file_list = _tmp4_;
		_tmp5_ = _file_list;
		_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_file_size = _tmp7_;
		_file_index = -1;
		while (TRUE) {
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			GFile* file = NULL;
			GeeArrayList* _tmp11_ = NULL;
			gint _tmp12_ = 0;
			gpointer _tmp13_ = NULL;
			gchar* attrs = NULL;
			gchar* _tmp14_ = NULL;
			gint _tmp43_ = 0;
			ProgressCallback _tmp44_ = NULL;
			void* _tmp44__target = NULL;
			_tmp8_ = _file_index;
			_file_index = _tmp8_ + 1;
			_tmp9_ = _file_index;
			_tmp10_ = _file_size;
			if (!(_tmp9_ < _tmp10_)) {
				break;
			}
			_tmp11_ = _file_list;
			_tmp12_ = _file_index;
			_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp11_, _tmp12_);
			file = (GFile*) _tmp13_;
			_tmp14_ = g_strdup_printf ("%s,%s,%s", G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_ATTRIBUTE_STANDARD_NAME);
			attrs = _tmp14_;
			{
				GFileInfo* fileinfo = NULL;
				GFile* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				GFileInfo* _tmp17_ = NULL;
				gchar* name = NULL;
				GFileInfo* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				gchar* content_type = NULL;
				GFileInfo* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				GFileInfo* _tmp24_ = NULL;
				GFileType _tmp25_ = 0;
				_tmp15_ = file;
				_tmp16_ = attrs;
				_tmp17_ = g_file_query_info (_tmp15_, _tmp16_, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
				fileinfo = _tmp17_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch12_g_error;
				}
				_tmp18_ = fileinfo;
				_tmp19_ = g_file_info_get_name (_tmp18_);
				_tmp20_ = g_strdup (_tmp19_);
				name = _tmp20_;
				_tmp21_ = fileinfo;
				_tmp22_ = g_file_info_get_content_type (_tmp21_);
				_tmp23_ = g_strdup (_tmp22_);
				content_type = _tmp23_;
				_tmp24_ = fileinfo;
				_tmp25_ = g_file_info_get_file_type (_tmp24_);
				if (_tmp25_ == G_FILE_TYPE_DIRECTORY) {
					GFile* _tmp26_ = NULL;
					_tmp26_ = file;
					font_manager_library_sorter_process_directory (self, _tmp26_);
				} else {
					gboolean _tmp27_ = FALSE;
					const gchar* _tmp28_ = NULL;
					gboolean _tmp29_ = FALSE;
					_tmp28_ = content_type;
					_tmp29_ = string_contains (_tmp28_, "font");
					if (_tmp29_) {
						const gchar* _tmp30_ = NULL;
						gboolean _tmp31_ = FALSE;
						_tmp30_ = name;
						_tmp31_ = font_manager_library_is_metrics_file (_tmp30_);
						_tmp27_ = !_tmp31_;
					} else {
						_tmp27_ = FALSE;
					}
					if (_tmp27_) {
						GeeArrayList* _tmp32_ = NULL;
						GFile* _tmp33_ = NULL;
						_tmp32_ = self->priv->_files;
						_tmp33_ = file;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp33_);
					} else {
						GeeArrayList* _tmp34_ = NULL;
						const gchar* _tmp35_ = NULL;
						gboolean _tmp36_ = FALSE;
						_tmp34_ = font_manager_library_supported_archives;
						_tmp35_ = content_type;
						_tmp36_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp34_, _tmp35_);
						if (_tmp36_) {
							GeeArrayList* _tmp37_ = NULL;
							GFile* _tmp38_ = NULL;
							_tmp37_ = self->priv->_archives;
							_tmp38_ = file;
							gee_abstract_collection_add ((GeeAbstractCollection*) _tmp37_, _tmp38_);
						}
					}
				}
				_g_free0 (content_type);
				_g_free0 (name);
				_g_object_unref0 (fileinfo);
			}
			goto __finally12;
			__catch12_g_error:
			{
				GError* e = NULL;
				GError* _tmp39_ = NULL;
				const gchar* _tmp40_ = NULL;
				const gchar* _tmp41_ = NULL;
				GError* _tmp42_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp39_ = e;
				_tmp40_ = _tmp39_->message;
				g_critical ("Library.vala:195: Error querying file information : %s", _tmp40_);
				_tmp41_ = _ ("Error querying file information");
				_tmp42_ = e;
				font_manager_show_error_message (_tmp41_, _tmp42_, NULL);
				_g_error_free0 (e);
			}
			__finally12:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (attrs);
				_g_object_unref0 (file);
				_g_object_unref0 (_file_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp43_ = processed;
			processed = _tmp43_ + 1;
			_tmp44_ = font_manager_library_progress;
			_tmp44__target = font_manager_library_progress_target;
			if (_tmp44_ != NULL) {
				ProgressCallback _tmp45_ = NULL;
				void* _tmp45__target = NULL;
				const gchar* _tmp46_ = NULL;
				gint _tmp47_ = 0;
				gint _tmp48_ = 0;
				_tmp45_ = font_manager_library_progress;
				_tmp45__target = font_manager_library_progress_target;
				_tmp46_ = _ ("Processing files");
				_tmp47_ = processed;
				_tmp48_ = total;
				_tmp45_ (_tmp46_, _tmp47_, _tmp48_, _tmp45__target);
			}
			_g_free0 (attrs);
			_g_object_unref0 (file);
		}
		_g_object_unref0 (_file_list);
	}
	return;
}


FontManagerLibrarySorter* font_manager_library_sorter_construct (GType object_type) {
	FontManagerLibrarySorter * self = NULL;
	self = (FontManagerLibrarySorter*) g_object_new (object_type, NULL);
	return self;
}


FontManagerLibrarySorter* font_manager_library_sorter_new (void) {
	return font_manager_library_sorter_construct (FONT_MANAGER_LIBRARY_TYPE_SORTER);
}


GeeArrayList* font_manager_library_sorter_get_files (FontManagerLibrarySorter* self) {
	GeeArrayList* result;
	GeeArrayList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_files;
	result = _tmp0_;
	return result;
}


static void font_manager_library_sorter_set_files (FontManagerLibrarySorter* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_files);
	self->priv->_files = _tmp1_;
	g_object_notify ((GObject *) self, "files");
}


GeeArrayList* font_manager_library_sorter_get_archives (FontManagerLibrarySorter* self) {
	GeeArrayList* result;
	GeeArrayList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_archives;
	result = _tmp0_;
	return result;
}


static void font_manager_library_sorter_set_archives (FontManagerLibrarySorter* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_archives);
	self->priv->_archives = _tmp1_;
	g_object_notify ((GObject *) self, "archives");
}


static GObject * font_manager_library_sorter_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FontManagerLibrarySorter * self;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GeeArrayList* _tmp3_ = NULL;
	ArchiveManager* _tmp4_ = NULL;
	parent_class = G_OBJECT_CLASS (font_manager_library_sorter_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorter);
	_tmp0_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_tmp1_ = _tmp0_;
	font_manager_library_sorter_set_files (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_tmp3_ = _tmp2_;
	font_manager_library_sorter_set_archives (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = font_manager_library_archive_manager;
	if (_tmp4_ == NULL) {
		ArchiveManager* _tmp5_ = NULL;
		ArchiveManager* _tmp6_ = NULL;
		GeeArrayList* _tmp7_ = NULL;
		_tmp5_ = archive_manager_new ();
		_g_object_unref0 (font_manager_library_archive_manager);
		font_manager_library_archive_manager = _tmp5_;
		_tmp6_ = font_manager_library_archive_manager;
		_tmp7_ = archive_manager_get_supported_types (_tmp6_, "extract");
		_g_object_unref0 (font_manager_library_supported_archives);
		font_manager_library_supported_archives = _tmp7_;
	}
	return obj;
}


static void font_manager_library_sorter_class_init (FontManagerLibrarySorterClass * klass) {
	font_manager_library_sorter_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FontManagerLibrarySorterPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_font_manager_library_sorter_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_font_manager_library_sorter_set_property;
	G_OBJECT_CLASS (klass)->constructor = font_manager_library_sorter_constructor;
	G_OBJECT_CLASS (klass)->finalize = font_manager_library_sorter_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_LIBRARY_SORTER_FILES, g_param_spec_object ("files", "files", "files", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), FONT_MANAGER_LIBRARY_SORTER_ARCHIVES, g_param_spec_object ("archives", "archives", "archives", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void font_manager_library_sorter_instance_init (FontManagerLibrarySorter * self) {
	self->priv = FONT_MANAGER_LIBRARY_SORTER_GET_PRIVATE (self);
}


static void font_manager_library_sorter_finalize (GObject* obj) {
	FontManagerLibrarySorter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorter);
	_g_object_unref0 (self->priv->_files);
	_g_object_unref0 (self->priv->_archives);
	G_OBJECT_CLASS (font_manager_library_sorter_parent_class)->finalize (obj);
}


GType font_manager_library_sorter_get_type (void) {
	static volatile gsize font_manager_library_sorter_type_id__volatile = 0;
	if (g_once_init_enter (&font_manager_library_sorter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FontManagerLibrarySorterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_manager_library_sorter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontManagerLibrarySorter), 0, (GInstanceInitFunc) font_manager_library_sorter_instance_init, NULL };
		GType font_manager_library_sorter_type_id;
		font_manager_library_sorter_type_id = g_type_register_static (G_TYPE_OBJECT, "FontManagerLibrarySorter", &g_define_type_info, 0);
		g_once_init_leave (&font_manager_library_sorter_type_id__volatile, font_manager_library_sorter_type_id);
	}
	return font_manager_library_sorter_type_id__volatile;
}


static void _vala_font_manager_library_sorter_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	FontManagerLibrarySorter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorter);
	switch (property_id) {
		case FONT_MANAGER_LIBRARY_SORTER_FILES:
		g_value_set_object (value, font_manager_library_sorter_get_files (self));
		break;
		case FONT_MANAGER_LIBRARY_SORTER_ARCHIVES:
		g_value_set_object (value, font_manager_library_sorter_get_archives (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_font_manager_library_sorter_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	FontManagerLibrarySorter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, FONT_MANAGER_LIBRARY_TYPE_SORTER, FontManagerLibrarySorter);
	switch (property_id) {
		case FONT_MANAGER_LIBRARY_SORTER_FILES:
		font_manager_library_sorter_set_files (self, g_value_get_object (value));
		break;
		case FONT_MANAGER_LIBRARY_SORTER_ARCHIVES:
		font_manager_library_sorter_set_archives (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


void font_manager_library_install_from_file_array (GFile** files, int files_length1) {
	GeeArrayList* _files = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GFile** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GeeArrayList* _tmp6_ = NULL;
	font_manager_library_install_init ();
	_tmp0_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_files = _tmp0_;
	_tmp1_ = files;
	_tmp1__length1 = files_length1;
	{
		GFile** file_collection = NULL;
		gint file_collection_length1 = 0;
		gint _file_collection_size_ = 0;
		gint file_it = 0;
		file_collection = _tmp1_;
		file_collection_length1 = _tmp1__length1;
		for (file_it = 0; file_it < _tmp1__length1; file_it = file_it + 1) {
			GFile* _tmp2_ = NULL;
			GFile* file = NULL;
			_tmp2_ = _g_object_ref0 (file_collection[file_it]);
			file = _tmp2_;
			{
				GFile* _tmp3_ = NULL;
				GeeArrayList* _tmp4_ = NULL;
				GFile* _tmp5_ = NULL;
				_tmp3_ = file;
				if (_tmp3_ == NULL) {
					_g_object_unref0 (file);
					break;
				}
				_tmp4_ = _files;
				_tmp5_ = file;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp5_);
				_g_object_unref0 (file);
			}
		}
	}
	_tmp6_ = _files;
	font_manager_library_install_process_files (_tmp6_);
	font_manager_library_install_fini ();
	_g_object_unref0 (_files);
}


void font_manager_library_install_from_path_array (gchar** paths, int paths_length1) {
	GeeArrayList* files = NULL;
	GeeArrayList* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GeeArrayList* _tmp8_ = NULL;
	font_manager_library_install_init ();
	_tmp0_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	files = _tmp0_;
	_tmp1_ = paths;
	_tmp1__length1 = paths_length1;
	{
		gchar** path_collection = NULL;
		gint path_collection_length1 = 0;
		gint _path_collection_size_ = 0;
		gint path_it = 0;
		path_collection = _tmp1_;
		path_collection_length1 = _tmp1__length1;
		for (path_it = 0; path_it < _tmp1__length1; path_it = path_it + 1) {
			gchar* _tmp2_ = NULL;
			gchar* path = NULL;
			_tmp2_ = g_strdup (path_collection[path_it]);
			path = _tmp2_;
			{
				const gchar* _tmp3_ = NULL;
				GeeArrayList* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				GFile* _tmp6_ = NULL;
				GFile* _tmp7_ = NULL;
				_tmp3_ = path;
				if (_tmp3_ == NULL) {
					_g_free0 (path);
					break;
				}
				_tmp4_ = files;
				_tmp5_ = path;
				_tmp6_ = g_file_new_for_path (_tmp5_);
				_tmp7_ = _tmp6_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp7_);
				_g_object_unref0 (_tmp7_);
				_g_free0 (path);
			}
		}
	}
	_tmp8_ = files;
	font_manager_library_install_process_files (_tmp8_);
	font_manager_library_install_fini ();
	_g_object_unref0 (files);
}


void font_manager_library_install_from_uri_array (gchar** uris, int uris_length1) {
	GeeArrayList* files = NULL;
	GeeArrayList* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GeeArrayList* _tmp8_ = NULL;
	font_manager_library_install_init ();
	_tmp0_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	files = _tmp0_;
	_tmp1_ = uris;
	_tmp1__length1 = uris_length1;
	{
		gchar** uri_collection = NULL;
		gint uri_collection_length1 = 0;
		gint _uri_collection_size_ = 0;
		gint uri_it = 0;
		uri_collection = _tmp1_;
		uri_collection_length1 = _tmp1__length1;
		for (uri_it = 0; uri_it < _tmp1__length1; uri_it = uri_it + 1) {
			gchar* _tmp2_ = NULL;
			gchar* uri = NULL;
			_tmp2_ = g_strdup (uri_collection[uri_it]);
			uri = _tmp2_;
			{
				const gchar* _tmp3_ = NULL;
				GeeArrayList* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				GFile* _tmp6_ = NULL;
				GFile* _tmp7_ = NULL;
				_tmp3_ = uri;
				if (_tmp3_ == NULL) {
					_g_free0 (uri);
					break;
				}
				_tmp4_ = files;
				_tmp5_ = uri;
				_tmp6_ = g_file_new_for_uri (_tmp5_);
				_tmp7_ = _tmp6_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp7_);
				_g_object_unref0 (_tmp7_);
				_g_free0 (uri);
			}
		}
	}
	_tmp8_ = files;
	font_manager_library_install_process_files (_tmp8_);
	font_manager_library_install_fini ();
	_g_object_unref0 (files);
}


static void font_manager_library_install_init (void) {
	ArchiveManager* _tmp0_ = NULL;
	_tmp0_ = font_manager_library_archive_manager;
	if (_tmp0_ == NULL) {
		ArchiveManager* _tmp1_ = NULL;
		ArchiveManager* _tmp2_ = NULL;
		GeeArrayList* _tmp3_ = NULL;
		_tmp1_ = archive_manager_new ();
		_g_object_unref0 (font_manager_library_archive_manager);
		font_manager_library_archive_manager = _tmp1_;
		_tmp2_ = font_manager_library_archive_manager;
		_tmp3_ = archive_manager_get_supported_types (_tmp2_, "extract");
		_g_object_unref0 (font_manager_library_supported_archives);
		font_manager_library_supported_archives = _tmp3_;
	}
	return;
}


static void font_manager_library_install_fini (void) {
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	_tmp0_ = font_manager_library_install_tmpdir;
	if (_tmp0_ == NULL) {
		return;
	}
	g_debug ("Library.vala:263: Removing temporary directory used during installatio" \
"n");
	_tmp1_ = font_manager_library_install_tmpdir;
	remove_directory (_tmp1_, TRUE);
	_g_object_unref0 (font_manager_library_install_tmpdir);
	font_manager_library_install_tmpdir = NULL;
	return;
}


static void font_manager_library_install_try_copy (GFile* original, GFile* copy) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (original != NULL);
	g_return_if_fail (copy != NULL);
	{
		GFile* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		GFile* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		GFile* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp0_ = original;
		_tmp1_ = copy;
		g_file_copy (_tmp0_, _tmp1_, G_FILE_COPY_OVERWRITE | G_FILE_COPY_ALL_METADATA, NULL, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch13_g_error;
		}
		_tmp2_ = original;
		_tmp3_ = g_file_get_path (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = copy;
		_tmp6_ = g_file_get_path (_tmp5_);
		_tmp7_ = _tmp6_;
		g_debug ("Library.vala:272: Successfully copied %s to %s", _tmp4_, _tmp7_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp4_);
	}
	goto __finally13;
	__catch13_g_error:
	{
		GError* e = NULL;
		gchar* path = NULL;
		GFile* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		GeeHashMap* _tmp10_ = NULL;
		GeeHashMap* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		GError* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		GError* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = original;
		_tmp9_ = g_file_get_path (_tmp8_);
		path = _tmp9_;
		_tmp10_ = font_manager_library_install_install_failed;
		if (_tmp10_ == NULL) {
			GeeHashMap* _tmp11_ = NULL;
			_tmp11_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			_g_object_unref0 (font_manager_library_install_install_failed);
			font_manager_library_install_install_failed = _tmp11_;
		}
		_tmp12_ = font_manager_library_install_install_failed;
		_tmp13_ = path;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp12_, _tmp13_, _tmp15_);
		_tmp16_ = e;
		_tmp17_ = _tmp16_->message;
		_tmp18_ = path;
		g_warning ("Library.vala:278: %s : %s", _tmp17_, _tmp18_);
		_g_free0 (path);
		_g_error_free0 (e);
	}
	__finally13:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	return;
}


gboolean font_manager_library_install_install_font (FontManagerFontData* data) {
	gboolean result = FALSE;
	FontManagerFontData _tmp0_ = {0};
	GFile* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	FontManagerFontData _tmp5_ = {0};
	FontConfigFont* _tmp6_ = NULL;
	gchar* dest = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	FontManagerFontData _tmp22_ = {0};
	FontManagerFontInfo* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	FontManagerFontData _tmp26_ = {0};
	FontManagerFontInfo* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	FontManagerFontData _tmp30_ = {0};
	FontConfigFont* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	const gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	const gchar* _tmp36_ = NULL;
	gchar* filename = NULL;
	FontManagerFontData _tmp37_ = {0};
	FontConfigFont* _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	gchar* filepath = NULL;
	const gchar* _tmp40_ = NULL;
	const gchar* _tmp41_ = NULL;
	FontManagerFontData _tmp42_ = {0};
	GFile* _tmp43_ = NULL;
	gchar* _tmp44_ = NULL;
	gchar* _tmp45_ = NULL;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_ = NULL;
	gchar* _tmp48_ = NULL;
	gchar* _tmp49_ = NULL;
	gchar* _tmp50_ = NULL;
	gchar* _tmp51_ = NULL;
	GFile* file = NULL;
	const gchar* _tmp52_ = NULL;
	GFile* _tmp53_ = NULL;
	FontManagerFontData _tmp54_ = {0};
	GFile* _tmp55_ = NULL;
	GFile* _tmp56_ = NULL;
	FontManagerFontData _tmp57_ = {0};
	FontManagerFontInfo* _tmp58_ = NULL;
	const gchar* _tmp59_ = NULL;
	const gchar* _tmp60_ = NULL;
	GeeArrayList* _tmp101_ = NULL;
	GeeArrayList* _tmp103_ = NULL;
	FontManagerFontData _tmp104_ = {0};
	GFile* _tmp105_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (data != NULL, FALSE);
	_tmp0_ = *data;
	_tmp1_ = _tmp0_.file;
	_tmp2_ = g_file_get_path (_tmp1_);
	_tmp3_ = _tmp2_;
	g_debug ("Library.vala:284: Preparing to install %s", _tmp3_);
	_g_free0 (_tmp3_);
	_tmp5_ = *data;
	_tmp6_ = _tmp5_.font;
	if (_tmp6_ == NULL) {
		_tmp4_ = TRUE;
	} else {
		FontManagerFontData _tmp7_ = {0};
		FontManagerFontInfo* _tmp8_ = NULL;
		_tmp7_ = *data;
		_tmp8_ = _tmp7_.fontinfo;
		_tmp4_ = _tmp8_ == NULL;
	}
	if (_tmp4_) {
		GeeHashMap* _tmp9_ = NULL;
		GeeHashMap* _tmp11_ = NULL;
		FontManagerFontData _tmp12_ = {0};
		GFile* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		FontManagerFontData _tmp16_ = {0};
		GFile* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		_tmp9_ = font_manager_library_install_install_failed;
		if (_tmp9_ == NULL) {
			GeeHashMap* _tmp10_ = NULL;
			_tmp10_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			_g_object_unref0 (font_manager_library_install_install_failed);
			font_manager_library_install_install_failed = _tmp10_;
		}
		_tmp11_ = font_manager_library_install_install_failed;
		_tmp12_ = *data;
		_tmp13_ = _tmp12_.file;
		_tmp14_ = g_file_get_path (_tmp13_);
		_tmp15_ = _tmp14_;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp11_, _tmp15_, "Failed to create FontInfo");
		_g_free0 (_tmp15_);
		_tmp16_ = *data;
		_tmp17_ = _tmp16_.file;
		_tmp18_ = g_file_get_path (_tmp17_);
		_tmp19_ = _tmp18_;
		g_warning ("Library.vala:289: Failed to create FontInfo : %s", _tmp19_);
		_g_free0 (_tmp19_);
		result = FALSE;
		return result;
	}
	_tmp20_ = get_user_font_dir ();
	_tmp21_ = _tmp20_;
	_tmp22_ = *data;
	_tmp23_ = _tmp22_.fontinfo;
	_tmp24_ = font_manager_font_info_get_vendor (_tmp23_);
	_tmp25_ = _tmp24_;
	_tmp26_ = *data;
	_tmp27_ = _tmp26_.fontinfo;
	_tmp28_ = font_manager_font_info_get_filetype (_tmp27_);
	_tmp29_ = _tmp28_;
	_tmp30_ = *data;
	_tmp31_ = _tmp30_.font;
	_tmp32_ = font_config_font_get_family (_tmp31_);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_build_filename (_tmp21_, _tmp25_, _tmp29_, _tmp33_, NULL);
	_tmp35_ = _tmp34_;
	_g_free0 (_tmp21_);
	dest = _tmp35_;
	_tmp36_ = dest;
	g_mkdir_with_parents (_tmp36_, 0755);
	_tmp37_ = *data;
	_tmp38_ = _tmp37_.font;
	_tmp39_ = font_config_font_to_filename (_tmp38_);
	filename = _tmp39_;
	_tmp40_ = dest;
	_tmp41_ = filename;
	_tmp42_ = *data;
	_tmp43_ = _tmp42_.file;
	_tmp44_ = g_file_get_path (_tmp43_);
	_tmp45_ = _tmp44_;
	_tmp46_ = get_file_extension (_tmp45_);
	_tmp47_ = _tmp46_;
	_tmp48_ = g_strdup_printf ("%s.%s", _tmp41_, _tmp47_);
	_tmp49_ = _tmp48_;
	_tmp50_ = g_build_filename (_tmp40_, _tmp49_, NULL);
	_tmp51_ = _tmp50_;
	_g_free0 (_tmp49_);
	_g_free0 (_tmp47_);
	_g_free0 (_tmp45_);
	filepath = _tmp51_;
	_tmp52_ = filepath;
	_tmp53_ = g_file_new_for_path (_tmp52_);
	file = _tmp53_;
	_tmp54_ = *data;
	_tmp55_ = _tmp54_.file;
	_tmp56_ = file;
	font_manager_library_install_try_copy (_tmp55_, _tmp56_);
	_tmp57_ = *data;
	_tmp58_ = _tmp57_.fontinfo;
	_tmp59_ = font_manager_font_info_get_filetype (_tmp58_);
	_tmp60_ = _tmp59_;
	if (g_strcmp0 (_tmp60_, "Type 1") == 0) {
		gchar* par = NULL;
		FontManagerFontData _tmp61_ = {0};
		GFile* _tmp62_ = NULL;
		GFile* _tmp63_ = NULL;
		GFile* _tmp64_ = NULL;
		gchar* _tmp65_ = NULL;
		gchar* _tmp66_ = NULL;
		_tmp61_ = *data;
		_tmp62_ = _tmp61_.file;
		_tmp63_ = g_file_get_parent (_tmp62_);
		_tmp64_ = _tmp63_;
		_tmp65_ = g_file_get_path (_tmp64_);
		_tmp66_ = _tmp65_;
		_g_object_unref0 (_tmp64_);
		par = _tmp66_;
		{
			const gchar** ext_collection = NULL;
			gint ext_collection_length1 = 0;
			gint _ext_collection_size_ = 0;
			gint ext_it = 0;
			ext_collection = FONT_MANAGER_FONT_METRICS;
			ext_collection_length1 = G_N_ELEMENTS (FONT_MANAGER_FONT_METRICS);
			for (ext_it = 0; ext_it < G_N_ELEMENTS (FONT_MANAGER_FONT_METRICS); ext_it = ext_it + 1) {
				const gchar* ext = NULL;
				ext = ext_collection[ext_it];
				{
					{
						GFileInfo* inf = NULL;
						FontManagerFontData _tmp67_ = {0};
						GFile* _tmp68_ = NULL;
						GFileInfo* _tmp69_ = NULL;
						gchar* name = NULL;
						GFileInfo* _tmp70_ = NULL;
						const gchar* _tmp71_ = NULL;
						gchar** _tmp72_ = NULL;
						gchar** _tmp73_ = NULL;
						gchar** _tmp74_ = NULL;
						gint _tmp74__length1 = 0;
						const gchar* _tmp75_ = NULL;
						const gchar* _tmp76_ = NULL;
						gchar* _tmp77_ = NULL;
						gchar* _tmp78_ = NULL;
						gchar* poss = NULL;
						const gchar* _tmp79_ = NULL;
						const gchar* _tmp80_ = NULL;
						gchar* _tmp81_ = NULL;
						GFile* f = NULL;
						const gchar* _tmp82_ = NULL;
						GFile* _tmp83_ = NULL;
						GFile* _tmp84_ = NULL;
						gboolean _tmp85_ = FALSE;
						_tmp67_ = *data;
						_tmp68_ = _tmp67_.file;
						_tmp69_ = g_file_query_info (_tmp68_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
						inf = _tmp69_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							goto __catch14_g_error;
						}
						_tmp70_ = inf;
						_tmp71_ = g_file_info_get_name (_tmp70_);
						_tmp73_ = _tmp72_ = g_strsplit_set (_tmp71_, ".", 0);
						_tmp74_ = _tmp73_;
						_tmp74__length1 = _vala_array_length (_tmp72_);
						_tmp75_ = _tmp74_[0];
						_tmp76_ = ext;
						_tmp77_ = g_strconcat (_tmp75_, _tmp76_, NULL);
						_tmp78_ = _tmp77_;
						_tmp74_ = (_vala_array_free (_tmp74_, _tmp74__length1, (GDestroyNotify) g_free), NULL);
						name = _tmp78_;
						_tmp79_ = par;
						_tmp80_ = name;
						_tmp81_ = g_build_filename (_tmp79_, _tmp80_, NULL);
						poss = _tmp81_;
						_tmp82_ = poss;
						_tmp83_ = g_file_new_for_path (_tmp82_);
						f = _tmp83_;
						_tmp84_ = f;
						_tmp85_ = g_file_query_exists (_tmp84_, NULL);
						if (_tmp85_) {
							gchar* path = NULL;
							const gchar* _tmp86_ = NULL;
							const gchar* _tmp87_ = NULL;
							const gchar* _tmp88_ = NULL;
							gchar* _tmp89_ = NULL;
							gchar* _tmp90_ = NULL;
							gchar* _tmp91_ = NULL;
							gchar* _tmp92_ = NULL;
							GFile* _f = NULL;
							const gchar* _tmp93_ = NULL;
							GFile* _tmp94_ = NULL;
							GFile* _tmp95_ = NULL;
							GFile* _tmp96_ = NULL;
							_tmp86_ = dest;
							_tmp87_ = filename;
							_tmp88_ = ext;
							_tmp89_ = g_strconcat (_tmp87_, _tmp88_, NULL);
							_tmp90_ = _tmp89_;
							_tmp91_ = g_build_filename (_tmp86_, _tmp90_, NULL);
							_tmp92_ = _tmp91_;
							_g_free0 (_tmp90_);
							path = _tmp92_;
							_tmp93_ = path;
							_tmp94_ = g_file_new_for_path (_tmp93_);
							_f = _tmp94_;
							_tmp95_ = f;
							_tmp96_ = _f;
							font_manager_library_install_try_copy (_tmp95_, _tmp96_);
							_g_object_unref0 (_f);
							_g_free0 (path);
						}
						_g_object_unref0 (f);
						_g_free0 (poss);
						_g_free0 (name);
						_g_object_unref0 (inf);
					}
					goto __finally14;
					__catch14_g_error:
					{
						GError* e = NULL;
						GError* _tmp97_ = NULL;
						const gchar* _tmp98_ = NULL;
						const gchar* _tmp99_ = NULL;
						GError* _tmp100_ = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_tmp97_ = e;
						_tmp98_ = _tmp97_->message;
						g_critical ("Library.vala:316: Error querying file information : %s", _tmp98_);
						_tmp99_ = _ ("Error querying file information");
						_tmp100_ = e;
						font_manager_show_error_message (_tmp99_, _tmp100_, NULL);
						_g_error_free0 (e);
					}
					__finally14:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_free0 (par);
						_g_object_unref0 (file);
						_g_free0 (filepath);
						_g_free0 (filename);
						_g_free0 (dest);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
			}
		}
		_g_free0 (par);
	}
	_tmp101_ = font_manager_library_install_installed;
	if (_tmp101_ == NULL) {
		GeeArrayList* _tmp102_ = NULL;
		_tmp102_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
		_g_object_unref0 (font_manager_library_install_installed);
		font_manager_library_install_installed = _tmp102_;
	}
	_tmp103_ = font_manager_library_install_installed;
	_tmp104_ = *data;
	_tmp105_ = _tmp104_.file;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp103_, _tmp105_);
	result = TRUE;
	_g_object_unref0 (file);
	_g_free0 (filepath);
	_g_free0 (filename);
	_g_free0 (dest);
	return result;
}


static GFile* font_manager_library_install_get_temp_dir (void) {
	GFile* result = NULL;
	gchar* _tmpdir = NULL;
	GFile* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	_tmpdir = NULL;
	{
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		_tmp1_ = g_dir_make_tmp (FONT_MANAGER_TMPL, &_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch15_g_file_error;
			}
			_g_free0 (_tmpdir);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_free0 (_tmpdir);
		_tmpdir = _tmp2_;
		_g_free0 (_tmp0_);
	}
	goto __finally15;
	__catch15_g_file_error:
	{
		GError* e = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		GError* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_critical ("Library.vala:332: Error creating temporary working directory : %s", _tmp4_);
		_tmp5_ = _ ("Error creating temporary working directory");
		_tmp6_ = e;
		font_manager_show_error_message (_tmp5_, _tmp6_, NULL);
		_g_error_free0 (e);
	}
	__finally15:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (_tmpdir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp8_ = _tmpdir;
	if (_tmp8_ != NULL) {
		const gchar* _tmp9_ = NULL;
		GFile* _tmp10_ = NULL;
		_tmp9_ = _tmpdir;
		_tmp10_ = g_file_new_for_path (_tmp9_);
		_g_object_unref0 (_tmp7_);
		_tmp7_ = _tmp10_;
	} else {
		_g_object_unref0 (_tmp7_);
		_tmp7_ = NULL;
	}
	result = _tmp7_;
	_g_free0 (_tmpdir);
	return result;
}


static void font_manager_library_install_process_files (GeeArrayList* filelist) {
	FontManagerLibrarySorter* sorter = NULL;
	FontManagerLibrarySorter* _tmp0_ = NULL;
	FontManagerLibrarySorter* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	gint processed = 0;
	gint total = 0;
	FontManagerLibrarySorter* _tmp3_ = NULL;
	GeeArrayList* _tmp4_ = NULL;
	GeeArrayList* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	FontManagerLibrarySorter* _tmp8_ = NULL;
	GeeArrayList* _tmp9_ = NULL;
	GeeArrayList* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	FontManagerLibrarySorter* _tmp39_ = NULL;
	GeeArrayList* _tmp40_ = NULL;
	GeeArrayList* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	gint _tmp43_ = 0;
	GFile* _tmp44_ = NULL;
	gchar* uri = NULL;
	GFile* _tmp45_ = NULL;
	gchar* _tmp46_ = NULL;
	GeeArrayList* l = NULL;
	GeeArrayList* _tmp82_ = NULL;
	GeeArrayList* _tmp83_ = NULL;
	GFile* _tmp84_ = NULL;
	GeeArrayList* _tmp85_ = NULL;
	g_return_if_fail (filelist != NULL);
	g_debug ("Library.vala:339: Processing files for installation");
	_tmp0_ = font_manager_library_sorter_new ();
	sorter = _tmp0_;
	_tmp1_ = sorter;
	_tmp2_ = filelist;
	font_manager_library_sorter_sort (_tmp1_, _tmp2_);
	processed = 0;
	_tmp3_ = sorter;
	_tmp4_ = font_manager_library_sorter_get_files (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = sorter;
	_tmp9_ = font_manager_library_sorter_get_archives (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp10_);
	_tmp12_ = _tmp11_;
	total = _tmp7_ + _tmp12_;
	{
		GeeArrayList* _f_list = NULL;
		FontManagerLibrarySorter* _tmp13_ = NULL;
		GeeArrayList* _tmp14_ = NULL;
		GeeArrayList* _tmp15_ = NULL;
		GeeArrayList* _tmp16_ = NULL;
		gint _f_size = 0;
		GeeArrayList* _tmp17_ = NULL;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		gint _f_index = 0;
		_tmp13_ = sorter;
		_tmp14_ = font_manager_library_sorter_get_files (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = _g_object_ref0 (_tmp15_);
		_f_list = _tmp16_;
		_tmp17_ = _f_list;
		_tmp18_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp17_);
		_tmp19_ = _tmp18_;
		_f_size = _tmp19_;
		_f_index = -1;
		while (TRUE) {
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gint _tmp22_ = 0;
			GFile* f = NULL;
			GeeArrayList* _tmp23_ = NULL;
			gint _tmp24_ = 0;
			gpointer _tmp25_ = NULL;
			FontManagerFontData data = {0};
			GFile* _tmp26_ = NULL;
			gboolean _tmp27_ = FALSE;
			FontManagerFontData _tmp28_ = {0};
			gboolean _tmp29_ = FALSE;
			gint _tmp33_ = 0;
			ProgressCallback _tmp34_ = NULL;
			void* _tmp34__target = NULL;
			_tmp20_ = _f_index;
			_f_index = _tmp20_ + 1;
			_tmp21_ = _f_index;
			_tmp22_ = _f_size;
			if (!(_tmp21_ < _tmp22_)) {
				break;
			}
			_tmp23_ = _f_list;
			_tmp24_ = _f_index;
			_tmp25_ = gee_abstract_list_get ((GeeAbstractList*) _tmp23_, _tmp24_);
			f = (GFile*) _tmp25_;
			_tmp26_ = f;
			font_manager_font_data_init (&data, _tmp26_, NULL);
			_tmp28_ = data;
			_tmp29_ = font_manager_library_is_installed (&_tmp28_);
			if (!_tmp29_) {
				FontManagerFontData _tmp30_ = {0};
				gint _tmp31_ = 0;
				_tmp30_ = data;
				_tmp31_ = font_manager_library_conflicts (&_tmp30_);
				_tmp27_ = _tmp31_ < 0;
			} else {
				_tmp27_ = FALSE;
			}
			if (_tmp27_) {
				FontManagerFontData _tmp32_ = {0};
				_tmp32_ = data;
				font_manager_library_install_install_font (&_tmp32_);
			}
			_tmp33_ = processed;
			processed = _tmp33_ + 1;
			_tmp34_ = font_manager_library_progress;
			_tmp34__target = font_manager_library_progress_target;
			if (_tmp34_ != NULL) {
				ProgressCallback _tmp35_ = NULL;
				void* _tmp35__target = NULL;
				const gchar* _tmp36_ = NULL;
				gint _tmp37_ = 0;
				gint _tmp38_ = 0;
				_tmp35_ = font_manager_library_progress;
				_tmp35__target = font_manager_library_progress_target;
				_tmp36_ = _ ("Installing files");
				_tmp37_ = processed;
				_tmp38_ = total;
				_tmp35_ (_tmp36_, _tmp37_, _tmp38_, _tmp35__target);
			}
			font_manager_font_data_destroy (&data);
			_g_object_unref0 (f);
		}
		_g_object_unref0 (_f_list);
	}
	_tmp39_ = sorter;
	_tmp40_ = font_manager_library_sorter_get_archives (_tmp39_);
	_tmp41_ = _tmp40_;
	_tmp42_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp41_);
	_tmp43_ = _tmp42_;
	if (_tmp43_ == 0) {
		_g_object_unref0 (sorter);
		return;
	}
	_tmp44_ = font_manager_library_install_get_temp_dir ();
	_g_object_unref0 (font_manager_library_install_tmpdir);
	font_manager_library_install_tmpdir = _tmp44_;
	_tmp45_ = font_manager_library_install_tmpdir;
	_tmp46_ = g_file_get_uri (_tmp45_);
	uri = _tmp46_;
	g_debug ("Library.vala:356: Preparing Archives");
	{
		GeeArrayList* _a_list = NULL;
		FontManagerLibrarySorter* _tmp47_ = NULL;
		GeeArrayList* _tmp48_ = NULL;
		GeeArrayList* _tmp49_ = NULL;
		GeeArrayList* _tmp50_ = NULL;
		gint _a_size = 0;
		GeeArrayList* _tmp51_ = NULL;
		gint _tmp52_ = 0;
		gint _tmp53_ = 0;
		gint _a_index = 0;
		_tmp47_ = sorter;
		_tmp48_ = font_manager_library_sorter_get_archives (_tmp47_);
		_tmp49_ = _tmp48_;
		_tmp50_ = _g_object_ref0 (_tmp49_);
		_a_list = _tmp50_;
		_tmp51_ = _a_list;
		_tmp52_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp51_);
		_tmp53_ = _tmp52_;
		_a_size = _tmp53_;
		_a_index = -1;
		while (TRUE) {
			gint _tmp54_ = 0;
			gint _tmp55_ = 0;
			gint _tmp56_ = 0;
			GFile* a = NULL;
			GeeArrayList* _tmp57_ = NULL;
			gint _tmp58_ = 0;
			gpointer _tmp59_ = NULL;
			ArchiveManager* _tmp60_ = NULL;
			GFile* _tmp61_ = NULL;
			gchar* _tmp62_ = NULL;
			gchar* _tmp63_ = NULL;
			const gchar* _tmp64_ = NULL;
			gboolean _tmp65_ = FALSE;
			gboolean _tmp66_ = FALSE;
			gint _tmp76_ = 0;
			ProgressCallback _tmp77_ = NULL;
			void* _tmp77__target = NULL;
			_tmp54_ = _a_index;
			_a_index = _tmp54_ + 1;
			_tmp55_ = _a_index;
			_tmp56_ = _a_size;
			if (!(_tmp55_ < _tmp56_)) {
				break;
			}
			_tmp57_ = _a_list;
			_tmp58_ = _a_index;
			_tmp59_ = gee_abstract_list_get ((GeeAbstractList*) _tmp57_, _tmp58_);
			a = (GFile*) _tmp59_;
			_tmp60_ = font_manager_library_archive_manager;
			_tmp61_ = a;
			_tmp62_ = g_file_get_uri (_tmp61_);
			_tmp63_ = _tmp62_;
			_tmp64_ = uri;
			_tmp65_ = archive_manager_extract (_tmp60_, _tmp63_, _tmp64_, FALSE);
			_tmp66_ = !_tmp65_;
			_g_free0 (_tmp63_);
			if (_tmp66_) {
				GeeHashMap* _tmp67_ = NULL;
				GeeHashMap* _tmp69_ = NULL;
				GFile* _tmp70_ = NULL;
				gchar* _tmp71_ = NULL;
				gchar* _tmp72_ = NULL;
				_tmp67_ = font_manager_library_install_install_failed;
				if (_tmp67_ == NULL) {
					GeeHashMap* _tmp68_ = NULL;
					_tmp68_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
					_g_object_unref0 (font_manager_library_install_install_failed);
					font_manager_library_install_install_failed = _tmp68_;
				}
				_tmp69_ = font_manager_library_install_install_failed;
				_tmp70_ = a;
				_tmp71_ = g_file_get_path (_tmp70_);
				_tmp72_ = _tmp71_;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp69_, _tmp72_, "Failed to extract archive");
				_g_free0 (_tmp72_);
			} else {
				GFile* _tmp73_ = NULL;
				gchar* _tmp74_ = NULL;
				gchar* _tmp75_ = NULL;
				_tmp73_ = a;
				_tmp74_ = g_file_get_basename (_tmp73_);
				_tmp75_ = _tmp74_;
				g_debug ("Library.vala:363: Successfully extracted the contents of %s", _tmp75_);
				_g_free0 (_tmp75_);
			}
			_tmp76_ = processed;
			processed = _tmp76_ + 1;
			_tmp77_ = font_manager_library_progress;
			_tmp77__target = font_manager_library_progress_target;
			if (_tmp77_ != NULL) {
				ProgressCallback _tmp78_ = NULL;
				void* _tmp78__target = NULL;
				const gchar* _tmp79_ = NULL;
				gint _tmp80_ = 0;
				gint _tmp81_ = 0;
				_tmp78_ = font_manager_library_progress;
				_tmp78__target = font_manager_library_progress_target;
				_tmp79_ = _ ("Preparing Archives");
				_tmp80_ = processed;
				_tmp81_ = total;
				_tmp78_ (_tmp79_, _tmp80_, _tmp81_, _tmp78__target);
			}
			_g_object_unref0 (a);
		}
		_g_object_unref0 (_a_list);
	}
	_tmp82_ = gee_array_list_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	l = _tmp82_;
	_tmp83_ = l;
	_tmp84_ = font_manager_library_install_tmpdir;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp83_, _tmp84_);
	_tmp85_ = l;
	font_manager_library_install_process_files (_tmp85_);
	_g_object_unref0 (l);
	_g_free0 (uri);
	_g_object_unref0 (sorter);
	return;
}


FontManagerLibraryInstall* font_manager_library_install_new (void) {
	FontManagerLibraryInstall* self;
	self = g_slice_new0 (FontManagerLibraryInstall);
	font_manager_library_install_instance_init (self);
	return self;
}


static void font_manager_library_install_instance_init (FontManagerLibraryInstall * self) {
}


void font_manager_library_install_free (FontManagerLibraryInstall* self) {
	g_slice_free (FontManagerLibraryInstall, self);
}


void font_manager_library_remove_from_file_array (GFile** files, int files_length1) {
	FontManagerDatabase* db = NULL;
	gint total = 0;
	GFile** _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	gint processed = 0;
	GFile** _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	FontManagerDatabase* _tmp43_ = NULL;
	GError * _inner_error_ = NULL;
	db = NULL;
	{
		FontManagerDatabase* _tmp0_ = NULL;
		FontManagerDatabase* _tmp1_ = NULL;
		FontManagerDatabase* _tmp2_ = NULL;
		FontManagerDatabase* _tmp3_ = NULL;
		_tmp1_ = font_manager_get_database (&_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
				goto __catch16_font_manager_database_error;
			}
			_g_object_unref0 (db);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (db);
		db = _tmp2_;
		_tmp3_ = db;
		font_manager_database_set_table (_tmp3_, "Fonts");
		_g_object_unref0 (_tmp0_);
	}
	goto __finally16;
	__catch16_font_manager_database_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("Library.vala:389: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally16:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (db);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp6_ = files;
	_tmp6__length1 = files_length1;
	total = _tmp6__length1;
	processed = 0;
	_tmp7_ = files;
	_tmp7__length1 = files_length1;
	{
		GFile** file_collection = NULL;
		gint file_collection_length1 = 0;
		gint _file_collection_size_ = 0;
		gint file_it = 0;
		file_collection = _tmp7_;
		file_collection_length1 = _tmp7__length1;
		for (file_it = 0; file_it < _tmp7__length1; file_it = file_it + 1) {
			GFile* _tmp8_ = NULL;
			GFile* file = NULL;
			_tmp8_ = _g_object_ref0 (file_collection[file_it]);
			file = _tmp8_;
			{
				{
					GFile* parent = NULL;
					GFile* _tmp9_ = NULL;
					GFile* _tmp10_ = NULL;
					gchar* path = NULL;
					GFile* _tmp11_ = NULL;
					gchar* _tmp12_ = NULL;
					GFile* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					FontManagerDatabase* _tmp15_ = NULL;
					GFile* _tmp23_ = NULL;
					gint _tmp24_ = 0;
					ProgressCallback _tmp25_ = NULL;
					void* _tmp25__target = NULL;
					_tmp9_ = file;
					_tmp10_ = g_file_get_parent (_tmp9_);
					parent = _tmp10_;
					_tmp11_ = file;
					_tmp12_ = g_file_get_path (_tmp11_);
					path = _tmp12_;
					_tmp13_ = file;
					g_file_delete (_tmp13_, NULL, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_free0 (path);
						_g_object_unref0 (parent);
						goto __catch17_g_error;
					}
					_tmp14_ = path;
					g_debug ("Library.vala:398: Successfully removed %s", _tmp14_);
					_tmp15_ = db;
					if (_tmp15_ != NULL) {
						{
							FontManagerDatabase* _tmp16_ = NULL;
							const gchar* _tmp17_ = NULL;
							gchar* _tmp18_ = NULL;
							gchar* _tmp19_ = NULL;
							const gchar* _tmp20_ = NULL;
							_tmp16_ = db;
							_tmp17_ = path;
							_tmp18_ = g_strdup_printf ("filepath=\"%s\"", _tmp17_);
							_tmp19_ = _tmp18_;
							font_manager_database_remove (_tmp16_, _tmp19_, &_inner_error_);
							_g_free0 (_tmp19_);
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
									goto __catch18_font_manager_database_error;
								}
								_g_free0 (path);
								_g_object_unref0 (parent);
								_g_object_unref0 (file);
								_g_object_unref0 (db);
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp20_ = path;
							g_debug ("Library.vala:402: Successfully removed entry for %s from database", _tmp20_);
						}
						goto __finally18;
						__catch18_font_manager_database_error:
						{
							GError* e = NULL;
							GError* _tmp21_ = NULL;
							const gchar* _tmp22_ = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_tmp21_ = e;
							_tmp22_ = _tmp21_->message;
							g_warning ("Library.vala:404: %s", _tmp22_);
							_g_error_free0 (e);
						}
						__finally18:
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_g_free0 (path);
							_g_object_unref0 (parent);
							goto __catch17_g_error;
						}
					}
					_tmp23_ = parent;
					remove_directory_tree_if_empty (_tmp23_);
					_tmp24_ = processed;
					processed = _tmp24_ + 1;
					_tmp25_ = font_manager_library_progress;
					_tmp25__target = font_manager_library_progress_target;
					if (_tmp25_ != NULL) {
						ProgressCallback _tmp26_ = NULL;
						void* _tmp26__target = NULL;
						const gchar* _tmp27_ = NULL;
						gint _tmp28_ = 0;
						gint _tmp29_ = 0;
						_tmp26_ = font_manager_library_progress;
						_tmp26__target = font_manager_library_progress_target;
						_tmp27_ = _ ("Removing files");
						_tmp28_ = processed;
						_tmp29_ = total;
						_tmp26_ (_tmp27_, _tmp28_, _tmp29_, _tmp26__target);
					}
					_g_free0 (path);
					_g_object_unref0 (parent);
				}
				goto __finally17;
				__catch17_g_error:
				{
					GError* e = NULL;
					GeeHashMap* _tmp30_ = NULL;
					GeeHashMap* _tmp32_ = NULL;
					GFile* _tmp33_ = NULL;
					gchar* _tmp34_ = NULL;
					gchar* _tmp35_ = NULL;
					GError* _tmp36_ = NULL;
					const gchar* _tmp37_ = NULL;
					GError* _tmp38_ = NULL;
					const gchar* _tmp39_ = NULL;
					GFile* _tmp40_ = NULL;
					gchar* _tmp41_ = NULL;
					gchar* _tmp42_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp30_ = font_manager_library_remove_remove_failed;
					if (_tmp30_ == NULL) {
						GeeHashMap* _tmp31_ = NULL;
						_tmp31_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
						_g_object_unref0 (font_manager_library_remove_remove_failed);
						font_manager_library_remove_remove_failed = _tmp31_;
					}
					_tmp32_ = font_manager_library_remove_remove_failed;
					_tmp33_ = file;
					_tmp34_ = g_file_get_path (_tmp33_);
					_tmp35_ = _tmp34_;
					_tmp36_ = e;
					_tmp37_ = _tmp36_->message;
					gee_abstract_map_set ((GeeAbstractMap*) _tmp32_, _tmp35_, _tmp37_);
					_g_free0 (_tmp35_);
					_tmp38_ = e;
					_tmp39_ = _tmp38_->message;
					_tmp40_ = file;
					_tmp41_ = g_file_get_path (_tmp40_);
					_tmp42_ = _tmp41_;
					g_warning ("Library.vala:415: %s : %s", _tmp39_, _tmp42_);
					_g_free0 (_tmp42_);
					_g_error_free0 (e);
				}
				__finally17:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (file);
					_g_object_unref0 (db);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_g_object_unref0 (file);
			}
		}
	}
	_tmp43_ = db;
	if (_tmp43_ != NULL) {
		{
			FontManagerDatabase* _tmp44_ = NULL;
			FontManagerDatabase* _tmp45_ = NULL;
			_tmp44_ = db;
			font_manager_database_vacuum (_tmp44_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == FONT_MANAGER_DATABASE_ERROR) {
					goto __catch19_font_manager_database_error;
				}
				_g_object_unref0 (db);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp45_ = db;
			font_manager_database_close (_tmp45_);
		}
		goto __finally19;
		__catch19_font_manager_database_error:
		{
			GError* e = NULL;
			GError* _tmp46_ = NULL;
			const gchar* _tmp47_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp46_ = e;
			_tmp47_ = _tmp46_->message;
			g_warning ("Library.vala:423: %s", _tmp47_);
			_g_error_free0 (e);
		}
		__finally19:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (db);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_g_object_unref0 (db);
}


FontManagerLibraryRemove* font_manager_library_remove_new (void) {
	FontManagerLibraryRemove* self;
	self = g_slice_new0 (FontManagerLibraryRemove);
	font_manager_library_remove_instance_init (self);
	return self;
}


static void font_manager_library_remove_instance_init (FontManagerLibraryRemove * self) {
}


void font_manager_library_remove_free (FontManagerLibraryRemove* self) {
	g_slice_free (FontManagerLibraryRemove, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



