/* ArchiveManager.c generated by valac 0.26.1, the Vala compiler
 * generated from ArchiveManager.vala, do not modify */

/* ArchiveManager.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gee.h>


#define TYPE_DBUS_SERVICE (dbus_service_get_type ())
#define DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DBUS_SERVICE, DBusService))
#define IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DBUS_SERVICE))
#define DBUS_SERVICE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_DBUS_SERVICE, DBusServiceIface))

typedef struct _DBusService DBusService;
typedef struct _DBusServiceIface DBusServiceIface;

#define TYPE_DBUS_SERVICE_PROXY (dbus_service_proxy_get_type ())
typedef GDBusProxy DBusServiceProxy;
typedef GDBusProxyClass DBusServiceProxyClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_ARCHIVE_MANAGER (archive_manager_get_type ())
#define ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManager))
#define ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))
#define IS_ARCHIVE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ARCHIVE_MANAGER))
#define IS_ARCHIVE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ARCHIVE_MANAGER))
#define ARCHIVE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ARCHIVE_MANAGER, ArchiveManagerClass))

typedef struct _ArchiveManager ArchiveManager;
typedef struct _ArchiveManagerClass ArchiveManagerClass;
typedef struct _ArchiveManagerPrivate ArchiveManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

struct _DBusServiceIface {
	GTypeInterface parent_iface;
	void (*add_to_archive) (DBusService* self, const gchar* archive, gchar** files, int files_length1, gboolean use_progress_dialog, GError** error);
	void (*compress) (DBusService* self, gchar** files, int files_length1, const gchar* destination, gboolean use_progress_dialog, GError** error);
	void (*extract) (DBusService* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog, GError** error);
	void (*extract_here) (DBusService* self, const gchar* archive, gboolean use_progress_dialog, GError** error);
	GHashTable** (*get_supported_types) (DBusService* self, const gchar* action, int* result_length1, GError** error);
};

struct _ArchiveManager {
	GObject parent_instance;
	ArchiveManagerPrivate * priv;
};

struct _ArchiveManagerClass {
	GObjectClass parent_class;
};

struct _ArchiveManagerPrivate {
	DBusService* service;
};


static gpointer archive_manager_parent_class = NULL;

GType dbus_service_proxy_get_type (void) G_GNUC_CONST;
guint dbus_service_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType dbus_service_get_type (void) G_GNUC_CONST;
void dbus_service_add_to_archive (DBusService* self, const gchar* archive, gchar** files, int files_length1, gboolean use_progress_dialog, GError** error);
void dbus_service_compress (DBusService* self, gchar** files, int files_length1, const gchar* destination, gboolean use_progress_dialog, GError** error);
void dbus_service_extract (DBusService* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog, GError** error);
void dbus_service_extract_here (DBusService* self, const gchar* archive, gboolean use_progress_dialog, GError** error);
GHashTable** dbus_service_get_supported_types (DBusService* self, const gchar* action, int* result_length1, GError** error);
static void g_cclosure_user_marshal_VOID__DOUBLE_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void dbus_service_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static void _dbus_handle_dbus_service_progress (DBusService* self, GVariant* parameters);
static void dbus_service_proxy_add_to_archive (DBusService* self, const gchar* archive, gchar** files, int files_length1, gboolean use_progress_dialog, GError** error);
static void dbus_service_proxy_compress (DBusService* self, gchar** files, int files_length1, const gchar* destination, gboolean use_progress_dialog, GError** error);
static void dbus_service_proxy_extract (DBusService* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog, GError** error);
static void dbus_service_proxy_extract_here (DBusService* self, const gchar* archive, gboolean use_progress_dialog, GError** error);
static GHashTable** dbus_service_proxy_get_supported_types (DBusService* self, const gchar* action, int* result_length1, GError** error);
static void dbus_service_proxy_dbus_service_interface_init (DBusServiceIface* iface);
static void _dbus_dbus_service_add_to_archive (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_dbus_service_compress (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_dbus_service_extract (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_dbus_service_extract_here (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_dbus_service_get_supported_types (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void dbus_service_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* dbus_service_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean dbus_service_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_dbus_service_progress (GObject* _sender, gdouble percent, const gchar* message, gpointer* _data);
static void _dbus_service_unregister_object (gpointer user_data);
GType archive_manager_get_type (void) G_GNUC_CONST;
#define ARCHIVE_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ARCHIVE_MANAGER, ArchiveManagerPrivate))
enum  {
	ARCHIVE_MANAGER_DUMMY_PROPERTY
};
void archive_manager_post_error_message (ArchiveManager* self, GError* e);
static void archive_manager_init (ArchiveManager* self);
static void ___lambda111_ (ArchiveManager* self, gdouble p, const gchar* m);
static void ____lambda111__dbus_service_progress (DBusService* _sender, gdouble percent, const gchar* message, gpointer self);
gboolean archive_manager_add_to_archive (ArchiveManager* self, const gchar* archive, gchar** uris, int uris_length1, gboolean use_progress_dialog);
void logger_verbose (const gchar* msg, ...);
static DBusService* archive_manager_get_file_roller (ArchiveManager* self);
gboolean archive_manager_compress (ArchiveManager* self, gchar** uris, int uris_length1, const gchar* destination, gboolean use_progress_dialog);
gboolean archive_manager_extract (ArchiveManager* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog);
gboolean archive_manager_extract_here (ArchiveManager* self, const gchar* archive, gboolean use_progress_dialog);
GeeArrayList* archive_manager_get_supported_types (ArchiveManager* self, const gchar* action);
ArchiveManager* archive_manager_new (void);
ArchiveManager* archive_manager_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__STRING_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void archive_manager_finalize (GObject* obj);
static void _vala_archive_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusArgInfo _dbus_service_dbus_arg_info_add_to_archive_archive = {-1, "archive", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_add_to_archive_files = {-1, "files", "as"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_add_to_archive_use_progress_dialog = {-1, "use_progress_dialog", "b"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_add_to_archive_in[] = {&_dbus_service_dbus_arg_info_add_to_archive_archive, &_dbus_service_dbus_arg_info_add_to_archive_files, &_dbus_service_dbus_arg_info_add_to_archive_use_progress_dialog, NULL};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_add_to_archive_out[] = {NULL};
static const GDBusMethodInfo _dbus_service_dbus_method_info_add_to_archive = {-1, "AddToArchive", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_add_to_archive_in), (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_add_to_archive_out)};
static const GDBusArgInfo _dbus_service_dbus_arg_info_compress_files = {-1, "files", "as"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_compress_destination = {-1, "destination", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_compress_use_progress_dialog = {-1, "use_progress_dialog", "b"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_compress_in[] = {&_dbus_service_dbus_arg_info_compress_files, &_dbus_service_dbus_arg_info_compress_destination, &_dbus_service_dbus_arg_info_compress_use_progress_dialog, NULL};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_compress_out[] = {NULL};
static const GDBusMethodInfo _dbus_service_dbus_method_info_compress = {-1, "Compress", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_compress_in), (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_compress_out)};
static const GDBusArgInfo _dbus_service_dbus_arg_info_extract_archive = {-1, "archive", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_extract_destination = {-1, "destination", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_extract_use_progress_dialog = {-1, "use_progress_dialog", "b"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_extract_in[] = {&_dbus_service_dbus_arg_info_extract_archive, &_dbus_service_dbus_arg_info_extract_destination, &_dbus_service_dbus_arg_info_extract_use_progress_dialog, NULL};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_extract_out[] = {NULL};
static const GDBusMethodInfo _dbus_service_dbus_method_info_extract = {-1, "Extract", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_extract_in), (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_extract_out)};
static const GDBusArgInfo _dbus_service_dbus_arg_info_extract_here_archive = {-1, "archive", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_extract_here_use_progress_dialog = {-1, "use_progress_dialog", "b"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_extract_here_in[] = {&_dbus_service_dbus_arg_info_extract_here_archive, &_dbus_service_dbus_arg_info_extract_here_use_progress_dialog, NULL};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_extract_here_out[] = {NULL};
static const GDBusMethodInfo _dbus_service_dbus_method_info_extract_here = {-1, "ExtractHere", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_extract_here_in), (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_extract_here_out)};
static const GDBusArgInfo _dbus_service_dbus_arg_info_get_supported_types_action = {-1, "action", "s"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_get_supported_types_result = {-1, "result", "aa{ss}"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_get_supported_types_in[] = {&_dbus_service_dbus_arg_info_get_supported_types_action, NULL};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_get_supported_types_out[] = {&_dbus_service_dbus_arg_info_get_supported_types_result, NULL};
static const GDBusMethodInfo _dbus_service_dbus_method_info_get_supported_types = {-1, "GetSupportedTypes", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_get_supported_types_in), (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_get_supported_types_out)};
static const GDBusMethodInfo * const _dbus_service_dbus_method_info[] = {&_dbus_service_dbus_method_info_add_to_archive, &_dbus_service_dbus_method_info_compress, &_dbus_service_dbus_method_info_extract, &_dbus_service_dbus_method_info_extract_here, &_dbus_service_dbus_method_info_get_supported_types, NULL};
static const GDBusArgInfo _dbus_service_dbus_arg_info_progress_percent = {-1, "percent", "d"};
static const GDBusArgInfo _dbus_service_dbus_arg_info_progress_message = {-1, "message", "s"};
static const GDBusArgInfo * const _dbus_service_dbus_arg_info_progress[] = {&_dbus_service_dbus_arg_info_progress_percent, &_dbus_service_dbus_arg_info_progress_message, NULL};
static const GDBusSignalInfo _dbus_service_dbus_signal_info_progress = {-1, "Progress", (GDBusArgInfo **) (&_dbus_service_dbus_arg_info_progress)};
static const GDBusSignalInfo * const _dbus_service_dbus_signal_info[] = {&_dbus_service_dbus_signal_info_progress, NULL};
static const GDBusPropertyInfo * const _dbus_service_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _dbus_service_dbus_interface_info = {-1, "org.gnome.ArchiveManager1", (GDBusMethodInfo **) (&_dbus_service_dbus_method_info), (GDBusSignalInfo **) (&_dbus_service_dbus_signal_info), (GDBusPropertyInfo **) (&_dbus_service_dbus_property_info)};
static const GDBusInterfaceVTable _dbus_service_dbus_interface_vtable = {dbus_service_dbus_interface_method_call, dbus_service_dbus_interface_get_property, dbus_service_dbus_interface_set_property};

void dbus_service_add_to_archive (DBusService* self, const gchar* archive, gchar** files, int files_length1, gboolean use_progress_dialog, GError** error) {
	g_return_if_fail (self != NULL);
	DBUS_SERVICE_GET_INTERFACE (self)->add_to_archive (self, archive, files, files_length1, use_progress_dialog, error);
}


void dbus_service_compress (DBusService* self, gchar** files, int files_length1, const gchar* destination, gboolean use_progress_dialog, GError** error) {
	g_return_if_fail (self != NULL);
	DBUS_SERVICE_GET_INTERFACE (self)->compress (self, files, files_length1, destination, use_progress_dialog, error);
}


void dbus_service_extract (DBusService* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog, GError** error) {
	g_return_if_fail (self != NULL);
	DBUS_SERVICE_GET_INTERFACE (self)->extract (self, archive, destination, use_progress_dialog, error);
}


void dbus_service_extract_here (DBusService* self, const gchar* archive, gboolean use_progress_dialog, GError** error) {
	g_return_if_fail (self != NULL);
	DBUS_SERVICE_GET_INTERFACE (self)->extract_here (self, archive, use_progress_dialog, error);
}


GHashTable** dbus_service_get_supported_types (DBusService* self, const gchar* action, int* result_length1, GError** error) {
	g_return_val_if_fail (self != NULL, NULL);
	return DBUS_SERVICE_GET_INTERFACE (self)->get_supported_types (self, action, result_length1, error);
}


static void g_cclosure_user_marshal_VOID__DOUBLE_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__DOUBLE_STRING) (gpointer data1, gdouble arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__DOUBLE_STRING callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__DOUBLE_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_double (param_values + 1), g_value_get_string (param_values + 2), data2);
}


static void dbus_service_base_init (DBusServiceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		g_signal_new ("progress", TYPE_DBUS_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__DOUBLE_STRING, G_TYPE_NONE, 2, G_TYPE_DOUBLE, G_TYPE_STRING);
	}
}


GType dbus_service_get_type (void) {
	static volatile gsize dbus_service_type_id__volatile = 0;
	if (g_once_init_enter (&dbus_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DBusServiceIface), (GBaseInitFunc) dbus_service_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType dbus_service_type_id;
		dbus_service_type_id = g_type_register_static (G_TYPE_INTERFACE, "DBusService", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (dbus_service_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (dbus_service_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) dbus_service_proxy_get_type);
		g_type_set_qdata (dbus_service_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.gnome.ArchiveManager1");
		g_type_set_qdata (dbus_service_type_id, g_quark_from_static_string ("vala-dbus-interface-info"), (void*) (&_dbus_service_dbus_interface_info));
		g_type_set_qdata (dbus_service_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) dbus_service_register_object);
		g_once_init_leave (&dbus_service_type_id__volatile, dbus_service_type_id);
	}
	return dbus_service_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (DBusServiceProxy, dbus_service_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_DBUS_SERVICE, dbus_service_proxy_dbus_service_interface_init) )
static void dbus_service_proxy_class_init (DBusServiceProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = dbus_service_proxy_g_signal;
}


static void _dbus_handle_dbus_service_progress (DBusService* self, GVariant* parameters) {
	GVariantIter _arguments_iter;
	gdouble percent = 0.0;
	GVariant* _tmp0_;
	gchar* message = NULL;
	GVariant* _tmp1_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	percent = g_variant_get_double (_tmp0_);
	g_variant_unref (_tmp0_);
	_tmp1_ = g_variant_iter_next_value (&_arguments_iter);
	message = g_variant_dup_string (_tmp1_, NULL);
	g_variant_unref (_tmp1_);
	g_signal_emit_by_name (self, "progress", percent, message);
	_g_free0 (message);
}


static void dbus_service_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
	if (strcmp (signal_name, "Progress") == 0) {
		_dbus_handle_dbus_service_progress ((DBusService*) proxy, parameters);
	}
}


static void dbus_service_proxy_init (DBusServiceProxy* self) {
}


static void dbus_service_proxy_add_to_archive (DBusService* self, const gchar* archive, gchar** files, int files_length1, gboolean use_progress_dialog, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	gchar** _tmp2_;
	GVariantBuilder _tmp3_;
	int _tmp4_;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.ArchiveManager1", "AddToArchive");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (archive));
	_tmp2_ = files;
	g_variant_builder_init (&_tmp3_, G_VARIANT_TYPE ("as"));
	for (_tmp4_ = 0; _tmp4_ < files_length1; _tmp4_++) {
		g_variant_builder_add_value (&_tmp3_, g_variant_new_string (*_tmp2_));
		_tmp2_++;
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp3_));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (use_progress_dialog));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void dbus_service_proxy_compress (DBusService* self, gchar** files, int files_length1, const gchar* destination, gboolean use_progress_dialog, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	gchar** _tmp5_;
	GVariantBuilder _tmp6_;
	int _tmp7_;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.ArchiveManager1", "Compress");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	_tmp5_ = files;
	g_variant_builder_init (&_tmp6_, G_VARIANT_TYPE ("as"));
	for (_tmp7_ = 0; _tmp7_ < files_length1; _tmp7_++) {
		g_variant_builder_add_value (&_tmp6_, g_variant_new_string (*_tmp5_));
		_tmp5_++;
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp6_));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (destination));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (use_progress_dialog));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void dbus_service_proxy_extract (DBusService* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.ArchiveManager1", "Extract");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (archive));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (destination));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (use_progress_dialog));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static void dbus_service_proxy_extract_here (DBusService* self, const gchar* archive, gboolean use_progress_dialog, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.ArchiveManager1", "ExtractHere");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (archive));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (use_progress_dialog));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return;
	}
	g_object_unref (_reply_message);
}


static GHashTable** dbus_service_proxy_get_supported_types (DBusService* self, const gchar* action, int* result_length1, GError** error) {
	GDBusMessage *_message;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GDBusMessage *_reply_message;
	GVariant *_reply;
	GVariantIter _reply_iter;
	GHashTable** _result;
	int _result_length1;
	GVariant* _tmp8_;
	GHashTable** _tmp9_;
	int _tmp9__length;
	int _tmp9__size;
	int _tmp9__length1;
	GVariantIter _tmp10_;
	GVariant* _tmp11_;
	G_IO_ERROR;
	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.gnome.ArchiveManager1", "GetSupportedTypes");
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (action));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_message_set_body (_message, _arguments);
	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
	g_object_unref (_message);
	if (!_reply_message) {
		return NULL;
	}
	if (g_dbus_message_to_gerror (_reply_message, error)) {
		g_object_unref (_reply_message);
		return NULL;
	}
	_reply = g_dbus_message_get_body (_reply_message);
	g_variant_iter_init (&_reply_iter, _reply);
	_result_length1 = 0;
	_tmp8_ = g_variant_iter_next_value (&_reply_iter);
	_tmp9_ = g_new (GHashTable*, 5);
	_tmp9__length = 0;
	_tmp9__size = 4;
	_tmp9__length1 = 0;
	g_variant_iter_init (&_tmp10_, _tmp8_);
	for (; (_tmp11_ = g_variant_iter_next_value (&_tmp10_)) != NULL; _tmp9__length1++) {
		GHashTable* _tmp12_;
		GVariantIter _tmp13_;
		GVariant* _tmp14_;
		GVariant* _tmp15_;
		if (_tmp9__size == _tmp9__length) {
			_tmp9__size = 2 * _tmp9__size;
			_tmp9_ = g_renew (GHashTable*, _tmp9_, _tmp9__size + 1);
		}
		_tmp12_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
		g_variant_iter_init (&_tmp13_, _tmp11_);
		while (g_variant_iter_loop (&_tmp13_, "{?*}", &_tmp14_, &_tmp15_)) {
			g_hash_table_insert (_tmp12_, g_variant_dup_string (_tmp14_, NULL), g_variant_dup_string (_tmp15_, NULL));
		}
		_tmp9_[_tmp9__length++] = _tmp12_;
		g_variant_unref (_tmp11_);
	}
	_result_length1 = _tmp9__length1;
	_tmp9_[_tmp9__length] = NULL;
	_result = _tmp9_;
	g_variant_unref (_tmp8_);
	*result_length1 = _result_length1;
	g_object_unref (_reply_message);
	return _result;
}


static void dbus_service_proxy_dbus_service_interface_init (DBusServiceIface* iface) {
	iface->add_to_archive = dbus_service_proxy_add_to_archive;
	iface->compress = dbus_service_proxy_compress;
	iface->extract = dbus_service_proxy_extract;
	iface->extract_here = dbus_service_proxy_extract_here;
	iface->get_supported_types = dbus_service_proxy_get_supported_types;
}


static void _dbus_dbus_service_add_to_archive (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* archive = NULL;
	GVariant* _tmp16_;
	gchar** files = NULL;
	int files_length1 = 0;
	GVariant* _tmp17_;
	gchar** _tmp18_;
	int _tmp18__length;
	int _tmp18__size;
	int _tmp18__length1;
	GVariantIter _tmp19_;
	GVariant* _tmp20_;
	gboolean use_progress_dialog = FALSE;
	GVariant* _tmp21_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp16_ = g_variant_iter_next_value (&_arguments_iter);
	archive = g_variant_dup_string (_tmp16_, NULL);
	g_variant_unref (_tmp16_);
	_tmp17_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp18_ = g_new (gchar*, 5);
	_tmp18__length = 0;
	_tmp18__size = 4;
	_tmp18__length1 = 0;
	g_variant_iter_init (&_tmp19_, _tmp17_);
	for (; (_tmp20_ = g_variant_iter_next_value (&_tmp19_)) != NULL; _tmp18__length1++) {
		if (_tmp18__size == _tmp18__length) {
			_tmp18__size = 2 * _tmp18__size;
			_tmp18_ = g_renew (gchar*, _tmp18_, _tmp18__size + 1);
		}
		_tmp18_[_tmp18__length++] = g_variant_dup_string (_tmp20_, NULL);
		g_variant_unref (_tmp20_);
	}
	files_length1 = _tmp18__length1;
	_tmp18_[_tmp18__length] = NULL;
	files = _tmp18_;
	g_variant_unref (_tmp17_);
	_tmp21_ = g_variant_iter_next_value (&_arguments_iter);
	use_progress_dialog = g_variant_get_boolean (_tmp21_);
	g_variant_unref (_tmp21_);
	dbus_service_add_to_archive (self, archive, files, files_length1, use_progress_dialog, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (archive);
	files = (_vala_array_free (files, files_length1, (GDestroyNotify) g_free), NULL);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dbus_service_compress (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar** files = NULL;
	int files_length1 = 0;
	GVariant* _tmp22_;
	gchar** _tmp23_;
	int _tmp23__length;
	int _tmp23__size;
	int _tmp23__length1;
	GVariantIter _tmp24_;
	GVariant* _tmp25_;
	gchar* destination = NULL;
	GVariant* _tmp26_;
	gboolean use_progress_dialog = FALSE;
	GVariant* _tmp27_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp22_ = g_variant_iter_next_value (&_arguments_iter);
	_tmp23_ = g_new (gchar*, 5);
	_tmp23__length = 0;
	_tmp23__size = 4;
	_tmp23__length1 = 0;
	g_variant_iter_init (&_tmp24_, _tmp22_);
	for (; (_tmp25_ = g_variant_iter_next_value (&_tmp24_)) != NULL; _tmp23__length1++) {
		if (_tmp23__size == _tmp23__length) {
			_tmp23__size = 2 * _tmp23__size;
			_tmp23_ = g_renew (gchar*, _tmp23_, _tmp23__size + 1);
		}
		_tmp23_[_tmp23__length++] = g_variant_dup_string (_tmp25_, NULL);
		g_variant_unref (_tmp25_);
	}
	files_length1 = _tmp23__length1;
	_tmp23_[_tmp23__length] = NULL;
	files = _tmp23_;
	g_variant_unref (_tmp22_);
	_tmp26_ = g_variant_iter_next_value (&_arguments_iter);
	destination = g_variant_dup_string (_tmp26_, NULL);
	g_variant_unref (_tmp26_);
	_tmp27_ = g_variant_iter_next_value (&_arguments_iter);
	use_progress_dialog = g_variant_get_boolean (_tmp27_);
	g_variant_unref (_tmp27_);
	dbus_service_compress (self, files, files_length1, destination, use_progress_dialog, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	files = (_vala_array_free (files, files_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (destination);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dbus_service_extract (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* archive = NULL;
	GVariant* _tmp28_;
	gchar* destination = NULL;
	GVariant* _tmp29_;
	gboolean use_progress_dialog = FALSE;
	GVariant* _tmp30_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp28_ = g_variant_iter_next_value (&_arguments_iter);
	archive = g_variant_dup_string (_tmp28_, NULL);
	g_variant_unref (_tmp28_);
	_tmp29_ = g_variant_iter_next_value (&_arguments_iter);
	destination = g_variant_dup_string (_tmp29_, NULL);
	g_variant_unref (_tmp29_);
	_tmp30_ = g_variant_iter_next_value (&_arguments_iter);
	use_progress_dialog = g_variant_get_boolean (_tmp30_);
	g_variant_unref (_tmp30_);
	dbus_service_extract (self, archive, destination, use_progress_dialog, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (archive);
	_g_free0 (destination);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dbus_service_extract_here (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* archive = NULL;
	GVariant* _tmp31_;
	gboolean use_progress_dialog = FALSE;
	GVariant* _tmp32_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp31_ = g_variant_iter_next_value (&_arguments_iter);
	archive = g_variant_dup_string (_tmp31_, NULL);
	g_variant_unref (_tmp31_);
	_tmp32_ = g_variant_iter_next_value (&_arguments_iter);
	use_progress_dialog = g_variant_get_boolean (_tmp32_);
	g_variant_unref (_tmp32_);
	dbus_service_extract_here (self, archive, use_progress_dialog, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (archive);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_dbus_service_get_supported_types (DBusService* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* action = NULL;
	GVariant* _tmp33_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	GHashTable** result;
	int result_length1 = 0;
	GHashTable** _tmp34_;
	GVariantBuilder _tmp35_;
	int _tmp36_;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp33_ = g_variant_iter_next_value (&_arguments_iter);
	action = g_variant_dup_string (_tmp33_, NULL);
	g_variant_unref (_tmp33_);
	result = dbus_service_get_supported_types (self, action, &result_length1, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_tmp34_ = result;
	g_variant_builder_init (&_tmp35_, G_VARIANT_TYPE ("aa{ss}"));
	for (_tmp36_ = 0; _tmp36_ < result_length1; _tmp36_++) {
		GVariantBuilder _tmp37_;
		GHashTableIter _tmp38_;
		gpointer _tmp39_;
		gpointer _tmp40_;
		g_hash_table_iter_init (&_tmp38_, *_tmp34_);
		g_variant_builder_init (&_tmp37_, G_VARIANT_TYPE ("a{ss}"));
		while (g_hash_table_iter_next (&_tmp38_, &_tmp39_, &_tmp40_)) {
			gchar* _key;
			gchar* _value;
			_key = (gchar*) _tmp39_;
			_value = (gchar*) _tmp40_;
			g_variant_builder_add (&_tmp37_, "{?*}", g_variant_new_string (_key), g_variant_new_string (_value));
		}
		g_variant_builder_add_value (&_tmp35_, g_variant_builder_end (&_tmp37_));
		_tmp34_++;
	}
	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp35_));
	result = (_vala_array_free (result, result_length1, (GDestroyNotify) g_hash_table_unref), NULL);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (action);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void dbus_service_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "AddToArchive") == 0) {
		_dbus_dbus_service_add_to_archive (object, parameters, invocation);
	} else if (strcmp (method_name, "Compress") == 0) {
		_dbus_dbus_service_compress (object, parameters, invocation);
	} else if (strcmp (method_name, "Extract") == 0) {
		_dbus_dbus_service_extract (object, parameters, invocation);
	} else if (strcmp (method_name, "ExtractHere") == 0) {
		_dbus_dbus_service_extract_here (object, parameters, invocation);
	} else if (strcmp (method_name, "GetSupportedTypes") == 0) {
		_dbus_dbus_service_get_supported_types (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* dbus_service_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean dbus_service_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_dbus_service_progress (GObject* _sender, gdouble percent, const gchar* message, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_double (percent));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (message));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.gnome.ArchiveManager1", "Progress", _arguments, NULL);
}


guint dbus_service_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_dbus_service_dbus_interface_info), &_dbus_service_dbus_interface_vtable, data, _dbus_service_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "progress", (GCallback) _dbus_dbus_service_progress, data);
	return result;
}


static void _dbus_service_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_dbus_service_progress, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


void archive_manager_post_error_message (ArchiveManager* self, GError* e) {
	GError* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = e;
	_tmp1_ = _tmp0_->message;
	g_critical ("ArchiveManager.vala:45: Archive Manager : %s", _tmp1_);
}


static void ___lambda111_ (ArchiveManager* self, gdouble p, const gchar* m) {
	const gchar* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	g_return_if_fail (m != NULL);
	_tmp0_ = m;
	_tmp1_ = p;
	g_signal_emit_by_name (self, "progress", _tmp0_, (gint) _tmp1_, 100);
}


static void ____lambda111__dbus_service_progress (DBusService* _sender, gdouble percent, const gchar* message, gpointer self) {
	___lambda111_ ((ArchiveManager*) self, percent, message);
}


static void archive_manager_init (ArchiveManager* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		DBusService* _tmp0_ = NULL;
		DBusService* _tmp1_ = NULL;
		DBusService* _tmp2_ = NULL;
		DBusService* _tmp3_ = NULL;
		_tmp1_ = g_initable_new (TYPE_DBUS_SERVICE_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.gnome.ArchiveManager1", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/gnome/ArchiveManager1", "g-interface-name", "org.gnome.ArchiveManager1", "g-interface-info", g_type_get_qdata (TYPE_DBUS_SERVICE, g_quark_from_static_string ("vala-dbus-interface-info")), NULL);
		_tmp0_ = (DBusService*) _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch1_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->service);
		self->priv->service = _tmp2_;
		_tmp3_ = self->priv->service;
		g_signal_connect_object (_tmp3_, "progress", (GCallback) ____lambda111__dbus_service_progress, self, 0);
		_g_object_unref0 (_tmp0_);
	}
	goto __finally1;
	__catch1_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("ArchiveManager.vala:53: Failed to contact Archive Manager service.");
		g_warning ("ArchiveManager.vala:54: Features which depend on Archive Manager will " \
"not function correctly.");
		_tmp4_ = e;
		archive_manager_post_error_message (self, _tmp4_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	return;
}


gboolean archive_manager_add_to_archive (ArchiveManager* self, const gchar* archive, gchar** uris, int uris_length1, gboolean use_progress_dialog) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (archive != NULL, FALSE);
	_tmp0_ = archive;
	logger_verbose ("File Roller - Add to archive : %s", _tmp0_, NULL);
	{
		DBusService* _tmp1_ = NULL;
		DBusService* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		gboolean _tmp5_ = FALSE;
		_tmp1_ = archive_manager_get_file_roller (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = archive;
		_tmp4_ = uris;
		_tmp4__length1 = uris_length1;
		_tmp5_ = use_progress_dialog;
		dbus_service_add_to_archive (_tmp2_, _tmp3_, _tmp4_, _tmp4__length1, _tmp5_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch2_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		result = TRUE;
		return result;
	}
	goto __finally2;
	__catch2_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		archive_manager_post_error_message (self, _tmp6_);
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


gboolean archive_manager_compress (ArchiveManager* self, gchar** uris, int uris_length1, const gchar* destination, gboolean use_progress_dialog) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (destination != NULL, FALSE);
	_tmp0_ = destination;
	logger_verbose ("File Roller - Compress : %s", _tmp0_, NULL);
	{
		DBusService* _tmp1_ = NULL;
		DBusService* _tmp2_ = NULL;
		gchar** _tmp3_ = NULL;
		gint _tmp3__length1 = 0;
		const gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		_tmp1_ = archive_manager_get_file_roller (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = uris;
		_tmp3__length1 = uris_length1;
		_tmp4_ = destination;
		_tmp5_ = use_progress_dialog;
		dbus_service_compress (_tmp2_, _tmp3_, _tmp3__length1, _tmp4_, _tmp5_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch3_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		result = TRUE;
		return result;
	}
	goto __finally3;
	__catch3_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		archive_manager_post_error_message (self, _tmp6_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


gboolean archive_manager_extract (ArchiveManager* self, const gchar* archive, const gchar* destination, gboolean use_progress_dialog) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (archive != NULL, FALSE);
	g_return_val_if_fail (destination != NULL, FALSE);
	_tmp0_ = archive;
	_tmp1_ = destination;
	logger_verbose ("File Roller - Extract %s to %s", _tmp0_, _tmp1_, NULL);
	{
		DBusService* _tmp2_ = NULL;
		DBusService* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		_tmp2_ = archive_manager_get_file_roller (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = archive;
		_tmp5_ = destination;
		_tmp6_ = use_progress_dialog;
		dbus_service_extract (_tmp3_, _tmp4_, _tmp5_, _tmp6_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch4_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		result = TRUE;
		return result;
	}
	goto __finally4;
	__catch4_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = e;
		archive_manager_post_error_message (self, _tmp7_);
		_g_error_free0 (e);
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


gboolean archive_manager_extract_here (ArchiveManager* self, const gchar* archive, gboolean use_progress_dialog) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (archive != NULL, FALSE);
	_tmp0_ = archive;
	logger_verbose ("File Roller - Extract here : %s", _tmp0_, NULL);
	{
		DBusService* _tmp1_ = NULL;
		DBusService* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		_tmp1_ = archive_manager_get_file_roller (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = archive;
		_tmp4_ = use_progress_dialog;
		dbus_service_extract_here (_tmp2_, _tmp3_, _tmp4_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch5_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		result = TRUE;
		return result;
	}
	goto __finally5;
	__catch5_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		archive_manager_post_error_message (self, _tmp5_);
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


GeeArrayList* archive_manager_get_supported_types (ArchiveManager* self, const gchar* action) {
	GeeArrayList* result = NULL;
	GeeArrayList* types = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (action != NULL, NULL);
	logger_verbose ("File Roller - Get supported types", NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	types = _tmp0_;
	{
		GHashTable** array = NULL;
		DBusService* _tmp1_ = NULL;
		DBusService* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		GHashTable** _tmp5_ = NULL;
		gint array_length1 = 0;
		gint _array_size_ = 0;
		_tmp1_ = archive_manager_get_file_roller (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = action;
		_tmp5_ = dbus_service_get_supported_types (_tmp2_, _tmp3_, &_tmp4_, &_inner_error_);
		array = _tmp5_;
		array_length1 = _tmp4_;
		_array_size_ = array_length1;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
		{
			GHashTable** hashtable_collection = NULL;
			gint hashtable_collection_length1 = 0;
			gint _hashtable_collection_size_ = 0;
			gint hashtable_it = 0;
			hashtable_collection = array;
			hashtable_collection_length1 = array_length1;
			for (hashtable_it = 0; hashtable_it < array_length1; hashtable_it = hashtable_it + 1) {
				GHashTable* _tmp6_ = NULL;
				GHashTable* hashtable = NULL;
				_tmp6_ = _g_hash_table_ref0 (hashtable_collection[hashtable_it]);
				hashtable = _tmp6_;
				{
					GHashTable* _tmp7_ = NULL;
					gconstpointer _tmp8_ = NULL;
					_tmp7_ = hashtable;
					_tmp8_ = g_hash_table_lookup (_tmp7_, "mime-type");
					gee_abstract_collection_add ((GeeAbstractCollection*) types, (const gchar*) _tmp8_);
					_g_hash_table_unref0 (hashtable);
				}
			}
		}
		array = (_vala_array_free (array, array_length1, (GDestroyNotify) g_hash_table_unref), NULL);
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		GError* _tmp9_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp9_ = e;
		archive_manager_post_error_message (self, _tmp9_);
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (types);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = types;
	return result;
}


ArchiveManager* archive_manager_construct (GType object_type) {
	ArchiveManager * self = NULL;
	self = (ArchiveManager*) g_object_new (object_type, NULL);
	return self;
}


ArchiveManager* archive_manager_new (void) {
	return archive_manager_construct (TYPE_ARCHIVE_MANAGER);
}


static DBusService* archive_manager_get_file_roller (ArchiveManager* self) {
	DBusService* result;
	DBusService* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	archive_manager_init (self);
	_tmp0_ = self->priv->service;
	result = _tmp0_;
	return result;
}


static void g_cclosure_user_marshal_VOID__STRING_INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_INT_INT) (gpointer data1, const char* arg_1, gint arg_2, gint arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), g_value_get_int (param_values + 3), data2);
}


static void archive_manager_class_init (ArchiveManagerClass * klass) {
	archive_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ArchiveManagerPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_archive_manager_get_property;
	G_OBJECT_CLASS (klass)->finalize = archive_manager_finalize;
	g_signal_new ("progress", TYPE_ARCHIVE_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT_INT, G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_INT);
}


static void archive_manager_instance_init (ArchiveManager * self) {
	self->priv = ARCHIVE_MANAGER_GET_PRIVATE (self);
	self->priv->service = NULL;
}


static void archive_manager_finalize (GObject* obj) {
	ArchiveManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ARCHIVE_MANAGER, ArchiveManager);
	_g_object_unref0 (self->priv->service);
	G_OBJECT_CLASS (archive_manager_parent_class)->finalize (obj);
}


GType archive_manager_get_type (void) {
	static volatile gsize archive_manager_type_id__volatile = 0;
	if (g_once_init_enter (&archive_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ArchiveManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) archive_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ArchiveManager), 0, (GInstanceInitFunc) archive_manager_instance_init, NULL };
		GType archive_manager_type_id;
		archive_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "ArchiveManager", &g_define_type_info, 0);
		g_once_init_leave (&archive_manager_type_id__volatile, archive_manager_type_id);
	}
	return archive_manager_type_id__volatile;
}


static void _vala_archive_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ArchiveManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_ARCHIVE_MANAGER, ArchiveManager);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



