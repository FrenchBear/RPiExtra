/* Utils.c generated by valac 0.26.1, the Vala compiler
 * generated from Utils.vala, do not modify */

/* Utils.vala
 *
 * Copyright (C) 2009 - 2015 Jerry Casiano
 *
 * This file is part of Font Manager.
 *
 * Font Manager is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Font Manager is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Font Manager.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:
 *        Jerry Casiano <JerryCasiano@gmail.com>
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <locale.h>
#include <pango/pango.h>
#include <gee.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_MENU_ENTRY (menu_entry_get_type ())

#define TYPE_MENU_CALLBACK_WRAPPER (menu_callback_wrapper_get_type ())
#define MENU_CALLBACK_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_CALLBACK_WRAPPER, MenuCallbackWrapper))
#define MENU_CALLBACK_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_CALLBACK_WRAPPER, MenuCallbackWrapperClass))
#define IS_MENU_CALLBACK_WRAPPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_CALLBACK_WRAPPER))
#define IS_MENU_CALLBACK_WRAPPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_CALLBACK_WRAPPER))
#define MENU_CALLBACK_WRAPPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_CALLBACK_WRAPPER, MenuCallbackWrapperClass))

typedef struct _MenuCallbackWrapper MenuCallbackWrapper;
typedef struct _MenuCallbackWrapperClass MenuCallbackWrapperClass;
typedef struct _MenuEntry MenuEntry;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _menu_callback_wrapper_unref0(var) ((var == NULL) ? NULL : (var = (menu_callback_wrapper_unref (var), NULL)))
typedef struct _MenuCallbackWrapperPrivate MenuCallbackWrapperPrivate;
typedef struct _Block2Data Block2Data;
typedef struct _ParamSpecMenuCallbackWrapper ParamSpecMenuCallbackWrapper;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block3Data Block3Data;

typedef void (*ReloadFunc) (void* user_data);
typedef void (*MenuCallback) (void* user_data);
typedef void (*ProgressCallback) (const gchar* message, gint processed, gint total, void* user_data);
struct _MenuEntry {
	gchar* action_name;
	gchar* display_name;
	gchar* detailed_action_name;
	gchar* accelerator;
	MenuCallbackWrapper* method;
};

struct _MenuCallbackWrapper {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MenuCallbackWrapperPrivate * priv;
	MenuCallback run;
	gpointer run_target;
	GDestroyNotify run_target_destroy_notify;
};

struct _MenuCallbackWrapperClass {
	GTypeClass parent_class;
	void (*finalize) (MenuCallbackWrapper *self);
};

struct _Block2Data {
	int _ref_count_;
	MenuCallbackWrapper* self;
	MenuCallback c;
	gpointer c_target;
};

struct _ParamSpecMenuCallbackWrapper {
	GParamSpec parent_instance;
};

struct _Block3Data {
	int _ref_count_;
	MenuEntry entry;
};


static gpointer menu_callback_wrapper_parent_class = NULL;

void intl_setup (const gchar* name);
GType menu_entry_get_type (void) G_GNUC_CONST;
gpointer menu_callback_wrapper_ref (gpointer instance);
void menu_callback_wrapper_unref (gpointer instance);
GParamSpec* param_spec_menu_callback_wrapper (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_menu_callback_wrapper (GValue* value, gpointer v_object);
void value_take_menu_callback_wrapper (GValue* value, gpointer v_object);
gpointer value_get_menu_callback_wrapper (const GValue* value);
GType menu_callback_wrapper_get_type (void) G_GNUC_CONST;
MenuEntry* menu_entry_dup (const MenuEntry* self);
void menu_entry_free (MenuEntry* self);
void menu_entry_copy (const MenuEntry* self, MenuEntry* dest);
void menu_entry_destroy (MenuEntry* self);
void menu_entry_init (MenuEntry *self, const gchar* name, const gchar* label, const gchar* detailed_signal, const gchar* accel, MenuCallbackWrapper* cbw);
enum  {
	MENU_CALLBACK_WRAPPER_DUMMY_PROPERTY
};
MenuCallbackWrapper* menu_callback_wrapper_new (MenuCallback c, void* c_target);
MenuCallbackWrapper* menu_callback_wrapper_construct (GType object_type, MenuCallback c, void* c_target);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda66_ (Block2Data* _data2_);
static void ___lambda66__menu_callback (gpointer self);
static void menu_callback_wrapper_finalize (MenuCallbackWrapper* obj);
gchar* get_command_line_output (const gchar* cmd);
gchar* get_user_font_dir (void);
gchar* get_localized_pangram (void);
gchar* get_localized_preview_text (void);
#define FONT_MANAGER_DEFAULT_PREVIEW_TEXT "\n" \
"%s\n" \
"\n" \
"ABCDEFGHIJKLMNOPQRSTUVWXYZ\n" \
"abcdefghijklmnopqrstuvwxyz\n" \
"1234567890.:,;(*!?')\n" \
"\n"
gchar* get_local_time (void);
gint natural_cmp (const gchar* a, const gchar* b);
gchar* get_file_extension (const gchar* path);
GeeArrayList* sorted_list_from_collection (GeeCollection* iter);
void builder_append (GString* builder, const gchar* val);
void add_action_from_menu_entry (GActionMap* map, MenuEntry* entry);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void __lambda67_ (Block3Data* _data3_, GSimpleAction* a, GVariant* p);
static void ___lambda67__g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self);
gboolean remove_directory_tree_if_empty (GFile* dir);
gboolean remove_directory (GFile* dir, gboolean recursive);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


void intl_setup (const gchar* name) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (name != NULL);
	_tmp0_ = name;
	bindtextdomain (_tmp0_, NULL);
	_tmp1_ = name;
	bind_textdomain_codeset (_tmp1_, NULL);
	_tmp2_ = name;
	textdomain (_tmp2_);
	setlocale (LC_ALL, NULL);
	return;
}


static gpointer _menu_callback_wrapper_ref0 (gpointer self) {
	return self ? menu_callback_wrapper_ref (self) : NULL;
}


void menu_entry_init (MenuEntry *self, const gchar* name, const gchar* label, const gchar* detailed_signal, const gchar* accel, MenuCallbackWrapper* cbw) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	MenuCallbackWrapper* _tmp8_ = NULL;
	MenuCallbackWrapper* _tmp9_ = NULL;
	g_return_if_fail (name != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (detailed_signal != NULL);
	g_return_if_fail (cbw != NULL);
	memset (self, 0, sizeof (MenuEntry));
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*self).action_name);
	(*self).action_name = _tmp1_;
	_tmp2_ = label;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*self).display_name);
	(*self).display_name = _tmp3_;
	_tmp4_ = detailed_signal;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*self).detailed_action_name);
	(*self).detailed_action_name = _tmp5_;
	_tmp6_ = accel;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 ((*self).accelerator);
	(*self).accelerator = _tmp7_;
	_tmp8_ = cbw;
	_tmp9_ = _menu_callback_wrapper_ref0 (_tmp8_);
	_menu_callback_wrapper_unref0 ((*self).method);
	(*self).method = _tmp9_;
}


void menu_entry_copy (const MenuEntry* self, MenuEntry* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	MenuCallbackWrapper* _tmp8_ = NULL;
	MenuCallbackWrapper* _tmp9_ = NULL;
	_tmp0_ = (*self).action_name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).action_name);
	(*dest).action_name = _tmp1_;
	_tmp2_ = (*self).display_name;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest).display_name);
	(*dest).display_name = _tmp3_;
	_tmp4_ = (*self).detailed_action_name;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*dest).detailed_action_name);
	(*dest).detailed_action_name = _tmp5_;
	_tmp6_ = (*self).accelerator;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 ((*dest).accelerator);
	(*dest).accelerator = _tmp7_;
	_tmp8_ = (*self).method;
	_tmp9_ = _menu_callback_wrapper_ref0 (_tmp8_);
	_menu_callback_wrapper_unref0 ((*dest).method);
	(*dest).method = _tmp9_;
}


void menu_entry_destroy (MenuEntry* self) {
	_g_free0 ((*self).action_name);
	_g_free0 ((*self).display_name);
	_g_free0 ((*self).detailed_action_name);
	_g_free0 ((*self).accelerator);
	_menu_callback_wrapper_unref0 ((*self).method);
}


MenuEntry* menu_entry_dup (const MenuEntry* self) {
	MenuEntry* dup;
	dup = g_new0 (MenuEntry, 1);
	menu_entry_copy (self, dup);
	return dup;
}


void menu_entry_free (MenuEntry* self) {
	menu_entry_destroy (self);
	g_free (self);
}


GType menu_entry_get_type (void) {
	static volatile gsize menu_entry_type_id__volatile = 0;
	if (g_once_init_enter (&menu_entry_type_id__volatile)) {
		GType menu_entry_type_id;
		menu_entry_type_id = g_boxed_type_register_static ("MenuEntry", (GBoxedCopyFunc) menu_entry_dup, (GBoxedFreeFunc) menu_entry_free);
		g_once_init_leave (&menu_entry_type_id__volatile, menu_entry_type_id);
	}
	return menu_entry_type_id__volatile;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		MenuCallbackWrapper* self;
		self = _data2_->self;
		_menu_callback_wrapper_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void __lambda66_ (Block2Data* _data2_) {
	MenuCallbackWrapper* self;
	MenuCallback _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	self = _data2_->self;
	_tmp0_ = _data2_->c;
	_tmp0__target = _data2_->c_target;
	_tmp0_ (_tmp0__target);
}


static void ___lambda66__menu_callback (gpointer self) {
	__lambda66_ (self);
}


MenuCallbackWrapper* menu_callback_wrapper_construct (GType object_type, MenuCallback c, void* c_target) {
	MenuCallbackWrapper* self = NULL;
	Block2Data* _data2_;
	MenuCallback _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	self = (MenuCallbackWrapper*) g_type_create_instance (object_type);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = menu_callback_wrapper_ref (self);
	_tmp0_ = c;
	_tmp0__target = c_target;
	_data2_->c = _tmp0_;
	_data2_->c_target = _tmp0__target;
	(self->run_target_destroy_notify == NULL) ? NULL : (self->run_target_destroy_notify (self->run_target), NULL);
	self->run = NULL;
	self->run_target = NULL;
	self->run_target_destroy_notify = NULL;
	self->run = ___lambda66__menu_callback;
	self->run_target = block2_data_ref (_data2_);
	self->run_target_destroy_notify = block2_data_unref;
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return self;
}


MenuCallbackWrapper* menu_callback_wrapper_new (MenuCallback c, void* c_target) {
	return menu_callback_wrapper_construct (TYPE_MENU_CALLBACK_WRAPPER, c, c_target);
}


static void value_menu_callback_wrapper_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_menu_callback_wrapper_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		menu_callback_wrapper_unref (value->data[0].v_pointer);
	}
}


static void value_menu_callback_wrapper_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = menu_callback_wrapper_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_menu_callback_wrapper_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_menu_callback_wrapper_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		MenuCallbackWrapper* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = menu_callback_wrapper_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_menu_callback_wrapper_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	MenuCallbackWrapper** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = menu_callback_wrapper_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_menu_callback_wrapper (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecMenuCallbackWrapper* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_MENU_CALLBACK_WRAPPER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_menu_callback_wrapper (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MENU_CALLBACK_WRAPPER), NULL);
	return value->data[0].v_pointer;
}


void value_set_menu_callback_wrapper (GValue* value, gpointer v_object) {
	MenuCallbackWrapper* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MENU_CALLBACK_WRAPPER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MENU_CALLBACK_WRAPPER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		menu_callback_wrapper_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		menu_callback_wrapper_unref (old);
	}
}


void value_take_menu_callback_wrapper (GValue* value, gpointer v_object) {
	MenuCallbackWrapper* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_MENU_CALLBACK_WRAPPER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_MENU_CALLBACK_WRAPPER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		menu_callback_wrapper_unref (old);
	}
}


static void menu_callback_wrapper_class_init (MenuCallbackWrapperClass * klass) {
	menu_callback_wrapper_parent_class = g_type_class_peek_parent (klass);
	((MenuCallbackWrapperClass *) klass)->finalize = menu_callback_wrapper_finalize;
}


static void menu_callback_wrapper_instance_init (MenuCallbackWrapper * self) {
	self->ref_count = 1;
}


static void menu_callback_wrapper_finalize (MenuCallbackWrapper* obj) {
	MenuCallbackWrapper * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MENU_CALLBACK_WRAPPER, MenuCallbackWrapper);
	g_signal_handlers_destroy (self);
	(self->run_target_destroy_notify == NULL) ? NULL : (self->run_target_destroy_notify (self->run_target), NULL);
	self->run = NULL;
	self->run_target = NULL;
	self->run_target_destroy_notify = NULL;
}


GType menu_callback_wrapper_get_type (void) {
	static volatile gsize menu_callback_wrapper_type_id__volatile = 0;
	if (g_once_init_enter (&menu_callback_wrapper_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_menu_callback_wrapper_init, value_menu_callback_wrapper_free_value, value_menu_callback_wrapper_copy_value, value_menu_callback_wrapper_peek_pointer, "p", value_menu_callback_wrapper_collect_value, "p", value_menu_callback_wrapper_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (MenuCallbackWrapperClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) menu_callback_wrapper_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MenuCallbackWrapper), 0, (GInstanceInitFunc) menu_callback_wrapper_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType menu_callback_wrapper_type_id;
		menu_callback_wrapper_type_id = g_type_register_fundamental (g_type_fundamental_next (), "MenuCallbackWrapper", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&menu_callback_wrapper_type_id__volatile, menu_callback_wrapper_type_id);
	}
	return menu_callback_wrapper_type_id__volatile;
}


gpointer menu_callback_wrapper_ref (gpointer instance) {
	MenuCallbackWrapper* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void menu_callback_wrapper_unref (gpointer instance) {
	MenuCallbackWrapper* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		MENU_CALLBACK_WRAPPER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


gchar* get_command_line_output (const gchar* cmd) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (cmd != NULL, NULL);
	{
		gint exit = 0;
		gchar* std_out = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		_tmp0_ = cmd;
		g_spawn_command_line_sync (_tmp0_, &_tmp1_, NULL, &_tmp2_, &_inner_error_);
		_g_free0 (std_out);
		std_out = _tmp1_;
		exit = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (std_out);
			goto __catch28_g_error;
		}
		result = std_out;
		return result;
	}
	goto __finally28;
	__catch28_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_ = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = cmd;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("Utils.vala:70: Execution of %s failed : %s", _tmp3_, _tmp5_);
		result = NULL;
		_g_error_free0 (e);
		return result;
	}
	__finally28:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


gchar* get_user_font_dir (void) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	_tmp0_ = g_get_user_data_dir ();
	_tmp1_ = g_build_filename (_tmp0_, "fonts", NULL);
	result = _tmp1_;
	return result;
}


gchar* get_localized_pangram (void) {
	gchar* result = NULL;
	PangoLanguage* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	_tmp0_ = pango_language_get_default ();
	_tmp1_ = pango_language_get_sample_string (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	result = _tmp2_;
	return result;
}


gchar* get_localized_preview_text (void) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = get_localized_pangram ();
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup_printf (FONT_MANAGER_DEFAULT_PREVIEW_TEXT, _tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	result = _tmp3_;
	return result;
}


gchar* get_local_time (void) {
	gchar* result = NULL;
	GDateTime* creation_time = NULL;
	GDateTime* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	_tmp0_ = g_date_time_new_now_local ();
	creation_time = _tmp0_;
	_tmp1_ = g_date_time_format (creation_time, "%c");
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%s", _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	_g_date_time_unref0 (creation_time);
	return result;
}


gint natural_cmp (const gchar* a, const gchar* b) {
	gint result = 0;
	GCompareFunc _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = g_utf8_collate_key_for_filename (_tmp1_, (gssize) (-1));
	_tmp3_ = _tmp2_;
	_tmp4_ = b;
	_tmp5_ = g_utf8_collate_key_for_filename (_tmp4_, (gssize) (-1));
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp0_ (_tmp3_, _tmp6_);
	_tmp8_ = _tmp7_;
	_g_free0 (_tmp6_);
	_g_free0 (_tmp3_);
	result = _tmp8_;
	return result;
}


gchar* get_file_extension (const gchar* path) {
	gchar* result = NULL;
	gchar** arr = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint arr_length1 = 0;
	gint _arr_size_ = 0;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = path;
	_tmp2_ = _tmp1_ = g_strsplit_set (_tmp0_, ".", 0);
	arr = _tmp2_;
	arr_length1 = _vala_array_length (_tmp1_);
	_arr_size_ = arr_length1;
	_tmp3_ = arr[arr_length1 - 1];
	_tmp4_ = g_strdup_printf ("%s", _tmp3_);
	result = _tmp4_;
	arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


GeeArrayList* sorted_list_from_collection (GeeCollection* iter) {
	GeeArrayList* result = NULL;
	GeeArrayList* l = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeCollection* _tmp1_ = NULL;
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	l = _tmp0_;
	_tmp1_ = iter;
	gee_array_list_add_all (l, _tmp1_);
	gee_list_sort ((GeeList*) l, (GCompareDataFunc) natural_cmp, NULL, NULL);
	result = l;
	return result;
}


void builder_append (GString* builder, const gchar* val) {
	const gchar* _tmp0_ = NULL;
	GString* _tmp1_ = NULL;
	GString* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (builder != NULL);
	_tmp0_ = val;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = builder;
	g_string_append (_tmp1_, " ");
	_tmp2_ = builder;
	_tmp3_ = val;
	g_string_append (_tmp2_, _tmp3_);
	return;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		menu_entry_destroy (&_data3_->entry);
		g_slice_free (Block3Data, _data3_);
	}
}


static void __lambda67_ (Block3Data* _data3_, GSimpleAction* a, GVariant* p) {
	MenuEntry _tmp0_ = {0};
	MenuCallbackWrapper* _tmp1_ = NULL;
	MenuCallback _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	g_return_if_fail (a != NULL);
	_tmp0_ = _data3_->entry;
	_tmp1_ = _tmp0_.method;
	_tmp2_ = _tmp1_->run;
	_tmp2__target = _tmp1_->run_target;
	_tmp2_ (_tmp2__target);
}


static void ___lambda67__g_simple_action_activate (GSimpleAction* _sender, GVariant* parameter, gpointer self) {
	__lambda67_ (self, _sender, parameter);
}


void add_action_from_menu_entry (GActionMap* map, MenuEntry* entry) {
	Block3Data* _data3_;
	MenuEntry _tmp0_ = {0};
	MenuEntry _tmp1_ = {0};
	GSimpleAction* action = NULL;
	MenuEntry _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	GSimpleAction* _tmp4_ = NULL;
	GActionMap* _tmp5_ = NULL;
	g_return_if_fail (map != NULL);
	g_return_if_fail (entry != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_tmp0_ = *entry;
	menu_entry_copy (&_tmp0_, &_tmp1_);
	menu_entry_destroy (&_data3_->entry);
	_data3_->entry = _tmp1_;
	_tmp2_ = _data3_->entry;
	_tmp3_ = _tmp2_.action_name;
	_tmp4_ = g_simple_action_new (_tmp3_, NULL);
	action = _tmp4_;
	g_signal_connect_data (action, "activate", (GCallback) ___lambda67__g_simple_action_activate, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
	_tmp5_ = map;
	g_action_map_add_action (_tmp5_, (GAction*) action);
	_g_object_unref0 (action);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return;
}


gboolean remove_directory_tree_if_empty (GFile* dir) {
	gboolean result = FALSE;
	GFile* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = dir;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	{
		GFileEnumerator* enumerator = NULL;
		GFile* _tmp1_ = NULL;
		GFileEnumerator* _tmp2_ = NULL;
		GFileInfo* _tmp3_ = NULL;
		GFileEnumerator* _tmp4_ = NULL;
		GFileInfo* _tmp5_ = NULL;
		GFileInfo* _tmp6_ = NULL;
		GFileInfo* _tmp7_ = NULL;
		gboolean _tmp8_ = FALSE;
		GFile* parent = NULL;
		GFile* _tmp9_ = NULL;
		GFile* _tmp10_ = NULL;
		GFile* _tmp11_ = NULL;
		GFile* _tmp12_ = NULL;
		_tmp1_ = dir;
		_tmp2_ = g_file_enumerate_children (_tmp1_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
		enumerator = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch29_g_error;
		}
		_tmp4_ = enumerator;
		_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error_);
		_tmp3_ = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (enumerator);
			goto __catch29_g_error;
		}
		_tmp6_ = _tmp3_;
		_tmp3_ = NULL;
		_tmp7_ = _tmp6_;
		_tmp8_ = _tmp7_ != NULL;
		_g_object_unref0 (_tmp7_);
		if (_tmp8_) {
			result = FALSE;
			_g_object_unref0 (_tmp3_);
			_g_object_unref0 (enumerator);
			return result;
		}
		_tmp9_ = dir;
		_tmp10_ = g_file_get_parent (_tmp9_);
		parent = _tmp10_;
		_tmp11_ = dir;
		g_file_delete (_tmp11_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (parent);
			_g_object_unref0 (_tmp3_);
			_g_object_unref0 (enumerator);
			goto __catch29_g_error;
		}
		_tmp12_ = parent;
		if (_tmp12_ != NULL) {
			GFile* _tmp13_ = NULL;
			_tmp13_ = parent;
			remove_directory_tree_if_empty (_tmp13_);
		}
		_g_object_unref0 (parent);
		_g_object_unref0 (_tmp3_);
		_g_object_unref0 (enumerator);
	}
	goto __finally29;
	__catch29_g_error:
	{
		GError* e = NULL;
		GError* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		g_warning ("Utils.vala:135: %s", _tmp15_);
		_g_error_free0 (e);
	}
	__finally29:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


gboolean remove_directory (GFile* dir, gboolean recursive) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (dir != NULL, FALSE);
	{
		gboolean _tmp0_ = FALSE;
		GFile* _tmp19_ = NULL;
		_tmp0_ = recursive;
		if (_tmp0_) {
			GFileInfo* fileinfo = NULL;
			GFileEnumerator* enumerator = NULL;
			GFile* _tmp1_ = NULL;
			GFileEnumerator* _tmp2_ = NULL;
			_tmp1_ = dir;
			_tmp2_ = g_file_enumerate_children (_tmp1_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
			enumerator = _tmp2_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (fileinfo);
				goto __catch30_g_error;
			}
			while (TRUE) {
				GFileInfo* _tmp3_ = NULL;
				GFileEnumerator* _tmp4_ = NULL;
				GFileInfo* _tmp5_ = NULL;
				GFileInfo* _tmp6_ = NULL;
				GFileInfo* _tmp7_ = NULL;
				_tmp4_ = enumerator;
				_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error_);
				_tmp3_ = _tmp5_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (enumerator);
					_g_object_unref0 (fileinfo);
					goto __catch30_g_error;
				}
				_tmp6_ = _tmp3_;
				_tmp3_ = NULL;
				_g_object_unref0 (fileinfo);
				fileinfo = _tmp6_;
				_tmp7_ = fileinfo;
				if (!(_tmp7_ != NULL)) {
					_g_object_unref0 (_tmp3_);
					break;
				}
				{
					GFile* _tmp8_ = NULL;
					GFileInfo* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					GFile* _tmp11_ = NULL;
					GFile* _tmp12_ = NULL;
					_tmp8_ = dir;
					_tmp9_ = fileinfo;
					_tmp10_ = g_file_info_get_name (_tmp9_);
					_tmp11_ = g_file_get_child (_tmp8_, _tmp10_);
					_tmp12_ = _tmp11_;
					g_file_delete (_tmp12_, NULL, &_inner_error_);
					_g_object_unref0 (_tmp12_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch31_g_error;
					}
				}
				goto __finally31;
				__catch31_g_error:
				{
					GError* e = NULL;
					GFile* _tmp13_ = NULL;
					GFileInfo* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					GFile* _tmp16_ = NULL;
					GFile* _tmp17_ = NULL;
					gboolean _tmp18_ = FALSE;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp13_ = dir;
					_tmp14_ = fileinfo;
					_tmp15_ = g_file_info_get_name (_tmp14_);
					_tmp16_ = g_file_get_child (_tmp13_, _tmp15_);
					_tmp17_ = _tmp16_;
					_tmp18_ = recursive;
					remove_directory (_tmp17_, _tmp18_);
					_g_object_unref0 (_tmp17_);
					_g_error_free0 (e);
				}
				__finally31:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (_tmp3_);
					_g_object_unref0 (enumerator);
					_g_object_unref0 (fileinfo);
					goto __catch30_g_error;
				}
				_g_object_unref0 (_tmp3_);
			}
			_g_object_unref0 (enumerator);
			_g_object_unref0 (fileinfo);
		}
		_tmp19_ = dir;
		g_file_delete (_tmp19_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch30_g_error;
		}
		result = TRUE;
		return result;
	}
	goto __finally30;
	__catch30_g_error:
	{
		GError* e = NULL;
		GError* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = e;
		_tmp21_ = _tmp20_->message;
		g_warning ("Utils.vala:156: %s", _tmp21_);
		_g_error_free0 (e);
	}
	__finally30:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = FALSE;
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



